From e63c8ba747db6f056b387307d2cbf031779360f1 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Sun, 31 May 2015 17:36:21 +0200
Subject: [PATCH 01/21] renderer: promote interface up to BaseRenderer

---
 xbmc/cores/VideoRenderers/BaseRenderer.h      | 49 +++++++++++++++--------
 xbmc/cores/VideoRenderers/LinuxRendererGL.cpp | 56 +++++++++++++++------------
 xbmc/cores/VideoRenderers/LinuxRendererGL.h   | 42 +++++++-------------
 xbmc/cores/VideoRenderers/RenderManager.cpp   | 44 ++++++---------------
 xbmc/cores/VideoRenderers/RenderManager.h     | 12 +-----
 5 files changed, 90 insertions(+), 113 deletions(-)

diff --git a/xbmc/cores/VideoRenderers/BaseRenderer.h b/xbmc/cores/VideoRenderers/BaseRenderer.h
index 5760714..ead7782 100644
--- a/xbmc/cores/VideoRenderers/BaseRenderer.h
+++ b/xbmc/cores/VideoRenderers/BaseRenderer.h
@@ -26,6 +26,7 @@
 #include "guilib/Geometry.h"
 #include "RenderFormats.h"
 #include "RenderFeatures.h"
+#include "settings/VideoSettings.h"
 
 #define MAX_PLANES 3
 #define MAX_FIELDS 3
@@ -71,6 +72,7 @@ typedef void (*RenderUpdateCallBackFn)(const void *ctx, const CRect &SrcRect, co
 typedef void (*RenderFeaturesCallBackFn)(const void *ctx, Features &renderFeatures);
 
 struct DVDVideoPicture;
+class CRenderCapture;
 
 class CBaseRenderer
 {
@@ -78,6 +80,37 @@ public:
   CBaseRenderer();
   virtual ~CBaseRenderer();
 
+  // Player functions
+  virtual bool Configure(unsigned int width, unsigned int height, unsigned int d_width, unsigned int d_height, float fps, unsigned flags, ERenderFormat format, unsigned extended_formatl, unsigned int orientation) = 0;
+  virtual bool IsConfigured() = 0;
+  virtual int GetImage(YV12Image *image, int source = -1, bool readonly = false) = 0;
+  virtual void ReleaseImage(int source, bool preserve = false) = 0;
+  virtual bool AddVideoPicture(DVDVideoPicture* picture, int index) { return false; }
+  virtual void AddVideoPictureHW(DVDVideoPicture &picture, int index) = 0;
+  virtual void FlipPage(int source) = 0;
+  virtual unsigned int PreInit() = 0;
+  virtual void UnInit() = 0;
+  virtual void Reset() = 0;
+  virtual void Flush() {};
+  virtual void SetBufferSize(int numBuffers) { }
+  virtual void ReleaseBuffer(int idx) { }
+  virtual bool NeedBufferForRef(int idx) { return false; }
+  virtual bool IsGuiLayer() { return true; }
+  // Render info, can be called before configure
+  virtual CRenderInfo GetRenderInfo() { return CRenderInfo(); }
+  virtual void Update() = 0;
+  virtual void RenderUpdate(bool clear, unsigned int flags = 0, unsigned int alpha = 255) = 0;
+  virtual void SetupScreenshot() = 0;
+  virtual bool RenderCapture(CRenderCapture* capture) = 0;
+  virtual EINTERLACEMETHOD AutoInterlaceMethod() = 0;
+
+  // Feature support
+  virtual bool SupportsMultiPassRendering() = 0;
+  virtual bool Supports(ERENDERFEATURE feature) { return false; };
+  virtual bool Supports(EDEINTERLACEMODE mode) = 0;
+  virtual bool Supports(EINTERLACEMETHOD method) = 0;
+  virtual bool Supports(ESCALINGMETHOD method) = 0;
+
   void SetViewMode(int viewMode);
   RESOLUTION GetResolution() const;
 
@@ -89,22 +122,6 @@ public:
   void GetVideoRect(CRect &source, CRect &dest, CRect &view);
   float GetAspectRatio() const;
 
-  virtual bool AddVideoPicture(DVDVideoPicture* picture, int index) { return false; }
-  virtual void Flush() {};
-
-  /**
-   * Returns number of references a single buffer can retain when rendering a single frame
-   */
-  virtual void         SetBufferSize(int numBuffers) { }
-  virtual void         ReleaseBuffer(int idx) { }
-  virtual bool         NeedBufferForRef(int idx) { return false; }
-  virtual bool         IsGuiLayer() { return true; }
-
-  virtual bool Supports(ERENDERFEATURE feature) { return false; }
-
-  // Render info, can be called before configure
-  virtual CRenderInfo GetRenderInfo() { return CRenderInfo(); }
-
   virtual void RegisterRenderUpdateCallBack(const void *ctx, RenderUpdateCallBackFn fn);
   virtual void RegisterRenderFeaturesCallBack(const void *ctx, RenderFeaturesCallBackFn fn);
 
diff --git a/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp b/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
index aee894b..f782224 100644
--- a/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
+++ b/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
@@ -3473,36 +3473,42 @@ CRenderInfo CLinuxRendererGL::GetRenderInfo()
   return info;
 }
 
-#ifdef HAVE_LIBVDPAU
-void CLinuxRendererGL::AddProcessor(VDPAU::CVdpauRenderPicture *vdpau, int index)
+void CLinuxRendererGL::AddVideoPictureHW(DVDVideoPicture &picture, int index)
 {
-  YUVBUFFER &buf = m_buffers[index];
-  VDPAU::CVdpauRenderPicture *pic = vdpau->Acquire();
-  SAFE_RELEASE(buf.vdpau);
-  buf.vdpau = pic;
-}
+  if (picture.format == RENDER_FMT_VDPAU ||
+      picture.format == RENDER_FMT_VDPAU_420)
+  {
+#ifdef HAVE_LIBVDPAU
+    VDPAU::CVdpauRenderPicture *vdpau = picture.vdpau;
+    YUVBUFFER &buf = m_buffers[index];
+    VDPAU::CVdpauRenderPicture *pic = vdpau->Acquire();
+    SAFE_RELEASE(buf.vdpau);
+    buf.vdpau = pic;
 #endif
-
+  }
+  else if (picture.format == RENDER_FMT_VAAPI ||
+           picture.format == RENDER_FMT_VAAPINV12)
+  {
 #ifdef HAVE_LIBVA
-void CLinuxRendererGL::AddProcessor(VAAPI::CVaapiRenderPicture *vaapi, int index)
-{
-  YUVBUFFER &buf = m_buffers[index];
-  VAAPI::CVaapiRenderPicture *pic = vaapi->Acquire();
-  SAFE_RELEASE(buf.vaapi);
-  buf.vaapi = pic;
-}
+    VAAPI::CVaapiRenderPicture *vaapi = picture.vaapi;
+    YUVBUFFER &buf = m_buffers[index];
+    VAAPI::CVaapiRenderPicture *pic = vaapi->Acquire();
+    SAFE_RELEASE(buf.vaapi);
+    buf.vaapi = pic;
 #endif
-
+  }
+  else if (picture.format == RENDER_FMT_CVBREF)
+  {
 #ifdef TARGET_DARWIN
-void CLinuxRendererGL::AddProcessor(struct __CVBuffer *cvBufferRef, int index)
-{
-  YUVBUFFER &buf = m_buffers[index];
-  if (buf.cvBufferRef)
-    CVBufferRelease(buf.cvBufferRef);
-  buf.cvBufferRef = cvBufferRef;
-  // retain another reference, this way dvdplayer and renderer can issue releases.
-  CVBufferRetain(buf.cvBufferRef);
-}
+    struct __CVBuffer *cvBufferRef = picture.cvBufferRef;
+    YUVBUFFER &buf = m_buffers[index];
+    if (buf.cvBufferRef)
+       CVBufferRelease(buf.cvBufferRef);
+    buf.cvBufferRef = cvBufferRef;
+    // retain another reference, this way dvdplayer and renderer can issue releases.
+    CVBufferRetain(buf.cvBufferRef);
 #endif
+  }
+}
 
 #endif
diff --git a/xbmc/cores/VideoRenderers/LinuxRendererGL.h b/xbmc/cores/VideoRenderers/LinuxRendererGL.h
index fcdea8d..2ae7ad6 100644
--- a/xbmc/cores/VideoRenderers/LinuxRendererGL.h
+++ b/xbmc/cores/VideoRenderers/LinuxRendererGL.h
@@ -117,35 +117,25 @@ public:
   CLinuxRendererGL();
   virtual ~CLinuxRendererGL();
 
-  virtual void Update();
-  virtual void SetupScreenshot() {};
-
-  bool RenderCapture(CRenderCapture* capture);
-
   // Player functions
   virtual bool Configure(unsigned int width, unsigned int height, unsigned int d_width, unsigned int d_height, float fps, unsigned flags, ERenderFormat format, unsigned extended_formatl, unsigned int orientation);
   virtual bool IsConfigured() { return m_bConfigured; }
-  virtual int          GetImage(YV12Image *image, int source = AUTOSOURCE, bool readonly = false);
-  virtual void         ReleaseImage(int source, bool preserve = false);
-  virtual void         FlipPage(int source);
+  virtual int GetImage(YV12Image *image, int source = AUTOSOURCE, bool readonly = false);
+  virtual void ReleaseImage(int source, bool preserve = false);
+  virtual void AddVideoPictureHW(DVDVideoPicture &picture, int index);
+  virtual void FlipPage(int source);
   virtual unsigned int PreInit();
-  virtual void         UnInit();
-  virtual void         Reset(); /* resets renderer after seek for example */
-  virtual void         Flush();
-  virtual void         ReleaseBuffer(int idx);
-  virtual void         SetBufferSize(int numBuffers) { m_NumYV12Buffers = numBuffers; }
-
-#ifdef HAVE_LIBVDPAU
-  virtual void         AddProcessor(VDPAU::CVdpauRenderPicture* vdpau, int index);
-#endif
-#ifdef HAVE_LIBVA
-  virtual void         AddProcessor(VAAPI::CVaapiRenderPicture* vaapi, int index);
-#endif
-#ifdef TARGET_DARWIN
-  virtual void         AddProcessor(struct __CVBuffer *cvBufferRef, int index);
-#endif
-
+  virtual void UnInit();
+  virtual void Reset(); /* resets renderer after seek for example */
+  virtual void Flush();
+  virtual void ReleaseBuffer(int idx);
+  virtual void SetBufferSize(int numBuffers) { m_NumYV12Buffers = numBuffers; }
   virtual void RenderUpdate(bool clear, DWORD flags = 0, DWORD alpha = 255);
+  virtual void Update();
+  virtual void SetupScreenshot() {};
+  virtual bool RenderCapture(CRenderCapture* capture);
+  virtual EINTERLACEMETHOD AutoInterlaceMethod();
+  virtual CRenderInfo GetRenderInfo();
 
   // Feature support
   virtual bool SupportsMultiPassRendering();
@@ -154,10 +144,6 @@ public:
   virtual bool Supports(EINTERLACEMETHOD method);
   virtual bool Supports(ESCALINGMETHOD method);
 
-  virtual EINTERLACEMETHOD AutoInterlaceMethod();
-
-  virtual CRenderInfo GetRenderInfo();
-
 protected:
   virtual void Render(DWORD flags, int renderBuffer);
   void         ClearBackBuffer();
diff --git a/xbmc/cores/VideoRenderers/RenderManager.cpp b/xbmc/cores/VideoRenderers/RenderManager.cpp
index 7f43949..dfd7a87 100644
--- a/xbmc/cores/VideoRenderers/RenderManager.cpp
+++ b/xbmc/cores/VideoRenderers/RenderManager.cpp
@@ -967,6 +967,7 @@ int CXBMCRenderManager::AddVideoPicture(DVDVideoPicture& pic)
     index = m_free.front();
   }
 
+  // TODO: this is a Windows onl thing and should go away
   if(m_pRenderer->AddVideoPicture(&pic, index))
     return 1;
 
@@ -993,44 +994,21 @@ int CXBMCRenderManager::AddVideoPicture(DVDVideoPicture& pic)
   {
     CDVDCodecUtils::CopyDXVA2Picture(&image, &pic);
   }
-#ifdef HAVE_LIBVDPAU
   else if(pic.format == RENDER_FMT_VDPAU
-       || pic.format == RENDER_FMT_VDPAU_420)
-    m_pRenderer->AddProcessor(pic.vdpau, index);
-#endif
-#ifdef HAVE_LIBOPENMAX
-  else if(pic.format == RENDER_FMT_OMXEGL)
-    m_pRenderer->AddProcessor(pic.openMax, &pic, index);
-#endif
-#ifdef TARGET_DARWIN
-  else if(pic.format == RENDER_FMT_CVBREF)
-    m_pRenderer->AddProcessor(pic.cvBufferRef, index);
-#endif
-#ifdef HAVE_LIBVA
-  else if(pic.format == RENDER_FMT_VAAPI)
-    m_pRenderer->AddProcessor(pic.vaapi, index);
+       || pic.format == RENDER_FMT_VDPAU_420
+       || pic.format == RENDER_FMT_OMXEGL
+       || pic.format == RENDER_FMT_CVBREF
+       || pic.format == RENDER_FMT_VAAPI
+       || pic.format == RENDER_FMT_EGLIMG
+       || pic.format == RENDER_FMT_MEDIACODEC
+       || pic.format == RENDER_FMT_IMXMAP
+       || pic.format == RENDER_FMT_MMAL)
+    m_pRenderer->AddVideoPictureHW(pic, index);
   else if(pic.format == RENDER_FMT_VAAPINV12)
   {
-    m_pRenderer->AddProcessor(pic.vaapi, index);
+    m_pRenderer->AddVideoPictureHW(pic, index);
     CDVDCodecUtils::CopyNV12Picture(&image, &pic.vaapi->DVDPic);
   }
-#endif
-#ifdef HAS_LIBSTAGEFRIGHT
-  else if(pic.format == RENDER_FMT_EGLIMG)
-    m_pRenderer->AddProcessor(pic.stf, pic.eglimg, index);
-#endif
-#if defined(TARGET_ANDROID)
-  else if(pic.format == RENDER_FMT_MEDIACODEC)
-    m_pRenderer->AddProcessor(pic.mediacodec, index);
-#endif
-#ifdef HAS_IMXVPU
-  else if(pic.format == RENDER_FMT_IMXMAP)
-    m_pRenderer->AddProcessor(pic.IMXBuffer, index);
-#endif
-#ifdef HAS_MMAL
-  else if(pic.format == RENDER_FMT_MMAL)
-    m_pRenderer->AddProcessor(pic.MMALBuffer, index);
-#endif
 
   m_pRenderer->ReleaseImage(index, false);
 
diff --git a/xbmc/cores/VideoRenderers/RenderManager.h b/xbmc/cores/VideoRenderers/RenderManager.h
index f43bff1..87573a5 100644
--- a/xbmc/cores/VideoRenderers/RenderManager.h
+++ b/xbmc/cores/VideoRenderers/RenderManager.h
@@ -150,17 +150,7 @@ public:
 
   void UpdateResolution();
 
-#ifdef HAS_GL
-  CLinuxRendererGL    *m_pRenderer;
-#elif defined(HAS_MMAL)
-  CMMALRenderer       *m_pRenderer;
-#elif HAS_GLES == 2
-  CLinuxRendererGLES  *m_pRenderer;
-#elif defined(HAS_DX)
-  CWinRenderer        *m_pRenderer;
-#elif defined(HAS_SDL)
-  CLinuxRenderer      *m_pRenderer;
-#endif
+  CBaseRenderer *m_pRenderer;
 
   // Get renderer info, can be called before configure
   CRenderInfo GetRenderInfo();
-- 
1.9.1


From 2d4d3481b27d70e220ec52f37699d07d03ab99fe Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Mon, 1 Jun 2015 13:56:29 +0200
Subject: [PATCH 02/21] renderer: refactor RenderManager and LinuxRendererGL

---
 Kodi.xcodeproj/project.pbxproj                     |   59 +-
 Makefile.in                                        |    1 +
 configure.ac                                       |    1 +
 xbmc/Application.cpp                               |    2 +-
 xbmc/cores/VideoRenderers/BaseRenderer.h           |    6 +-
 xbmc/cores/VideoRenderers/DXVAHD.cpp               |  522 ----------
 xbmc/cores/VideoRenderers/DXVAHD.h                 |   91 --
 xbmc/cores/VideoRenderers/HwDecRender/DXVAHD.cpp   |  522 ++++++++++
 xbmc/cores/VideoRenderers/HwDecRender/DXVAHD.h     |   91 ++
 .../VideoRenderers/HwDecRender/MMALRenderer.cpp    |  722 ++++++++++++++
 .../VideoRenderers/HwDecRender/MMALRenderer.h      |  117 +++
 xbmc/cores/VideoRenderers/HwDecRender/Makefile     |   15 +
 xbmc/cores/VideoRenderers/HwDecRender/Makefile.in  |   15 +
 .../VideoRenderers/HwDecRender/RendererVAAPI.cpp   |  264 +++++
 .../VideoRenderers/HwDecRender/RendererVAAPI.h     |   56 ++
 .../VideoRenderers/HwDecRender/RendererVDA.cpp     |  174 ++++
 .../cores/VideoRenderers/HwDecRender/RendererVDA.h |   54 +
 .../VideoRenderers/HwDecRender/RendererVDPAU.cpp   |  418 ++++++++
 .../VideoRenderers/HwDecRender/RendererVDPAU.h     |   64 ++
 xbmc/cores/VideoRenderers/LinuxRendererGL.cpp      | 1031 +++++---------------
 xbmc/cores/VideoRenderers/LinuxRendererGL.h        |   46 +-
 xbmc/cores/VideoRenderers/MMALRenderer.cpp         |  722 --------------
 xbmc/cores/VideoRenderers/MMALRenderer.h           |  117 ---
 xbmc/cores/VideoRenderers/Makefile.in              |    4 -
 xbmc/cores/VideoRenderers/RenderManager.cpp        |  387 +++++---
 xbmc/cores/VideoRenderers/RenderManager.h          |  102 +-
 xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp     |    1 -
 xbmc/cores/dvdplayer/DVDPlayerVideo.cpp            |  135 +--
 xbmc/cores/dvdplayer/DVDPlayerVideo.h              |   17 -
 xbmc/guilib/GUIVideoControl.cpp                    |    4 +-
 30 files changed, 3126 insertions(+), 2634 deletions(-)
 delete mode 100644 xbmc/cores/VideoRenderers/DXVAHD.cpp
 delete mode 100644 xbmc/cores/VideoRenderers/DXVAHD.h
 create mode 100644 xbmc/cores/VideoRenderers/HwDecRender/DXVAHD.cpp
 create mode 100644 xbmc/cores/VideoRenderers/HwDecRender/DXVAHD.h
 create mode 100644 xbmc/cores/VideoRenderers/HwDecRender/MMALRenderer.cpp
 create mode 100644 xbmc/cores/VideoRenderers/HwDecRender/MMALRenderer.h
 create mode 100644 xbmc/cores/VideoRenderers/HwDecRender/Makefile
 create mode 100644 xbmc/cores/VideoRenderers/HwDecRender/Makefile.in
 create mode 100644 xbmc/cores/VideoRenderers/HwDecRender/RendererVAAPI.cpp
 create mode 100644 xbmc/cores/VideoRenderers/HwDecRender/RendererVAAPI.h
 create mode 100644 xbmc/cores/VideoRenderers/HwDecRender/RendererVDA.cpp
 create mode 100644 xbmc/cores/VideoRenderers/HwDecRender/RendererVDA.h
 create mode 100644 xbmc/cores/VideoRenderers/HwDecRender/RendererVDPAU.cpp
 create mode 100644 xbmc/cores/VideoRenderers/HwDecRender/RendererVDPAU.h
 delete mode 100644 xbmc/cores/VideoRenderers/MMALRenderer.cpp
 delete mode 100644 xbmc/cores/VideoRenderers/MMALRenderer.h

diff --git a/Kodi.xcodeproj/project.pbxproj b/Kodi.xcodeproj/project.pbxproj
index ce5a7f7..cf6fa57 100644
--- a/Kodi.xcodeproj/project.pbxproj
+++ b/Kodi.xcodeproj/project.pbxproj
@@ -6,26 +6,6 @@
 	objectVersion = 46;
 	objects = {
 
-/* Begin PBXNativeTarget section */
-		6E2FACBA0E26DF7A00DF79EA /* Kodi.app */ = {
-			isa = PBXNativeTarget;
-			buildConfigurationList = 6E2FACC10E26DFA300DF79EA /* Build configuration list for PBXNativeTarget "Kodi.app" */;
-			buildPhases = (
-				F5DEC3580E6DEBB2005A4E24 /* copy root files */,
-				6E2FACC70E26E22400DF79EA /* copy frameworks */,
-				81B8FC150E7D927A00354E2E /* update version info */,
-				1D64E5FC157BD76F001ACEBE /* genoutputdirlink */,
-			);
-			dependencies = (
-				6E2FACC40E26E08100DF79EA /* PBXTargetDependency */,
-			);
-			name = Kodi.app;
-			productName = Kodi.app;
-			productReference = D6299ABB1AFC2A9F00E3059D /* Kodi.app */;
-			productType = "com.apple.product-type.application";
-		};
-/* End PBXAggregateTarget section */
-
 /* Begin PBXBuildFile section */
 		0E3036EC1760F68A00D93596 /* FavouritesDirectory.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 0E3036EA1760F68A00D93596 /* FavouritesDirectory.cpp */; };
 		0E3036ED1760F68A00D93596 /* FavouritesDirectory.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 0E3036EA1760F68A00D93596 /* FavouritesDirectory.cpp */; };
@@ -397,6 +377,7 @@
 		7CAA469019427AED00008885 /* PosixDirectory.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 7CAA468E19427AED00008885 /* PosixDirectory.cpp */; };
 		7CAA469119427AED00008885 /* PosixDirectory.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 7CAA468E19427AED00008885 /* PosixDirectory.cpp */; };
 		7CAA469219427AED00008885 /* PosixDirectory.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 7CAA468E19427AED00008885 /* PosixDirectory.cpp */; };
+		7CBB101F1B1E1C7D00E4FDE5 /* RendererVDA.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 7CBB101D1B1E1C7D00E4FDE5 /* RendererVDA.cpp */; };
 		7CBEBB8412912BA400431822 /* fstrcmp.c in Sources */ = {isa = PBXBuildFile; fileRef = 7CBEBB8212912BA300431822 /* fstrcmp.c */; };
 		7CC30DB116291A5C003E7579 /* MusicThumbLoader.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 7CC30DAF16291A5C003E7579 /* MusicThumbLoader.cpp */; };
 		7CC30DC016291C2C003E7579 /* VideoThumbLoader.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 7CC30DBE16291C2C003E7579 /* VideoThumbLoader.cpp */; };
@@ -3785,6 +3766,8 @@
 		7CAA25381085971C0096DE39 /* ScraperUrl.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ScraperUrl.h; sourceTree = "<group>"; };
 		7CAA468E19427AED00008885 /* PosixDirectory.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = PosixDirectory.cpp; sourceTree = "<group>"; };
 		7CAA468F19427AED00008885 /* PosixDirectory.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = PosixDirectory.h; sourceTree = "<group>"; };
+		7CBB101D1B1E1C7D00E4FDE5 /* RendererVDA.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = RendererVDA.cpp; path = HwDecRender/RendererVDA.cpp; sourceTree = "<group>"; };
+		7CBB101E1B1E1C7D00E4FDE5 /* RendererVDA.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = RendererVDA.h; path = HwDecRender/RendererVDA.h; sourceTree = "<group>"; };
 		7CBEBB8212912BA300431822 /* fstrcmp.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = fstrcmp.c; sourceTree = "<group>"; };
 		7CC30DAF16291A5C003E7579 /* MusicThumbLoader.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = MusicThumbLoader.cpp; sourceTree = "<group>"; };
 		7CC30DB016291A5C003E7579 /* MusicThumbLoader.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = MusicThumbLoader.h; sourceTree = "<group>"; };
@@ -4198,7 +4181,6 @@
 		889B4D8D0E0EF86C00FAD25E /* RSSDirectory.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = RSSDirectory.h; sourceTree = "<group>"; };
 		88ECB6580DE013C4003396A7 /* DiskArbitration.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = DiskArbitration.framework; path = /System/Library/Frameworks/DiskArbitration.framework; sourceTree = "<absolute>"; };
 		8DD76F7E0486A8DE00D96B5E /* Kodi */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.executable"; includeInIndex = 0; path = Kodi; sourceTree = BUILT_PRODUCTS_DIR; };
-		D6299ABB1AFC2A9F00E3059D /* Kodi.app */ = {isa = PBXFileReference; explicitFileType = wrapper.application; includeInIndex = 0; path = Kodi.app; sourceTree = BUILT_PRODUCTS_DIR; };
 		AE4E87A517354C4A00D15206 /* XSLTUtils.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = XSLTUtils.cpp; sourceTree = "<group>"; };
 		AE4E87A617354C4A00D15206 /* XSLTUtils.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = XSLTUtils.h; sourceTree = "<group>"; };
 		AE84CB5915A5B8A600A3810E /* TagLibVFSStream.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = TagLibVFSStream.cpp; sourceTree = "<group>"; };
@@ -4315,6 +4297,7 @@
 		C8D0B2AE1265A9A800F0C0AC /* SystemGlobals.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = SystemGlobals.cpp; sourceTree = "<group>"; };
 		C8EC5D0C1369519D00CCC10D /* XBMC_keytable.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = XBMC_keytable.cpp; sourceTree = "<group>"; };
 		C8EC5D0D1369519D00CCC10D /* XBMC_keytable.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = XBMC_keytable.h; sourceTree = "<group>"; };
+		D6299ABB1AFC2A9F00E3059D /* Kodi.app */ = {isa = PBXFileReference; explicitFileType = wrapper.application; includeInIndex = 0; path = Kodi.app; sourceTree = BUILT_PRODUCTS_DIR; };
 		DF00492B162DAEA200A971AD /* PVROperations.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = PVROperations.cpp; sourceTree = "<group>"; };
 		DF00492C162DAEA200A971AD /* PVROperations.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = PVROperations.h; sourceTree = "<group>"; };
 		DF02BA601A910623006DCA16 /* VideoSyncIos.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = VideoSyncIos.cpp; path = videosync/VideoSyncIos.cpp; sourceTree = "<group>"; };
@@ -5429,7 +5412,7 @@
 		E46F7C2B0F77219700C25D29 /* ZeroconfOSX.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ZeroconfOSX.h; sourceTree = "<group>"; };
 		E46F7C2C0F77219700C25D29 /* ZeroconfOSX.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = ZeroconfOSX.cpp; sourceTree = "<group>"; };
 		E47252BF175115F9001C1AAA /* Codesign.command */ = {isa = PBXFileReference; lastKnownFileType = text.script.sh; path = Codesign.command; sourceTree = "<group>"; };
-		E4991089174D0D2600741B6D /* Kodi.app */ = {isa = PBXFileReference; explicitFileType = wrapper.application; includeInIndex = 0; name = Kodi.app; path = .app; sourceTree = BUILT_PRODUCTS_DIR; };
+		E4991089174D0D2600741B6D /* Kodi.app */ = {isa = PBXFileReference; explicitFileType = wrapper.application; includeInIndex = 0; path = Kodi.app; sourceTree = BUILT_PRODUCTS_DIR; };
 		E499108B174D0D2600741B6D /* UIKit.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = UIKit.framework; path = Library/Frameworks/UIKit.framework; sourceTree = DEVELOPER_DIR; };
 		E499108D174D0D2600741B6D /* Foundation.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = Foundation.framework; path = Library/Frameworks/Foundation.framework; sourceTree = DEVELOPER_DIR; };
 		E499108F174D0D2600741B6D /* CoreGraphics.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = CoreGraphics.framework; path = Library/Frameworks/CoreGraphics.framework; sourceTree = DEVELOPER_DIR; };
@@ -6977,6 +6960,15 @@
 			path = posix;
 			sourceTree = "<group>";
 		};
+		7CBB101C1B1E1C0700E4FDE5 /* HwDecRender */ = {
+			isa = PBXGroup;
+			children = (
+				7CBB101D1B1E1C7D00E4FDE5 /* RendererVDA.cpp */,
+				7CBB101E1B1E1C7D00E4FDE5 /* RendererVDA.h */,
+			);
+			name = HwDecRender;
+			sourceTree = "<group>";
+		};
 		7CCD9F52192753E30074CF51 /* Source */ = {
 			isa = PBXGroup;
 			children = (
@@ -8607,6 +8599,7 @@
 		E38E16580D25F9FA00618676 /* VideoRenderers */ = {
 			isa = PBXGroup;
 			children = (
+				7CBB101C1B1E1C0700E4FDE5 /* HwDecRender */,
 				E38E166B0D25F9FA00618676 /* VideoShaders */,
 				7CAA204F1079C8160096DE39 /* BaseRenderer.cpp */,
 				7CAA20501079C8160096DE39 /* BaseRenderer.h */,
@@ -9721,6 +9714,25 @@
 /* End PBXGroup section */
 
 /* Begin PBXNativeTarget section */
+		6E2FACBA0E26DF7A00DF79EA /* Kodi.app */ = {
+			isa = PBXNativeTarget;
+			buildConfigurationList = 6E2FACC10E26DFA300DF79EA /* Build configuration list for PBXNativeTarget "Kodi.app" */;
+			buildPhases = (
+				F5DEC3580E6DEBB2005A4E24 /* copy root files */,
+				6E2FACC70E26E22400DF79EA /* copy frameworks */,
+				81B8FC150E7D927A00354E2E /* update version info */,
+				1D64E5FC157BD76F001ACEBE /* genoutputdirlink */,
+			);
+			buildRules = (
+			);
+			dependencies = (
+				6E2FACC40E26E08100DF79EA /* PBXTargetDependency */,
+			);
+			name = Kodi.app;
+			productName = Kodi.app;
+			productReference = D6299ABB1AFC2A9F00E3059D /* Kodi.app */;
+			productType = "com.apple.product-type.application";
+		};
 		8DD76F740486A8DE00D96B5E /* Kodi */ = {
 			isa = PBXNativeTarget;
 			buildConfigurationList = 1DEB924708733DCA0010E9CD /* Build configuration list for PBXNativeTarget "Kodi" */;
@@ -10333,6 +10345,7 @@
 				395C29BC1A94733100EBC7AD /* Key.cpp in Sources */,
 				E38E224E0D25F9FE00618676 /* pathfn.cpp in Sources */,
 				395C29F01A98A16300EBC7AD /* HTTPPythonWsgiInvoker.cpp in Sources */,
+				7CBB101F1B1E1C7D00E4FDE5 /* RendererVDA.cpp in Sources */,
 				E38E22500D25F9FE00618676 /* rarvm.cpp in Sources */,
 				E38E22520D25F9FE00618676 /* rawread.cpp in Sources */,
 				E38E22530D25F9FE00618676 /* rdwrfn.cpp in Sources */,
@@ -13611,7 +13624,7 @@
 			defaultConfigurationIsVisible = 0;
 			defaultConfigurationName = Release;
 		};
-		6E2FACC10E26DFA300DF79EA /* Build configuration list for PBXAggregateTarget "Kodi.app" */ = {
+		6E2FACC10E26DFA300DF79EA /* Build configuration list for PBXNativeTarget "Kodi.app" */ = {
 			isa = XCConfigurationList;
 			buildConfigurations = (
 				6E2FACBB0E26DF7A00DF79EA /* Debug */,
diff --git a/Makefile.in b/Makefile.in
index c88f85b..97c1617 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -38,6 +38,7 @@ DIRECTORY_ARCHIVES=$(DVDPLAYER_ARCHIVES) \
                    xbmc/cores/ExternalPlayer/ExternalPlayer.a \
                    xbmc/cores/VideoRenderers/VideoRenderer.a \
                    xbmc/cores/VideoRenderers/VideoShaders/VideoShaders.a \
+                   xbmc/cores/VideoRenderers/HwDecRender/HwDecRender.a \
                    xbmc/cores/cores.a \
                    xbmc/cores/paplayer/paplayer.a \
                    xbmc/cores/playercorefactory/playercorefactory.a \
diff --git a/configure.ac b/configure.ac
index cf945a0..56e3734 100644
--- a/configure.ac
+++ b/configure.ac
@@ -2455,6 +2455,7 @@ OUTPUT_FILES="Makefile \
     xbmc/cdrip/Makefile \
     xbmc/cores/Makefile \
     xbmc/cores/VideoRenderers/Makefile \
+    xbmc/cores/VideoRenderers/HwDecRender/Makefile \
     xbmc/cores/dvdplayer/Makefile \
     lib/libdvd/Makefile \
     xbmc/cores/DllLoader/Makefile \
diff --git a/xbmc/Application.cpp b/xbmc/Application.cpp
index 697f278..7323da1 100644
--- a/xbmc/Application.cpp
+++ b/xbmc/Application.cpp
@@ -3236,7 +3236,7 @@ PlayBackRet CApplication::PlayFile(const CFileItem& item, bool bRestart)
     else if(m_pPlayer->IsPlayingVideo())
     {
       // if player didn't manange to switch to fullscreen by itself do it here
-      if (options.fullscreen && g_renderManager.IsStarted() &&
+      if (options.fullscreen && g_renderManager.IsConfigured() &&
           g_windowManager.GetActiveWindow() != WINDOW_FULLSCREEN_VIDEO )
        SwitchToFullScreen(true);
     }
diff --git a/xbmc/cores/VideoRenderers/BaseRenderer.h b/xbmc/cores/VideoRenderers/BaseRenderer.h
index ead7782..26cdd80 100644
--- a/xbmc/cores/VideoRenderers/BaseRenderer.h
+++ b/xbmc/cores/VideoRenderers/BaseRenderer.h
@@ -86,9 +86,9 @@ public:
   virtual int GetImage(YV12Image *image, int source = -1, bool readonly = false) = 0;
   virtual void ReleaseImage(int source, bool preserve = false) = 0;
   virtual bool AddVideoPicture(DVDVideoPicture* picture, int index) { return false; }
-  virtual void AddVideoPictureHW(DVDVideoPicture &picture, int index) = 0;
+  virtual void AddVideoPictureHW(DVDVideoPicture &picture, int index) {};
   virtual void FlipPage(int source) = 0;
-  virtual unsigned int PreInit() = 0;
+  virtual void PreInit() = 0;
   virtual void UnInit() = 0;
   virtual void Reset() = 0;
   virtual void Flush() {};
@@ -111,6 +111,8 @@ public:
   virtual bool Supports(EINTERLACEMETHOD method) = 0;
   virtual bool Supports(ESCALINGMETHOD method) = 0;
 
+  ERenderFormat GetRenderFormat() { return m_format; }
+
   void SetViewMode(int viewMode);
   RESOLUTION GetResolution() const;
 
diff --git a/xbmc/cores/VideoRenderers/DXVAHD.cpp b/xbmc/cores/VideoRenderers/DXVAHD.cpp
deleted file mode 100644
index 5c6758e..0000000
--- a/xbmc/cores/VideoRenderers/DXVAHD.cpp
+++ /dev/null
@@ -1,522 +0,0 @@
-/*
- *      Copyright (C) 2005-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-
-#ifdef HAS_DX
-
-// setting that here because otherwise SampleFormat is defined to AVSampleFormat
-// which we don't use here
-#define FF_API_OLD_SAMPLE_FMT 0
-
-#include <windows.h>
-#include <d3d9.h>
-#include <Initguid.h>
-#include <dxva2api.h>
-
-#include "DXVAHD.h"
-#include "windowing/WindowingFactory.h"
-#include "settings/Settings.h"
-#include "settings/MediaSettings.h"
-#include "utils/AutoPtrHandle.h"
-#include "utils/StringUtils.h"
-#include "settings/AdvancedSettings.h"
-#include "cores/VideoRenderers/RenderManager.h"
-#include "RenderFlags.h"
-#include "win32/WIN32Util.h"
-#include "utils/Log.h"
-
-using namespace DXVA;
-using namespace AUTOPTR;
-using namespace std;
-
-#define CHECK(a) \
-do { \
-  HRESULT res = a; \
-  if(FAILED(res)) \
-  { \
-    CLog::Log(LOGERROR, __FUNCTION__" - failed executing "#a" at line %d with error %x", __LINE__, res); \
-    return false; \
-  } \
-} while(0);
-
-#define LOGIFERROR(a) \
-do { \
-  HRESULT res = a; \
-  if(FAILED(res)) \
-  { \
-    CLog::Log(LOGERROR, __FUNCTION__" - failed executing "#a" at line %d with error %x", __LINE__, res); \
-  } \
-} while(0);
-
-static std::string GUIDToString(const GUID& guid)
-{
-  std::string buffer = StringUtils::Format("%08X-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x"
-                                          , guid.Data1, guid.Data2, guid.Data3
-                                          , guid.Data4[0], guid.Data4[1]
-                                          , guid.Data4[2], guid.Data4[3], guid.Data4[4]
-                                          , guid.Data4[5], guid.Data4[6], guid.Data4[7]);
-  return buffer;
-}
-
-DXVAHDCreateVideoServicePtr CProcessorHD::m_DXVAHDCreateVideoService = NULL;
-
-CProcessorHD::CProcessorHD()
-{
-  m_pDXVAHD = NULL;
-  m_pDXVAVP = NULL;
-  g_Windowing.Register(this);
-
-  m_context  = NULL;
-}
-
-CProcessorHD::~CProcessorHD()
-{
-  g_Windowing.Unregister(this);
-  UnInit();
-}
-
-void CProcessorHD::UnInit()
-{
-  CSingleLock lock(m_section);
-  Close();
-  SAFE_RELEASE(m_pDXVAHD);
-}
-
-void CProcessorHD::Close()
-{
-  CSingleLock lock(m_section);
-  SAFE_RELEASE(m_pDXVAVP);
-  SAFE_RELEASE(m_context);
-}
-
-bool CProcessorHD::UpdateSize(const DXVA2_VideoDesc& dsc)
-{
-  return true;
-}
-
-bool CProcessorHD::PreInit()
-{
-  if (!LoadSymbols())
-  {
-    CLog::Log(LOGWARNING, __FUNCTION__" - DXVAHD not loaded.");
-    return false;
-  }
-
-  UnInit();
-
-  CSingleLock lock(m_section);
-
-  DXVAHD_RATIONAL fps = { 60, 1 }; 
-  DXVAHD_CONTENT_DESC desc;
-  desc.InputFrameFormat = DXVAHD_FRAME_FORMAT_PROGRESSIVE;
-  desc.InputFrameRate = fps;
-  desc.InputWidth = 640;
-  desc.InputHeight = 480;
-  desc.OutputFrameRate = fps;
-  desc.OutputWidth = 640;
-  desc.OutputHeight = 480;
-
-  HRESULT cvres = m_DXVAHDCreateVideoService( (IDirect3DDevice9Ex*)g_Windowing.Get3DDevice()
-                                              , &desc
-                                              , DXVAHD_DEVICE_USAGE_OPTIMAL_QUALITY
-                                              , NULL
-                                              , &m_pDXVAHD );
-
-  if(FAILED(cvres))
-  {
-    if(cvres == E_NOINTERFACE)
-      CLog::Log(LOGNOTICE, __FUNCTION__" - The Direct3d device doesn't support DXVA-HD.");
-    else
-      CLog::Log(LOGERROR, __FUNCTION__" - failed to create DXVAHD device %x", cvres);
-
-    return false;
-  }
-
-  CHECK(m_pDXVAHD->GetVideoProcessorDeviceCaps( &m_VPDevCaps ));
-
-  if (m_VPDevCaps.VideoProcessorCount == 0)
-  {
-    CLog::Log(LOGWARNING, __FUNCTION__" - unable to find any video processor. GPU drivers doesn't support DXVA-HD.");
-    return false;
-  }
-
-  // Create the array of video processor caps. 
-  DXVAHD_VPCAPS* pVPCaps = new (std::nothrow) DXVAHD_VPCAPS[ m_VPDevCaps.VideoProcessorCount ];
-  if (pVPCaps == NULL)
-  {
-    CLog::Log(LOGERROR, __FUNCTION__" - unable to create video processor caps array. Out of memory.");
-    return false;
-  }
-
-  HRESULT hr = m_pDXVAHD->GetVideoProcessorCaps( m_VPDevCaps.VideoProcessorCount, pVPCaps );
-  if(FAILED(hr))
-  {
-    CLog::Log(LOGERROR, __FUNCTION__" - failed get processor caps with error %x.", hr);
-
-    delete [] pVPCaps;
-    return false;
-  }
-
-  m_max_back_refs = 0;
-  m_max_fwd_refs = 0;
-
-  for (unsigned int i = 0; i < m_VPDevCaps.VideoProcessorCount; i++)
-  {
-    if (pVPCaps[i].FutureFrames > m_max_fwd_refs)
-    {
-      m_max_fwd_refs = pVPCaps[i].FutureFrames;
-    }
-
-    if (pVPCaps[i].PastFrames > m_max_back_refs)
-    {
-      m_max_back_refs = pVPCaps[i].PastFrames;
-    }
-  }
-
-  m_size = m_max_back_refs + 1 + m_max_fwd_refs + 2;  // refs + 1 display + 2 safety frames
-
-  // Get the image filtering capabilities.
-  for (long i = 0; i < NUM_FILTERS; i++)
-  {
-    if (m_VPDevCaps.FilterCaps & (1 << i))
-    {
-      m_pDXVAHD->GetVideoProcessorFilterRange(PROCAMP_FILTERS[i], &m_Filters[i].Range);
-      m_Filters[i].bSupported = true;
-    }
-    else
-    {
-      m_Filters[i].bSupported = false;
-    }
-  }
-
-  m_VPCaps = pVPCaps[0];
-  m_device = m_VPCaps.VPGuid;
-
-  delete [] pVPCaps;
-
-  return true;
-}
-
-bool CProcessorHD::Open(UINT width, UINT height, unsigned int flags, unsigned int format, unsigned int extended_format)
-{
-  Close();
-
-  CSingleLock lock(m_section);
-
-  if (!m_pDXVAHD)
-  {
-    return false;
-  }
-
-  m_width = width;
-  m_height = height;
-  m_flags = flags;
-  m_renderFormat = format;
-
-  if (g_advancedSettings.m_DXVANoDeintProcForProgressive)
-  {
-    CLog::Log(LOGNOTICE, __FUNCTION__" - Auto deinterlacing mode workaround activated. Deinterlacing processor will be used only for interlaced frames.");
-  }
-
-  if (format == RENDER_FMT_DXVA)
-  {
-    m_format = (D3DFORMAT)extended_format;
-  }
-  else
-  {
-    // Only NV12 software colorspace conversion is implemented for now
-    m_format = (D3DFORMAT)MAKEFOURCC('N','V','1','2');
-    if (!CreateSurfaces())
-      return false;
-  }
-
-  if (!OpenProcessor())
-  {
-    return false;
-  }
-
-  return true;
-}
-
-bool CProcessorHD::ReInit()
-{
-  return PreInit() && (m_renderFormat == RENDER_FMT_DXVA || CreateSurfaces());
-}
-
-bool CProcessorHD::OpenProcessor()
-{
-  // restore the device if it was lost
-  if (!m_pDXVAHD && !ReInit())
-  {
-    return false;
-  }
-
-  SAFE_RELEASE(m_pDXVAVP);
-
-  CLog::Log(LOGDEBUG, __FUNCTION__" - processor selected %s.", GUIDToString(m_device).c_str());
-
-  CHECK(m_pDXVAHD->CreateVideoProcessor(&m_device, &m_pDXVAVP));
-
-  DXVAHD_STREAM_STATE_D3DFORMAT_DATA d3dformat = { m_format };
-  CHECK(m_pDXVAVP->SetVideoProcessStreamState( 0, DXVAHD_STREAM_STATE_D3DFORMAT
-                                             , sizeof(d3dformat), &d3dformat ));
-
-  DXVAHD_STREAM_STATE_INPUT_COLOR_SPACE_DATA data =
-  {
-    0,                                          // Type: 0=Video, 1=Graphics
-    0,                                          // RGB_Range: 0=Full, 1=Limited
-    m_flags & CONF_FLAGS_YUVCOEF_BT709 ? 1 : 0, // YCbCr_Matrix: 0=BT.601, 1=BT.709
-    m_flags & CONF_FLAGS_YUV_FULLRANGE ? 1 : 0  // YCbCr_xvYCC: 0=Conventional YCbCr, 1=xvYCC
-  };
-  CHECK(m_pDXVAVP->SetVideoProcessStreamState( 0, DXVAHD_STREAM_STATE_INPUT_COLOR_SPACE
-                                             , sizeof(data), &data ));
-
-  DXVAHD_COLOR_YCbCrA bgColor = { 0.0625f, 0.5f, 0.5f, 1.0f }; // black color
-  DXVAHD_COLOR backgroundColor;
-  backgroundColor.YCbCr = bgColor; 
-  DXVAHD_BLT_STATE_BACKGROUND_COLOR_DATA backgroundData = { true, backgroundColor }; // {YCbCr, DXVAHD_COLOR}
-  CHECK(m_pDXVAVP->SetVideoProcessBltState( DXVAHD_BLT_STATE_BACKGROUND_COLOR
-                                          , sizeof (backgroundData), &backgroundData ));
-
-  DXVAHD_STREAM_STATE_ALPHA_DATA alpha = { true, 1.0f };
-  CHECK(m_pDXVAVP->SetVideoProcessStreamState( 0, DXVAHD_STREAM_STATE_ALPHA
-                                             , sizeof(alpha), &alpha ));
-
-  return true;
-}
-
-bool CProcessorHD::CreateSurfaces()
-{
-  LPDIRECT3DDEVICE9 pD3DDevice = g_Windowing.Get3DDevice();
-  LPDIRECT3DSURFACE9 surfaces[32];
-  for (unsigned idx = 0; idx < m_size; idx++)
-  {
-    CHECK(pD3DDevice->CreateOffscreenPlainSurface(
-      (m_width + 15) & ~15,
-      (m_height + 15) & ~15,
-      m_format,
-      m_VPDevCaps.InputPool,
-      &surfaces[idx],
-      NULL));
-  }
-
-  m_context = new CSurfaceContext();
-  for (int i = 0; i < m_size; i++)
-  {
-    m_context->AddSurface(surfaces[i]);
-  }
-
-  return true;
-}
-
-bool CProcessorHD::ApplyFilter(DXVAHD_FILTER filter, int value, int min, int max, int def)
-{
-  if (filter >= NUM_FILTERS)
-    return false;
-
-  // Unsupported filter. Ignore.
-  if (!m_Filters[filter].bSupported)
-  {
-    return false;
-  }
-
-  DXVAHD_FILTER_RANGE_DATA range = m_Filters[filter].Range;
-  int val;
-
-  if(value > def)
-  {
-    val = range.Default + (range.Maximum - range.Default) * (value - def) / (max - def);
-  }
-  else if(value < def)
-  {
-    val = range.Default + (range.Minimum - range.Default) * (value - def) / (min - def);
-  }
-  else
-  {
-    val = range.Default;
-  }
-
-  DXVAHD_STREAM_STATE_FILTER_DATA data = { true, val };
-  DXVAHD_STREAM_STATE state = static_cast<DXVAHD_STREAM_STATE>(DXVAHD_STREAM_STATE_FILTER_BRIGHTNESS + filter);
-
-  return !FAILED( m_pDXVAVP->SetVideoProcessStreamState( 0, state, sizeof(data), &data ) );
-}
-
-bool CProcessorHD::Render(CRect src, CRect dst, IDirect3DSurface9* target, IDirect3DSurface9** source, DWORD flags, UINT frameIdx)
-{
-  CSingleLock lock(m_section);
-
-  // restore processor if it was lost
-  if(!m_pDXVAVP && !OpenProcessor())
-  {
-    return false;
-  }
-  
-  if (!source[2])
-    return false;
-
-  EDEINTERLACEMODE deinterlace_mode = CMediaSettings::Get().GetCurrentVideoSettings().m_DeinterlaceMode;
-  if (g_advancedSettings.m_DXVANoDeintProcForProgressive)
-    deinterlace_mode = (flags & RENDER_FLAG_FIELD0 || flags & RENDER_FLAG_FIELD1) ? VS_DEINTERLACEMODE_FORCE : VS_DEINTERLACEMODE_OFF;
-  EINTERLACEMETHOD interlace_method = g_renderManager.AutoInterlaceMethod(CMediaSettings::Get().GetCurrentVideoSettings().m_InterlaceMethod);
-
-  bool progressive = deinterlace_mode == VS_DEINTERLACEMODE_OFF
-                  || (   interlace_method != VS_INTERLACEMETHOD_DXVA_BOB
-                      && interlace_method != VS_INTERLACEMETHOD_DXVA_BEST);
-
-  D3DSURFACE_DESC desc;
-  CHECK(target->GetDesc(&desc));
-  CRect rectTarget(0, 0, desc.Width, desc.Height);
-  CWIN32Util::CropSource(src, dst, rectTarget);
-  RECT sourceRECT = { src.x1, src.y1, src.x2, src.y2 };
-  RECT dstRECT    = { dst.x1, dst.y1, dst.x2, dst.y2 };
-
-  DXVAHD_FRAME_FORMAT dxvaFrameFormat = DXVAHD_FRAME_FORMAT_PROGRESSIVE;
-
-  unsigned int providedPast = 0;
-  for (int i = 3; i < 8; i++)
-  {
-    if (source[i])
-      providedPast++;
-  }
-  unsigned int providedFuture = 0;
-  for (int i = 1; i >= 0; i--)
-  {
-    if (source[i])
-      providedFuture++;
-  }
-  int futureFrames = std::min(providedFuture, m_VPCaps.FutureFrames);
-  int pastFrames = std::min(providedPast, m_VPCaps.PastFrames);
-
-  DXVAHD_STREAM_DATA stream_data = { 0 };
-  stream_data.Enable = TRUE;
-  stream_data.PastFrames = pastFrames;
-  stream_data.FutureFrames = futureFrames;
-  stream_data.ppPastSurfaces = new IDirect3DSurface9*[pastFrames];
-  stream_data.ppFutureSurfaces = new IDirect3DSurface9*[futureFrames];
-
-  int start = 2 - futureFrames;
-  int end = 2 + pastFrames;
-
-  for (int i = start; i <= end; i++)
-  {
-    if (!source[i])
-      continue;
-
-    if (i > 2)
-    {
-      // frames order should be { ?, T-3, T-2, T-1 }
-      stream_data.ppPastSurfaces[2+pastFrames-i] = source[i];
-    }
-    else if (i == 2)
-    {
-      stream_data.pInputSurface = source[2];
-    }
-    else if (i < 2)
-    {
-      // frames order should be { T+1, T+2, T+3, .. }
-      stream_data.ppFutureSurfaces[1-i] = source[i];
-    }
-  }
-
-  if (flags & RENDER_FLAG_FIELD0 && flags & RENDER_FLAG_TOP)
-    dxvaFrameFormat = DXVAHD_FRAME_FORMAT_INTERLACED_TOP_FIELD_FIRST;
-  else if (flags & RENDER_FLAG_FIELD1 && flags & RENDER_FLAG_BOT)
-    dxvaFrameFormat = DXVAHD_FRAME_FORMAT_INTERLACED_TOP_FIELD_FIRST;
-  if (flags & RENDER_FLAG_FIELD0 && flags & RENDER_FLAG_BOT)
-    dxvaFrameFormat = DXVAHD_FRAME_FORMAT_INTERLACED_BOTTOM_FIELD_FIRST;
-  if (flags & RENDER_FLAG_FIELD1 && flags & RENDER_FLAG_TOP)
-    dxvaFrameFormat = DXVAHD_FRAME_FORMAT_INTERLACED_BOTTOM_FIELD_FIRST;
-
-  // Override the sample format when the processor doesn't need to deinterlace or when deinterlacing is forced and flags are missing.
-  if (progressive)
-  {
-    dxvaFrameFormat = DXVAHD_FRAME_FORMAT_PROGRESSIVE;
-  }
-  else if (deinterlace_mode == VS_DEINTERLACEMODE_FORCE 
-        && dxvaFrameFormat  == DXVAHD_FRAME_FORMAT_PROGRESSIVE)
-  {
-    dxvaFrameFormat = DXVAHD_FRAME_FORMAT_INTERLACED_TOP_FIELD_FIRST;
-  }
-
-  bool frameProgressive = dxvaFrameFormat == DXVAHD_FRAME_FORMAT_PROGRESSIVE;
-
-  // Progressive or Interlaced video at normal rate.
-  stream_data.InputFrameOrField = frameIdx;
-  stream_data.OutputIndex = flags & RENDER_FLAG_FIELD1 && !frameProgressive ? 1 : 0;
-
-  DXVAHD_STREAM_STATE_FRAME_FORMAT_DATA frame_format = { dxvaFrameFormat };
-  LOGIFERROR( m_pDXVAVP->SetVideoProcessStreamState( 0, DXVAHD_STREAM_STATE_FRAME_FORMAT
-                                                   , sizeof(frame_format), &frame_format ) );
-
-  DXVAHD_STREAM_STATE_DESTINATION_RECT_DATA dstRect = { true, dstRECT };
-  LOGIFERROR( m_pDXVAVP->SetVideoProcessStreamState( 0, DXVAHD_STREAM_STATE_DESTINATION_RECT
-                                                   , sizeof(dstRect), &dstRect));
-
-  DXVAHD_STREAM_STATE_SOURCE_RECT_DATA srcRect = { true, sourceRECT };
-  LOGIFERROR( m_pDXVAVP->SetVideoProcessStreamState( 0, DXVAHD_STREAM_STATE_SOURCE_RECT
-                                                   , sizeof(srcRect), &srcRect));
-
-  ApplyFilter( DXVAHD_FILTER_BRIGHTNESS, CMediaSettings::Get().GetCurrentVideoSettings().m_Brightness
-                                             , 0, 100, 50);
-  ApplyFilter( DXVAHD_FILTER_CONTRAST, CMediaSettings::Get().GetCurrentVideoSettings().m_Contrast
-                                             , 0, 100, 50);
-
-  unsigned int uiRange = g_Windowing.UseLimitedColor() ? 1 : 0;
-  DXVAHD_BLT_STATE_OUTPUT_COLOR_SPACE_DATA colorData = 
-  {
-    0,        // 0 = playback, 1 = video processing
-    uiRange,  // 0 = 0-255, 1 = 16-235
-    1,        // 0 = BT.601, 1 = BT.709
-    1         // 0 = Conventional YCbCr, 1 = xvYCC
-  };
-
-  LOGIFERROR( m_pDXVAVP->SetVideoProcessBltState( DXVAHD_BLT_STATE_OUTPUT_COLOR_SPACE
-                                                , sizeof(colorData), &colorData ));
-
-  DXVAHD_BLT_STATE_TARGET_RECT_DATA targetRect = { true, dstRECT };
-  LOGIFERROR( m_pDXVAVP->SetVideoProcessBltState( DXVAHD_BLT_STATE_TARGET_RECT
-                                                , sizeof(targetRect), &targetRect ) );
-
-  HRESULT hr = m_pDXVAVP->VideoProcessBltHD(target, frameIdx, 1, &stream_data);
-  if(FAILED(hr))
-  {
-    CLog::Log(LOGERROR, __FUNCTION__" - failed executing VideoProcessBltHD with error %x", hr);
-  }
-
-  delete [] stream_data.ppPastSurfaces;
-  delete [] stream_data.ppFutureSurfaces;
-
-  return !FAILED(hr);
-}
-
-bool CProcessorHD::LoadSymbols()
-{
-  CSingleLock lock(m_dlSection);
-  if(m_dlHandle == NULL)
-    m_dlHandle = LoadLibraryEx("dxva2.dll", NULL, 0);
-  if(m_dlHandle == NULL)
-    return false;
-  m_DXVAHDCreateVideoService = (DXVAHDCreateVideoServicePtr)GetProcAddress(m_dlHandle, "DXVAHD_CreateDevice");
-  if(m_DXVAHDCreateVideoService == NULL)
-    return false;
-  return true;
-}
-
-#endif
diff --git a/xbmc/cores/VideoRenderers/DXVAHD.h b/xbmc/cores/VideoRenderers/DXVAHD.h
deleted file mode 100644
index 4f1c5fe..0000000
--- a/xbmc/cores/VideoRenderers/DXVAHD.h
+++ /dev/null
@@ -1,91 +0,0 @@
-/*
- *      Copyright (C) 2005-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-#include "threads/Event.h"
-#include "DXVA.h"
-#include <dxva2api.h>
-#include "guilib/Geometry.h"
-#include <dxvahd.h>
-
-namespace DXVA {
-
-// ProcAmp filters
-const DXVAHD_FILTER PROCAMP_FILTERS[] =
-{
-    DXVAHD_FILTER_BRIGHTNESS,
-    DXVAHD_FILTER_CONTRAST,
-    DXVAHD_FILTER_HUE,
-    DXVAHD_FILTER_SATURATION
-};
-
-const DWORD NUM_FILTERS = ARRAYSIZE(PROCAMP_FILTERS);
-
-typedef HRESULT (__stdcall *DXVAHDCreateVideoServicePtr)(IDirect3DDevice9Ex *pD3DDevice, const DXVAHD_CONTENT_DESC *pContentDesc, DXVAHD_DEVICE_USAGE Usage, PDXVAHDSW_Plugin pPlugin, IDXVAHD_Device **ppDevice);
-
-class CProcessorHD
-  : public CProcessor
-{
-public:
-  CProcessorHD();
- ~CProcessorHD();
-
-  virtual bool           PreInit();
-  virtual void           UnInit();
-  virtual bool           Open(UINT width, UINT height, unsigned int flags, unsigned int format, unsigned int extended_format);
-  virtual void           Close();
-  virtual bool           Render(CRect src, CRect dst, IDirect3DSurface9* target, IDirect3DSurface9 **source, DWORD flags, UINT frameIdx);
-  virtual unsigned       Size() { if (m_pDXVAHD) return m_size; return 0; }
-  virtual unsigned       PastRefs() { return m_max_back_refs; }
-
-  virtual void OnCreateDevice()  {}
-  virtual void OnDestroyDevice() { CSingleLock lock(m_section); UnInit(); }
-  virtual void OnLostDevice()    { CSingleLock lock(m_section); UnInit(); }
-  virtual void OnResetDevice()   { CSingleLock lock(m_section); Close(); }
-
-protected:
-  virtual bool LoadSymbols();
-  virtual bool UpdateSize(const DXVA2_VideoDesc& dsc);
-  virtual bool ReInit();
-  virtual bool CreateSurfaces();
-  virtual bool OpenProcessor();
-  virtual bool ApplyFilter(DXVAHD_FILTER filter, int value, int min, int max, int def);
-
-  IDXVAHD_Device          *m_pDXVAHD;      // DXVA-HD device.
-  IDXVAHD_VideoProcessor  *m_pDXVAVP;      // DXVA-HD video processor.
-  DXVAHD_VPDEVCAPS         m_VPDevCaps;
-  DXVAHD_VPCAPS            m_VPCaps;
-  unsigned int             m_width;
-  unsigned int             m_height;
-  D3DFORMAT                m_format;
-  unsigned int             m_flags;
-  unsigned int             m_renderFormat;
-
-  struct ProcAmpInfo
-  {
-    bool                      bSupported;
-    DXVAHD_FILTER_RANGE_DATA  Range;
-  };
-  ProcAmpInfo              m_Filters[NUM_FILTERS];
-
-  static DXVAHDCreateVideoServicePtr m_DXVAHDCreateVideoService;
-};
-
-};
diff --git a/xbmc/cores/VideoRenderers/HwDecRender/DXVAHD.cpp b/xbmc/cores/VideoRenderers/HwDecRender/DXVAHD.cpp
new file mode 100644
index 0000000..5c6758e
--- /dev/null
+++ b/xbmc/cores/VideoRenderers/HwDecRender/DXVAHD.cpp
@@ -0,0 +1,522 @@
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#ifdef HAS_DX
+
+// setting that here because otherwise SampleFormat is defined to AVSampleFormat
+// which we don't use here
+#define FF_API_OLD_SAMPLE_FMT 0
+
+#include <windows.h>
+#include <d3d9.h>
+#include <Initguid.h>
+#include <dxva2api.h>
+
+#include "DXVAHD.h"
+#include "windowing/WindowingFactory.h"
+#include "settings/Settings.h"
+#include "settings/MediaSettings.h"
+#include "utils/AutoPtrHandle.h"
+#include "utils/StringUtils.h"
+#include "settings/AdvancedSettings.h"
+#include "cores/VideoRenderers/RenderManager.h"
+#include "RenderFlags.h"
+#include "win32/WIN32Util.h"
+#include "utils/Log.h"
+
+using namespace DXVA;
+using namespace AUTOPTR;
+using namespace std;
+
+#define CHECK(a) \
+do { \
+  HRESULT res = a; \
+  if(FAILED(res)) \
+  { \
+    CLog::Log(LOGERROR, __FUNCTION__" - failed executing "#a" at line %d with error %x", __LINE__, res); \
+    return false; \
+  } \
+} while(0);
+
+#define LOGIFERROR(a) \
+do { \
+  HRESULT res = a; \
+  if(FAILED(res)) \
+  { \
+    CLog::Log(LOGERROR, __FUNCTION__" - failed executing "#a" at line %d with error %x", __LINE__, res); \
+  } \
+} while(0);
+
+static std::string GUIDToString(const GUID& guid)
+{
+  std::string buffer = StringUtils::Format("%08X-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x"
+                                          , guid.Data1, guid.Data2, guid.Data3
+                                          , guid.Data4[0], guid.Data4[1]
+                                          , guid.Data4[2], guid.Data4[3], guid.Data4[4]
+                                          , guid.Data4[5], guid.Data4[6], guid.Data4[7]);
+  return buffer;
+}
+
+DXVAHDCreateVideoServicePtr CProcessorHD::m_DXVAHDCreateVideoService = NULL;
+
+CProcessorHD::CProcessorHD()
+{
+  m_pDXVAHD = NULL;
+  m_pDXVAVP = NULL;
+  g_Windowing.Register(this);
+
+  m_context  = NULL;
+}
+
+CProcessorHD::~CProcessorHD()
+{
+  g_Windowing.Unregister(this);
+  UnInit();
+}
+
+void CProcessorHD::UnInit()
+{
+  CSingleLock lock(m_section);
+  Close();
+  SAFE_RELEASE(m_pDXVAHD);
+}
+
+void CProcessorHD::Close()
+{
+  CSingleLock lock(m_section);
+  SAFE_RELEASE(m_pDXVAVP);
+  SAFE_RELEASE(m_context);
+}
+
+bool CProcessorHD::UpdateSize(const DXVA2_VideoDesc& dsc)
+{
+  return true;
+}
+
+bool CProcessorHD::PreInit()
+{
+  if (!LoadSymbols())
+  {
+    CLog::Log(LOGWARNING, __FUNCTION__" - DXVAHD not loaded.");
+    return false;
+  }
+
+  UnInit();
+
+  CSingleLock lock(m_section);
+
+  DXVAHD_RATIONAL fps = { 60, 1 }; 
+  DXVAHD_CONTENT_DESC desc;
+  desc.InputFrameFormat = DXVAHD_FRAME_FORMAT_PROGRESSIVE;
+  desc.InputFrameRate = fps;
+  desc.InputWidth = 640;
+  desc.InputHeight = 480;
+  desc.OutputFrameRate = fps;
+  desc.OutputWidth = 640;
+  desc.OutputHeight = 480;
+
+  HRESULT cvres = m_DXVAHDCreateVideoService( (IDirect3DDevice9Ex*)g_Windowing.Get3DDevice()
+                                              , &desc
+                                              , DXVAHD_DEVICE_USAGE_OPTIMAL_QUALITY
+                                              , NULL
+                                              , &m_pDXVAHD );
+
+  if(FAILED(cvres))
+  {
+    if(cvres == E_NOINTERFACE)
+      CLog::Log(LOGNOTICE, __FUNCTION__" - The Direct3d device doesn't support DXVA-HD.");
+    else
+      CLog::Log(LOGERROR, __FUNCTION__" - failed to create DXVAHD device %x", cvres);
+
+    return false;
+  }
+
+  CHECK(m_pDXVAHD->GetVideoProcessorDeviceCaps( &m_VPDevCaps ));
+
+  if (m_VPDevCaps.VideoProcessorCount == 0)
+  {
+    CLog::Log(LOGWARNING, __FUNCTION__" - unable to find any video processor. GPU drivers doesn't support DXVA-HD.");
+    return false;
+  }
+
+  // Create the array of video processor caps. 
+  DXVAHD_VPCAPS* pVPCaps = new (std::nothrow) DXVAHD_VPCAPS[ m_VPDevCaps.VideoProcessorCount ];
+  if (pVPCaps == NULL)
+  {
+    CLog::Log(LOGERROR, __FUNCTION__" - unable to create video processor caps array. Out of memory.");
+    return false;
+  }
+
+  HRESULT hr = m_pDXVAHD->GetVideoProcessorCaps( m_VPDevCaps.VideoProcessorCount, pVPCaps );
+  if(FAILED(hr))
+  {
+    CLog::Log(LOGERROR, __FUNCTION__" - failed get processor caps with error %x.", hr);
+
+    delete [] pVPCaps;
+    return false;
+  }
+
+  m_max_back_refs = 0;
+  m_max_fwd_refs = 0;
+
+  for (unsigned int i = 0; i < m_VPDevCaps.VideoProcessorCount; i++)
+  {
+    if (pVPCaps[i].FutureFrames > m_max_fwd_refs)
+    {
+      m_max_fwd_refs = pVPCaps[i].FutureFrames;
+    }
+
+    if (pVPCaps[i].PastFrames > m_max_back_refs)
+    {
+      m_max_back_refs = pVPCaps[i].PastFrames;
+    }
+  }
+
+  m_size = m_max_back_refs + 1 + m_max_fwd_refs + 2;  // refs + 1 display + 2 safety frames
+
+  // Get the image filtering capabilities.
+  for (long i = 0; i < NUM_FILTERS; i++)
+  {
+    if (m_VPDevCaps.FilterCaps & (1 << i))
+    {
+      m_pDXVAHD->GetVideoProcessorFilterRange(PROCAMP_FILTERS[i], &m_Filters[i].Range);
+      m_Filters[i].bSupported = true;
+    }
+    else
+    {
+      m_Filters[i].bSupported = false;
+    }
+  }
+
+  m_VPCaps = pVPCaps[0];
+  m_device = m_VPCaps.VPGuid;
+
+  delete [] pVPCaps;
+
+  return true;
+}
+
+bool CProcessorHD::Open(UINT width, UINT height, unsigned int flags, unsigned int format, unsigned int extended_format)
+{
+  Close();
+
+  CSingleLock lock(m_section);
+
+  if (!m_pDXVAHD)
+  {
+    return false;
+  }
+
+  m_width = width;
+  m_height = height;
+  m_flags = flags;
+  m_renderFormat = format;
+
+  if (g_advancedSettings.m_DXVANoDeintProcForProgressive)
+  {
+    CLog::Log(LOGNOTICE, __FUNCTION__" - Auto deinterlacing mode workaround activated. Deinterlacing processor will be used only for interlaced frames.");
+  }
+
+  if (format == RENDER_FMT_DXVA)
+  {
+    m_format = (D3DFORMAT)extended_format;
+  }
+  else
+  {
+    // Only NV12 software colorspace conversion is implemented for now
+    m_format = (D3DFORMAT)MAKEFOURCC('N','V','1','2');
+    if (!CreateSurfaces())
+      return false;
+  }
+
+  if (!OpenProcessor())
+  {
+    return false;
+  }
+
+  return true;
+}
+
+bool CProcessorHD::ReInit()
+{
+  return PreInit() && (m_renderFormat == RENDER_FMT_DXVA || CreateSurfaces());
+}
+
+bool CProcessorHD::OpenProcessor()
+{
+  // restore the device if it was lost
+  if (!m_pDXVAHD && !ReInit())
+  {
+    return false;
+  }
+
+  SAFE_RELEASE(m_pDXVAVP);
+
+  CLog::Log(LOGDEBUG, __FUNCTION__" - processor selected %s.", GUIDToString(m_device).c_str());
+
+  CHECK(m_pDXVAHD->CreateVideoProcessor(&m_device, &m_pDXVAVP));
+
+  DXVAHD_STREAM_STATE_D3DFORMAT_DATA d3dformat = { m_format };
+  CHECK(m_pDXVAVP->SetVideoProcessStreamState( 0, DXVAHD_STREAM_STATE_D3DFORMAT
+                                             , sizeof(d3dformat), &d3dformat ));
+
+  DXVAHD_STREAM_STATE_INPUT_COLOR_SPACE_DATA data =
+  {
+    0,                                          // Type: 0=Video, 1=Graphics
+    0,                                          // RGB_Range: 0=Full, 1=Limited
+    m_flags & CONF_FLAGS_YUVCOEF_BT709 ? 1 : 0, // YCbCr_Matrix: 0=BT.601, 1=BT.709
+    m_flags & CONF_FLAGS_YUV_FULLRANGE ? 1 : 0  // YCbCr_xvYCC: 0=Conventional YCbCr, 1=xvYCC
+  };
+  CHECK(m_pDXVAVP->SetVideoProcessStreamState( 0, DXVAHD_STREAM_STATE_INPUT_COLOR_SPACE
+                                             , sizeof(data), &data ));
+
+  DXVAHD_COLOR_YCbCrA bgColor = { 0.0625f, 0.5f, 0.5f, 1.0f }; // black color
+  DXVAHD_COLOR backgroundColor;
+  backgroundColor.YCbCr = bgColor; 
+  DXVAHD_BLT_STATE_BACKGROUND_COLOR_DATA backgroundData = { true, backgroundColor }; // {YCbCr, DXVAHD_COLOR}
+  CHECK(m_pDXVAVP->SetVideoProcessBltState( DXVAHD_BLT_STATE_BACKGROUND_COLOR
+                                          , sizeof (backgroundData), &backgroundData ));
+
+  DXVAHD_STREAM_STATE_ALPHA_DATA alpha = { true, 1.0f };
+  CHECK(m_pDXVAVP->SetVideoProcessStreamState( 0, DXVAHD_STREAM_STATE_ALPHA
+                                             , sizeof(alpha), &alpha ));
+
+  return true;
+}
+
+bool CProcessorHD::CreateSurfaces()
+{
+  LPDIRECT3DDEVICE9 pD3DDevice = g_Windowing.Get3DDevice();
+  LPDIRECT3DSURFACE9 surfaces[32];
+  for (unsigned idx = 0; idx < m_size; idx++)
+  {
+    CHECK(pD3DDevice->CreateOffscreenPlainSurface(
+      (m_width + 15) & ~15,
+      (m_height + 15) & ~15,
+      m_format,
+      m_VPDevCaps.InputPool,
+      &surfaces[idx],
+      NULL));
+  }
+
+  m_context = new CSurfaceContext();
+  for (int i = 0; i < m_size; i++)
+  {
+    m_context->AddSurface(surfaces[i]);
+  }
+
+  return true;
+}
+
+bool CProcessorHD::ApplyFilter(DXVAHD_FILTER filter, int value, int min, int max, int def)
+{
+  if (filter >= NUM_FILTERS)
+    return false;
+
+  // Unsupported filter. Ignore.
+  if (!m_Filters[filter].bSupported)
+  {
+    return false;
+  }
+
+  DXVAHD_FILTER_RANGE_DATA range = m_Filters[filter].Range;
+  int val;
+
+  if(value > def)
+  {
+    val = range.Default + (range.Maximum - range.Default) * (value - def) / (max - def);
+  }
+  else if(value < def)
+  {
+    val = range.Default + (range.Minimum - range.Default) * (value - def) / (min - def);
+  }
+  else
+  {
+    val = range.Default;
+  }
+
+  DXVAHD_STREAM_STATE_FILTER_DATA data = { true, val };
+  DXVAHD_STREAM_STATE state = static_cast<DXVAHD_STREAM_STATE>(DXVAHD_STREAM_STATE_FILTER_BRIGHTNESS + filter);
+
+  return !FAILED( m_pDXVAVP->SetVideoProcessStreamState( 0, state, sizeof(data), &data ) );
+}
+
+bool CProcessorHD::Render(CRect src, CRect dst, IDirect3DSurface9* target, IDirect3DSurface9** source, DWORD flags, UINT frameIdx)
+{
+  CSingleLock lock(m_section);
+
+  // restore processor if it was lost
+  if(!m_pDXVAVP && !OpenProcessor())
+  {
+    return false;
+  }
+  
+  if (!source[2])
+    return false;
+
+  EDEINTERLACEMODE deinterlace_mode = CMediaSettings::Get().GetCurrentVideoSettings().m_DeinterlaceMode;
+  if (g_advancedSettings.m_DXVANoDeintProcForProgressive)
+    deinterlace_mode = (flags & RENDER_FLAG_FIELD0 || flags & RENDER_FLAG_FIELD1) ? VS_DEINTERLACEMODE_FORCE : VS_DEINTERLACEMODE_OFF;
+  EINTERLACEMETHOD interlace_method = g_renderManager.AutoInterlaceMethod(CMediaSettings::Get().GetCurrentVideoSettings().m_InterlaceMethod);
+
+  bool progressive = deinterlace_mode == VS_DEINTERLACEMODE_OFF
+                  || (   interlace_method != VS_INTERLACEMETHOD_DXVA_BOB
+                      && interlace_method != VS_INTERLACEMETHOD_DXVA_BEST);
+
+  D3DSURFACE_DESC desc;
+  CHECK(target->GetDesc(&desc));
+  CRect rectTarget(0, 0, desc.Width, desc.Height);
+  CWIN32Util::CropSource(src, dst, rectTarget);
+  RECT sourceRECT = { src.x1, src.y1, src.x2, src.y2 };
+  RECT dstRECT    = { dst.x1, dst.y1, dst.x2, dst.y2 };
+
+  DXVAHD_FRAME_FORMAT dxvaFrameFormat = DXVAHD_FRAME_FORMAT_PROGRESSIVE;
+
+  unsigned int providedPast = 0;
+  for (int i = 3; i < 8; i++)
+  {
+    if (source[i])
+      providedPast++;
+  }
+  unsigned int providedFuture = 0;
+  for (int i = 1; i >= 0; i--)
+  {
+    if (source[i])
+      providedFuture++;
+  }
+  int futureFrames = std::min(providedFuture, m_VPCaps.FutureFrames);
+  int pastFrames = std::min(providedPast, m_VPCaps.PastFrames);
+
+  DXVAHD_STREAM_DATA stream_data = { 0 };
+  stream_data.Enable = TRUE;
+  stream_data.PastFrames = pastFrames;
+  stream_data.FutureFrames = futureFrames;
+  stream_data.ppPastSurfaces = new IDirect3DSurface9*[pastFrames];
+  stream_data.ppFutureSurfaces = new IDirect3DSurface9*[futureFrames];
+
+  int start = 2 - futureFrames;
+  int end = 2 + pastFrames;
+
+  for (int i = start; i <= end; i++)
+  {
+    if (!source[i])
+      continue;
+
+    if (i > 2)
+    {
+      // frames order should be { ?, T-3, T-2, T-1 }
+      stream_data.ppPastSurfaces[2+pastFrames-i] = source[i];
+    }
+    else if (i == 2)
+    {
+      stream_data.pInputSurface = source[2];
+    }
+    else if (i < 2)
+    {
+      // frames order should be { T+1, T+2, T+3, .. }
+      stream_data.ppFutureSurfaces[1-i] = source[i];
+    }
+  }
+
+  if (flags & RENDER_FLAG_FIELD0 && flags & RENDER_FLAG_TOP)
+    dxvaFrameFormat = DXVAHD_FRAME_FORMAT_INTERLACED_TOP_FIELD_FIRST;
+  else if (flags & RENDER_FLAG_FIELD1 && flags & RENDER_FLAG_BOT)
+    dxvaFrameFormat = DXVAHD_FRAME_FORMAT_INTERLACED_TOP_FIELD_FIRST;
+  if (flags & RENDER_FLAG_FIELD0 && flags & RENDER_FLAG_BOT)
+    dxvaFrameFormat = DXVAHD_FRAME_FORMAT_INTERLACED_BOTTOM_FIELD_FIRST;
+  if (flags & RENDER_FLAG_FIELD1 && flags & RENDER_FLAG_TOP)
+    dxvaFrameFormat = DXVAHD_FRAME_FORMAT_INTERLACED_BOTTOM_FIELD_FIRST;
+
+  // Override the sample format when the processor doesn't need to deinterlace or when deinterlacing is forced and flags are missing.
+  if (progressive)
+  {
+    dxvaFrameFormat = DXVAHD_FRAME_FORMAT_PROGRESSIVE;
+  }
+  else if (deinterlace_mode == VS_DEINTERLACEMODE_FORCE 
+        && dxvaFrameFormat  == DXVAHD_FRAME_FORMAT_PROGRESSIVE)
+  {
+    dxvaFrameFormat = DXVAHD_FRAME_FORMAT_INTERLACED_TOP_FIELD_FIRST;
+  }
+
+  bool frameProgressive = dxvaFrameFormat == DXVAHD_FRAME_FORMAT_PROGRESSIVE;
+
+  // Progressive or Interlaced video at normal rate.
+  stream_data.InputFrameOrField = frameIdx;
+  stream_data.OutputIndex = flags & RENDER_FLAG_FIELD1 && !frameProgressive ? 1 : 0;
+
+  DXVAHD_STREAM_STATE_FRAME_FORMAT_DATA frame_format = { dxvaFrameFormat };
+  LOGIFERROR( m_pDXVAVP->SetVideoProcessStreamState( 0, DXVAHD_STREAM_STATE_FRAME_FORMAT
+                                                   , sizeof(frame_format), &frame_format ) );
+
+  DXVAHD_STREAM_STATE_DESTINATION_RECT_DATA dstRect = { true, dstRECT };
+  LOGIFERROR( m_pDXVAVP->SetVideoProcessStreamState( 0, DXVAHD_STREAM_STATE_DESTINATION_RECT
+                                                   , sizeof(dstRect), &dstRect));
+
+  DXVAHD_STREAM_STATE_SOURCE_RECT_DATA srcRect = { true, sourceRECT };
+  LOGIFERROR( m_pDXVAVP->SetVideoProcessStreamState( 0, DXVAHD_STREAM_STATE_SOURCE_RECT
+                                                   , sizeof(srcRect), &srcRect));
+
+  ApplyFilter( DXVAHD_FILTER_BRIGHTNESS, CMediaSettings::Get().GetCurrentVideoSettings().m_Brightness
+                                             , 0, 100, 50);
+  ApplyFilter( DXVAHD_FILTER_CONTRAST, CMediaSettings::Get().GetCurrentVideoSettings().m_Contrast
+                                             , 0, 100, 50);
+
+  unsigned int uiRange = g_Windowing.UseLimitedColor() ? 1 : 0;
+  DXVAHD_BLT_STATE_OUTPUT_COLOR_SPACE_DATA colorData = 
+  {
+    0,        // 0 = playback, 1 = video processing
+    uiRange,  // 0 = 0-255, 1 = 16-235
+    1,        // 0 = BT.601, 1 = BT.709
+    1         // 0 = Conventional YCbCr, 1 = xvYCC
+  };
+
+  LOGIFERROR( m_pDXVAVP->SetVideoProcessBltState( DXVAHD_BLT_STATE_OUTPUT_COLOR_SPACE
+                                                , sizeof(colorData), &colorData ));
+
+  DXVAHD_BLT_STATE_TARGET_RECT_DATA targetRect = { true, dstRECT };
+  LOGIFERROR( m_pDXVAVP->SetVideoProcessBltState( DXVAHD_BLT_STATE_TARGET_RECT
+                                                , sizeof(targetRect), &targetRect ) );
+
+  HRESULT hr = m_pDXVAVP->VideoProcessBltHD(target, frameIdx, 1, &stream_data);
+  if(FAILED(hr))
+  {
+    CLog::Log(LOGERROR, __FUNCTION__" - failed executing VideoProcessBltHD with error %x", hr);
+  }
+
+  delete [] stream_data.ppPastSurfaces;
+  delete [] stream_data.ppFutureSurfaces;
+
+  return !FAILED(hr);
+}
+
+bool CProcessorHD::LoadSymbols()
+{
+  CSingleLock lock(m_dlSection);
+  if(m_dlHandle == NULL)
+    m_dlHandle = LoadLibraryEx("dxva2.dll", NULL, 0);
+  if(m_dlHandle == NULL)
+    return false;
+  m_DXVAHDCreateVideoService = (DXVAHDCreateVideoServicePtr)GetProcAddress(m_dlHandle, "DXVAHD_CreateDevice");
+  if(m_DXVAHDCreateVideoService == NULL)
+    return false;
+  return true;
+}
+
+#endif
diff --git a/xbmc/cores/VideoRenderers/HwDecRender/DXVAHD.h b/xbmc/cores/VideoRenderers/HwDecRender/DXVAHD.h
new file mode 100644
index 0000000..4f1c5fe
--- /dev/null
+++ b/xbmc/cores/VideoRenderers/HwDecRender/DXVAHD.h
@@ -0,0 +1,91 @@
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#pragma once
+
+#include "threads/Event.h"
+#include "DXVA.h"
+#include <dxva2api.h>
+#include "guilib/Geometry.h"
+#include <dxvahd.h>
+
+namespace DXVA {
+
+// ProcAmp filters
+const DXVAHD_FILTER PROCAMP_FILTERS[] =
+{
+    DXVAHD_FILTER_BRIGHTNESS,
+    DXVAHD_FILTER_CONTRAST,
+    DXVAHD_FILTER_HUE,
+    DXVAHD_FILTER_SATURATION
+};
+
+const DWORD NUM_FILTERS = ARRAYSIZE(PROCAMP_FILTERS);
+
+typedef HRESULT (__stdcall *DXVAHDCreateVideoServicePtr)(IDirect3DDevice9Ex *pD3DDevice, const DXVAHD_CONTENT_DESC *pContentDesc, DXVAHD_DEVICE_USAGE Usage, PDXVAHDSW_Plugin pPlugin, IDXVAHD_Device **ppDevice);
+
+class CProcessorHD
+  : public CProcessor
+{
+public:
+  CProcessorHD();
+ ~CProcessorHD();
+
+  virtual bool           PreInit();
+  virtual void           UnInit();
+  virtual bool           Open(UINT width, UINT height, unsigned int flags, unsigned int format, unsigned int extended_format);
+  virtual void           Close();
+  virtual bool           Render(CRect src, CRect dst, IDirect3DSurface9* target, IDirect3DSurface9 **source, DWORD flags, UINT frameIdx);
+  virtual unsigned       Size() { if (m_pDXVAHD) return m_size; return 0; }
+  virtual unsigned       PastRefs() { return m_max_back_refs; }
+
+  virtual void OnCreateDevice()  {}
+  virtual void OnDestroyDevice() { CSingleLock lock(m_section); UnInit(); }
+  virtual void OnLostDevice()    { CSingleLock lock(m_section); UnInit(); }
+  virtual void OnResetDevice()   { CSingleLock lock(m_section); Close(); }
+
+protected:
+  virtual bool LoadSymbols();
+  virtual bool UpdateSize(const DXVA2_VideoDesc& dsc);
+  virtual bool ReInit();
+  virtual bool CreateSurfaces();
+  virtual bool OpenProcessor();
+  virtual bool ApplyFilter(DXVAHD_FILTER filter, int value, int min, int max, int def);
+
+  IDXVAHD_Device          *m_pDXVAHD;      // DXVA-HD device.
+  IDXVAHD_VideoProcessor  *m_pDXVAVP;      // DXVA-HD video processor.
+  DXVAHD_VPDEVCAPS         m_VPDevCaps;
+  DXVAHD_VPCAPS            m_VPCaps;
+  unsigned int             m_width;
+  unsigned int             m_height;
+  D3DFORMAT                m_format;
+  unsigned int             m_flags;
+  unsigned int             m_renderFormat;
+
+  struct ProcAmpInfo
+  {
+    bool                      bSupported;
+    DXVAHD_FILTER_RANGE_DATA  Range;
+  };
+  ProcAmpInfo              m_Filters[NUM_FILTERS];
+
+  static DXVAHDCreateVideoServicePtr m_DXVAHDCreateVideoService;
+};
+
+};
diff --git a/xbmc/cores/VideoRenderers/HwDecRender/MMALRenderer.cpp b/xbmc/cores/VideoRenderers/HwDecRender/MMALRenderer.cpp
new file mode 100644
index 0000000..9f1f803
--- /dev/null
+++ b/xbmc/cores/VideoRenderers/HwDecRender/MMALRenderer.cpp
@@ -0,0 +1,722 @@
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "Util.h"
+#include "MMALRenderer.h"
+#include "cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h"
+#include "filesystem/File.h"
+#include "settings/AdvancedSettings.h"
+#include "settings/DisplaySettings.h"
+#include "settings/MediaSettings.h"
+#include "settings/Settings.h"
+#include "threads/SingleLock.h"
+#include "utils/log.h"
+#include "utils/MathUtils.h"
+#include "windowing/WindowingFactory.h"
+#include "cores/dvdplayer/DVDCodecs/Video/MMALCodec.h"
+#include "xbmc/Application.h"
+
+#define CLASSNAME "CMMALRenderer"
+
+#ifdef _DEBUG
+#define MMAL_DEBUG_VERBOSE
+#endif
+
+CRenderInfo CMMALRenderer::GetRenderInfo()
+{
+  CSingleLock lock(m_sharedSection);
+  CRenderInfo info;
+
+  // we'll assume that video is accelerated (RENDER_FMT_MMAL) for now
+  // we will reconfigure renderer later if necessary
+  if (!m_bMMALConfigured)
+    m_bMMALConfigured = init_vout(RENDER_FMT_MMAL);
+
+  #if defined(MMAL_DEBUG_VERBOSE)
+  CLog::Log(LOGDEBUG, "%s::%s cookie:%p", CLASSNAME, __func__, (void *)m_vout_input_pool);
+  #endif
+
+  info.max_buffer_size = NUM_BUFFERS;
+  info.optimal_buffer_size = NUM_BUFFERS;
+  info.opaque_pointer = (void *)m_vout_input_pool;
+  info.formats = m_formats;
+  return info;
+}
+
+static void vout_control_port_cb(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)
+{
+  mmal_buffer_header_release(buffer);
+}
+
+void CMMALRenderer::vout_input_port_cb(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)
+{
+  #if defined(MMAL_DEBUG_VERBOSE)
+  CMMALVideoBuffer *omvb = (CMMALVideoBuffer *)buffer->user_data;
+  CLog::Log(LOGDEBUG, "%s::%s port:%p buffer %p (%p), len %d cmd:%x f:%x", CLASSNAME, __func__, port, buffer, omvb, buffer->length, buffer->cmd, buffer->flags);
+  #endif
+
+  assert(!(buffer->flags & MMAL_BUFFER_HEADER_FLAG_TRANSMISSION_FAILED));
+  buffer->flags &= ~MMAL_BUFFER_HEADER_FLAG_USER2;
+  if (m_format == RENDER_FMT_MMAL)
+  {
+    CMMALVideoBuffer *omvb = (CMMALVideoBuffer *)buffer->user_data;
+    omvb->Release();
+  }
+  else if (m_format == RENDER_FMT_YUV420P)
+  {
+    mmal_buffer_header_release(buffer);
+  }
+  else assert(0);
+}
+
+static void vout_input_port_cb_static(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)
+{
+  CMMALRenderer *mmal = reinterpret_cast<CMMALRenderer*>(port->userdata);
+  mmal->vout_input_port_cb(port, buffer);
+}
+
+bool CMMALRenderer::init_vout(ERenderFormat format)
+{
+  CSingleLock lock(m_sharedSection);
+  bool formatChanged = m_format != format;
+  MMAL_STATUS_T status;
+
+  CLog::Log(LOGDEBUG, "%s::%s configured:%d format:%d->%d", CLASSNAME, __func__, m_bConfigured, m_format, format);
+
+  if (m_bMMALConfigured && formatChanged)
+    UnInitMMAL();
+
+  if (m_bMMALConfigured)
+    return true;
+
+  m_format = format;
+  if (m_format != RENDER_FMT_MMAL && m_format != RENDER_FMT_YUV420P)
+    return true;
+
+  /* Create video renderer */
+  status = mmal_component_create(MMAL_COMPONENT_DEFAULT_VIDEO_RENDERER, &m_vout);
+  if(status != MMAL_SUCCESS)
+  {
+    CLog::Log(LOGERROR, "%s::%s Failed to create vout component (status=%x %s)", CLASSNAME, __func__, status, mmal_status_to_string(status));
+    return false;
+  }
+
+  m_vout->control->userdata = (struct MMAL_PORT_USERDATA_T *)this;
+  status = mmal_port_enable(m_vout->control, vout_control_port_cb);
+  if(status != MMAL_SUCCESS)
+  {
+    CLog::Log(LOGERROR, "%s::%s Failed to enable vout control port (status=%x %s)", CLASSNAME, __func__, status, mmal_status_to_string(status));
+    return false;
+  }
+  m_vout_input = m_vout->input[0];
+  m_vout_input->userdata = (struct MMAL_PORT_USERDATA_T *)this;
+  MMAL_ES_FORMAT_T *es_format = m_vout_input->format;
+
+  es_format->type = MMAL_ES_TYPE_VIDEO;
+  es_format->es->video.crop.width = m_sourceWidth;
+  es_format->es->video.crop.height = m_sourceHeight;
+
+  if (m_format == RENDER_FMT_MMAL)
+  {
+    es_format->encoding = MMAL_ENCODING_OPAQUE;
+    es_format->es->video.width = m_sourceWidth;
+    es_format->es->video.height = m_sourceHeight;
+  }
+  else if (m_format == RENDER_FMT_YUV420P)
+  {
+    const int pitch = ALIGN_UP(m_sourceWidth, 32);
+    const int aligned_height = ALIGN_UP(m_sourceHeight, 16);
+
+    es_format->encoding = MMAL_ENCODING_I420;
+    es_format->es->video.width = pitch;
+    es_format->es->video.height = aligned_height;
+
+    if (CONF_FLAGS_YUVCOEF_MASK(m_iFlags) == CONF_FLAGS_YUVCOEF_BT709)
+      es_format->es->video.color_space = MMAL_COLOR_SPACE_ITUR_BT709;
+    else if (CONF_FLAGS_YUVCOEF_MASK(m_iFlags) == CONF_FLAGS_YUVCOEF_BT601)
+      es_format->es->video.color_space = MMAL_COLOR_SPACE_ITUR_BT601;
+    else if (CONF_FLAGS_YUVCOEF_MASK(m_iFlags) == CONF_FLAGS_YUVCOEF_240M)
+      es_format->es->video.color_space = MMAL_COLOR_SPACE_SMPTE240M;
+  }
+
+  if (m_format == RENDER_FMT_MMAL)
+  {
+    status = mmal_port_parameter_set_boolean(m_vout_input, MMAL_PARAMETER_ZERO_COPY,  MMAL_TRUE);
+    if (status != MMAL_SUCCESS)
+       CLog::Log(LOGERROR, "%s::%s Failed to enable zero copy mode on %s (status=%x %s)", CLASSNAME, __func__, m_vout_input->name, status, mmal_status_to_string(status));
+  }
+  status = mmal_port_format_commit(m_vout_input);
+  if (status != MMAL_SUCCESS)
+  {
+    CLog::Log(LOGERROR, "%s::%s Failed to commit vout input format (status=%x %s)", CLASSNAME, __func__, status, mmal_status_to_string(status));
+    return false;
+  }
+
+  m_vout_input->buffer_num = std::max(m_vout_input->buffer_num_recommended, (uint32_t)m_NumYV12Buffers);
+  m_vout_input->buffer_size = m_vout_input->buffer_size_recommended;
+
+  status = mmal_port_enable(m_vout_input, vout_input_port_cb_static);
+  if(status != MMAL_SUCCESS)
+  {
+    CLog::Log(LOGERROR, "%s::%s Failed to vout enable input port (status=%x %s)", CLASSNAME, __func__, status, mmal_status_to_string(status));
+    return false;
+  }
+
+  status = mmal_component_enable(m_vout);
+  if(status != MMAL_SUCCESS)
+  {
+    CLog::Log(LOGERROR, "%s::%s Failed to enable vout component (status=%x %s)", CLASSNAME, __func__, status, mmal_status_to_string(status));
+    return false;
+  }
+
+  m_vout_input_pool = mmal_port_pool_create(m_vout_input , m_vout_input->buffer_num, m_vout_input->buffer_size);
+  if (!m_vout_input_pool)
+  {
+    CLog::Log(LOGERROR, "%s::%s Failed to create pool for decoder input port (status=%x %s)", CLASSNAME, __func__, status, mmal_status_to_string(status));
+    return false;
+  }
+  return true;
+}
+
+CMMALRenderer::CMMALRenderer()
+{
+  CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
+  m_vout = NULL;
+  m_vout_input = NULL;
+  m_vout_input_pool = NULL;
+  memset(m_buffers, 0, sizeof m_buffers);
+  m_iFlags = 0;
+  m_format = RENDER_FMT_NONE;
+  m_bConfigured = false;
+  m_bMMALConfigured = false;
+  m_iYV12RenderBuffer = 0;
+}
+
+CMMALRenderer::~CMMALRenderer()
+{
+  CSingleLock lock(m_sharedSection);
+  CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
+  UnInit();
+}
+
+void CMMALRenderer::AddProcessor(CMMALVideoBuffer *buffer, int index)
+{
+#if defined(MMAL_DEBUG_VERBOSE)
+  CLog::Log(LOGDEBUG, "%s::%s - %p (%p) %i", CLASSNAME, __func__, buffer, buffer->mmal_buffer, index);
+#endif
+
+  YUVBUFFER &buf = m_buffers[index];
+  assert(!buf.MMALBuffer);
+  memset(&buf, 0, sizeof buf);
+  buf.MMALBuffer = buffer->Acquire();
+}
+
+bool CMMALRenderer::Configure(unsigned int width, unsigned int height, unsigned int d_width, unsigned int d_height, float fps, unsigned flags, ERenderFormat format, unsigned extended_format, unsigned int orientation)
+{
+  CSingleLock lock(m_sharedSection);
+  ReleaseBuffers();
+
+  m_sourceWidth  = width;
+  m_sourceHeight = height;
+  m_renderOrientation = orientation;
+
+  m_fps = fps;
+  m_iFlags = flags;
+
+  CLog::Log(LOGDEBUG, "%s::%s - %dx%d->%dx%d@%.2f flags:%x format:%d ext:%x orient:%d", CLASSNAME, __func__, width, height, d_width, d_height, fps, flags, format, extended_format, orientation);
+
+  m_RenderUpdateCallBackFn = NULL;
+  m_RenderUpdateCallBackCtx = NULL;
+
+  // calculate the input frame aspect ratio
+  CalculateFrameAspectRatio(d_width, d_height);
+  ChooseBestResolution(fps);
+  m_destWidth = g_graphicsContext.GetResInfo(m_resolution).iWidth;
+  m_destHeight = g_graphicsContext.GetResInfo(m_resolution).iHeight;
+  SetViewMode(CMediaSettings::Get().GetCurrentVideoSettings().m_ViewMode);
+  ManageDisplay();
+
+  m_bMMALConfigured = init_vout(format);
+  m_bConfigured = m_bMMALConfigured;
+  assert(m_bConfigured);
+  return m_bConfigured;
+}
+
+int CMMALRenderer::GetImage(YV12Image *image, int source, bool readonly)
+{
+#if defined(MMAL_DEBUG_VERBOSE)
+  CLog::Log(LOGDEBUG, "%s::%s - %p %d %d", CLASSNAME, __func__, image, source, readonly);
+#endif
+  if (!image) return -1;
+
+  if( source < 0)
+    return -1;
+
+  if (m_format == RENDER_FMT_MMAL)
+  {
+  }
+  else if (m_format == RENDER_FMT_YUV420P)
+  {
+    const int pitch = ALIGN_UP(m_sourceWidth, 32);
+    const int aligned_height = ALIGN_UP(m_sourceHeight, 16);
+
+    MMAL_BUFFER_HEADER_T *buffer = mmal_queue_timedwait(m_vout_input_pool->queue, 500);
+    if (!buffer)
+    {
+      CLog::Log(LOGERROR, "%s::%s - mmal_queue_get failed", CLASSNAME, __func__);
+      return -1;
+    }
+
+    mmal_buffer_header_reset(buffer);
+
+    buffer->length = 3 * pitch * aligned_height >> 1;
+    assert(buffer->length <= buffer->alloc_size);
+
+    image->width    = m_sourceWidth;
+    image->height   = m_sourceHeight;
+    image->flags    = 0;
+    image->cshift_x = 1;
+    image->cshift_y = 1;
+    image->bpp      = 1;
+
+    image->stride[0] = pitch;
+    image->stride[1] = image->stride[2] = pitch>>image->cshift_x;
+
+    image->planesize[0] = pitch * aligned_height;
+    image->planesize[1] = image->planesize[2] = (pitch>>image->cshift_x)*(aligned_height>>image->cshift_y);
+
+    image->plane[0] = (uint8_t *)buffer->data;
+    image->plane[1] = image->plane[0] + image->planesize[0];
+    image->plane[2] = image->plane[1] + image->planesize[1];
+
+    CLog::Log(LOGDEBUG, "%s::%s - %p %d", CLASSNAME, __func__, buffer, source);
+    YUVBUFFER &buf = m_buffers[source];
+    memset(&buf, 0, sizeof buf);
+    buf.mmal_buffer = buffer;
+  }
+  else assert(0);
+
+  return source;
+}
+
+void CMMALRenderer::ReleaseBuffer(int idx)
+{
+  CSingleLock lock(m_sharedSection);
+  if (!m_bMMALConfigured || m_format == RENDER_FMT_BYPASS)
+    return;
+
+#if defined(MMAL_DEBUG_VERBOSE)
+  CLog::Log(LOGDEBUG, "%s::%s - %d (%p)", CLASSNAME, __func__, idx, m_buffers[idx].MMALBuffer);
+#endif
+  YUVBUFFER &buf = m_buffers[idx];
+  SAFE_RELEASE(buf.MMALBuffer);
+}
+
+void CMMALRenderer::ReleaseImage(int source, bool preserve)
+{
+#if defined(MMAL_DEBUG_VERBOSE)
+  CLog::Log(LOGDEBUG, "%s::%s - %d %d (%p)", CLASSNAME, __func__, source, preserve, m_buffers[source].MMALBuffer);
+#endif
+}
+
+void CMMALRenderer::Reset()
+{
+  CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
+}
+
+void CMMALRenderer::Flush()
+{
+  m_iYV12RenderBuffer = 0;
+  CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
+}
+
+void CMMALRenderer::Update()
+{
+#if defined(MMAL_DEBUG_VERBOSE)
+  CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
+#endif
+  if (!m_bConfigured) return;
+  ManageDisplay();
+}
+
+void CMMALRenderer::RenderUpdate(bool clear, DWORD flags, DWORD alpha)
+{
+  CSingleLock lock(m_sharedSection);
+  int source = m_iYV12RenderBuffer;
+#if defined(MMAL_DEBUG_VERBOSE)
+  CLog::Log(LOGDEBUG, "%s::%s - %d %x %d %d", CLASSNAME, __func__, clear, flags, alpha, source);
+#endif
+
+  if (!m_bConfigured) return;
+
+  if (g_graphicsContext.GetStereoMode())
+    g_graphicsContext.SetStereoView(RENDER_STEREO_VIEW_LEFT);
+  ManageDisplay();
+  if (g_graphicsContext.GetStereoMode())
+    g_graphicsContext.SetStereoView(RENDER_STEREO_VIEW_OFF);
+
+  // if running bypass, then the player might need the src/dst rects
+  // for sizing video playback on a layer other than the gles layer.
+  if (m_RenderUpdateCallBackFn)
+    (*m_RenderUpdateCallBackFn)(m_RenderUpdateCallBackCtx, m_sourceRect, m_destRect);
+
+  if (m_format == RENDER_FMT_BYPASS)
+    return;
+
+  SetVideoRect(m_sourceRect, m_destRect);
+
+  YUVBUFFER *buffer = &m_buffers[source];
+  if (m_format == RENDER_FMT_MMAL)
+  {
+    CMMALVideoBuffer *omvb = buffer->MMALBuffer;
+    if (omvb)
+    {
+#if defined(MMAL_DEBUG_VERBOSE)
+      CLog::Log(LOGDEBUG, "%s::%s %p (%p) f:%x", CLASSNAME, __func__, omvb, omvb->mmal_buffer, omvb->mmal_buffer->flags);
+#endif
+      // we only want to upload frames once
+      if (omvb->mmal_buffer->flags & MMAL_BUFFER_HEADER_FLAG_USER1)
+        return;
+      omvb->Acquire();
+      omvb->mmal_buffer->flags |= MMAL_BUFFER_HEADER_FLAG_USER1 | MMAL_BUFFER_HEADER_FLAG_USER2;
+      mmal_port_send_buffer(m_vout_input, omvb->mmal_buffer);
+    }
+    else
+      CLog::Log(LOGDEBUG, "%s::%s - No buffer to update", CLASSNAME, __func__);
+  }
+  else if (m_format == RENDER_FMT_YUV420P)
+  {
+    if (buffer->mmal_buffer)
+    {
+      CLog::Log(LOGDEBUG, "%s::%s - %p %d f:%x", CLASSNAME, __func__, buffer->mmal_buffer, source, buffer->mmal_buffer->flags);
+      // we only want to upload frames once
+      if (buffer->mmal_buffer->flags & MMAL_BUFFER_HEADER_FLAG_USER1)
+        return;
+      // sanity check it is not on display
+      buffer->mmal_buffer->flags |= MMAL_BUFFER_HEADER_FLAG_USER1 | MMAL_BUFFER_HEADER_FLAG_USER2;
+      mmal_port_send_buffer(m_vout_input, buffer->mmal_buffer);
+    }
+    else
+      CLog::Log(LOGDEBUG, "%s::%s - No buffer to update", CLASSNAME, __func__);
+  }
+  else assert(0);
+}
+
+void CMMALRenderer::FlipPage(int source)
+{
+  CSingleLock lock(m_sharedSection);
+  if (!m_bConfigured || m_format == RENDER_FMT_BYPASS)
+    return;
+
+#if defined(MMAL_DEBUG_VERBOSE)
+  CLog::Log(LOGDEBUG, "%s::%s - %d", CLASSNAME, __func__, source);
+#endif
+
+  m_iYV12RenderBuffer = source;
+}
+
+unsigned int CMMALRenderer::PreInit()
+{
+  CSingleLock lock(m_sharedSection);
+  m_bConfigured = false;
+  UnInit();
+
+  m_iFlags = 0;
+
+  m_resolution = CDisplaySettings::Get().GetCurrentResolution();
+  if ( m_resolution == RES_WINDOW )
+    m_resolution = RES_DESKTOP;
+
+  CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
+
+  m_formats.clear();
+  m_formats.push_back(RENDER_FMT_YUV420P);
+  m_formats.push_back(RENDER_FMT_MMAL);
+  m_formats.push_back(RENDER_FMT_BYPASS);
+
+  memset(m_buffers, 0, sizeof m_buffers);
+  m_iYV12RenderBuffer = 0;
+  m_NumYV12Buffers = NUM_BUFFERS;
+
+  return 0;
+}
+
+void CMMALRenderer::ReleaseBuffers()
+{
+  for (int i=0; i<NUM_BUFFERS; i++)
+    ReleaseBuffer(i);
+}
+
+void CMMALRenderer::UnInitMMAL()
+{
+  CSingleLock lock(m_sharedSection);
+  CLog::Log(LOGDEBUG, "%s::%s pool(%p)", CLASSNAME, __func__, m_vout_input_pool);
+  if (m_vout)
+  {
+    mmal_component_disable(m_vout);
+    mmal_port_disable(m_vout->control);
+  }
+
+  if (m_vout_input)
+  {
+    mmal_port_flush(m_vout_input);
+    mmal_port_disable(m_vout_input);
+    m_vout_input = NULL;
+  }
+
+  ReleaseBuffers();
+
+  if (m_vout_input_pool)
+  {
+    mmal_pool_destroy(m_vout_input_pool);
+    m_vout_input_pool = NULL;
+  }
+
+  if (m_vout)
+  {
+    mmal_component_release(m_vout);
+    m_vout = NULL;
+  }
+
+  m_RenderUpdateCallBackFn = NULL;
+  m_RenderUpdateCallBackCtx = NULL;
+
+  m_src_rect.SetRect(0, 0, 0, 0);
+  m_dst_rect.SetRect(0, 0, 0, 0);
+  m_video_stereo_mode = RENDER_STEREO_MODE_OFF;
+  m_display_stereo_mode = RENDER_STEREO_MODE_OFF;
+  m_StereoInvert = false;
+  m_format = RENDER_FMT_NONE;
+
+  m_bConfigured = false;
+  m_bMMALConfigured = false;
+}
+
+void CMMALRenderer::UnInit()
+{
+  UnInitMMAL();
+}
+
+bool CMMALRenderer::RenderCapture(CRenderCapture* capture)
+{
+  if (!m_bConfigured)
+    return false;
+
+  CLog::Log(LOGDEBUG, "%s::%s - %p", CLASSNAME, __func__, capture);
+
+  capture->BeginRender();
+  capture->EndRender();
+
+  return true;
+}
+
+//********************************************************************************************************
+// YV12 Texture creation, deletion, copying + clearing
+//********************************************************************************************************
+
+bool CMMALRenderer::Supports(EDEINTERLACEMODE mode)
+{
+  if(mode == VS_DEINTERLACEMODE_OFF
+  || mode == VS_DEINTERLACEMODE_AUTO
+  || mode == VS_DEINTERLACEMODE_FORCE)
+    return true;
+
+  return false;
+}
+
+bool CMMALRenderer::Supports(EINTERLACEMETHOD method)
+{
+  if (method == VS_INTERLACEMETHOD_AUTO)
+    return true;
+  if (method == VS_INTERLACEMETHOD_MMAL_ADVANCED)
+    return true;
+  if (method == VS_INTERLACEMETHOD_MMAL_ADVANCED_HALF)
+    return true;
+  if (method == VS_INTERLACEMETHOD_MMAL_BOB)
+    return true;
+  if (method == VS_INTERLACEMETHOD_MMAL_BOB_HALF)
+    return true;
+
+  return false;
+}
+
+bool CMMALRenderer::Supports(ERENDERFEATURE feature)
+{
+  if (feature == RENDERFEATURE_STRETCH         ||
+      feature == RENDERFEATURE_ZOOM            ||
+      feature == RENDERFEATURE_ROTATION        ||
+      feature == RENDERFEATURE_VERTICAL_SHIFT  ||
+      feature == RENDERFEATURE_PIXEL_RATIO)
+    return true;
+
+  return false;
+}
+
+bool CMMALRenderer::Supports(ESCALINGMETHOD method)
+{
+  return false;
+}
+
+EINTERLACEMETHOD CMMALRenderer::AutoInterlaceMethod()
+{
+  return VS_INTERLACEMETHOD_MMAL_ADVANCED;
+}
+
+void CMMALRenderer::SetVideoRect(const CRect& InSrcRect, const CRect& InDestRect)
+{
+  // we get called twice a frame for left/right. Can ignore the rights.
+  if (g_graphicsContext.GetStereoView() == RENDER_STEREO_VIEW_RIGHT)
+    return;
+  CSingleLock lock(m_sharedSection);
+
+  if (!m_vout_input)
+    return;
+
+  CRect SrcRect = InSrcRect, DestRect = InDestRect;
+  RENDER_STEREO_MODE video_stereo_mode = (m_iFlags & CONF_FLAGS_STEREO_MODE_SBS) ? RENDER_STEREO_MODE_SPLIT_VERTICAL :
+                                         (m_iFlags & CONF_FLAGS_STEREO_MODE_TAB) ? RENDER_STEREO_MODE_SPLIT_HORIZONTAL : RENDER_STEREO_MODE_OFF;
+  bool stereo_invert                   = (m_iFlags & CONF_FLAGS_STEREO_CADANCE_RIGHT_LEFT) ? true : false;
+  RENDER_STEREO_MODE display_stereo_mode = g_graphicsContext.GetStereoMode();
+
+  // fix up transposed video
+  if (m_renderOrientation == 90 || m_renderOrientation == 270)
+  {
+    float diff = (DestRect.Height() - DestRect.Width()) * 0.5f;
+    DestRect.x1 -= diff;
+    DestRect.x2 += diff;
+    DestRect.y1 += diff;
+    DestRect.y2 -= diff;
+  }
+
+  // check if destination rect or video view mode has changed
+  if (!(m_dst_rect != DestRect) && !(m_src_rect != SrcRect) && m_video_stereo_mode == video_stereo_mode && m_display_stereo_mode == display_stereo_mode && m_StereoInvert == stereo_invert)
+    return;
+
+  CLog::Log(LOGDEBUG, "%s::%s %d,%d,%d,%d -> %d,%d,%d,%d (o:%d v:%d d:%d i:%d)", CLASSNAME, __func__,
+      (int)SrcRect.x1, (int)SrcRect.y1, (int)SrcRect.x2, (int)SrcRect.y2,
+      (int)DestRect.x1, (int)DestRect.y1, (int)DestRect.x2, (int)DestRect.y2,
+      m_renderOrientation, video_stereo_mode, display_stereo_mode, stereo_invert);
+
+  m_src_rect = SrcRect;
+  m_dst_rect = DestRect;
+  m_video_stereo_mode = video_stereo_mode;
+  m_display_stereo_mode = display_stereo_mode;
+  m_StereoInvert = stereo_invert;
+
+  // might need to scale up m_dst_rect to display size as video decodes
+  // to separate video plane that is at display size.
+  RESOLUTION res = g_graphicsContext.GetVideoResolution();
+  CRect gui(0, 0, CDisplaySettings::Get().GetResolutionInfo(res).iWidth, CDisplaySettings::Get().GetResolutionInfo(res).iHeight);
+  CRect display(0, 0, CDisplaySettings::Get().GetResolutionInfo(res).iScreenWidth, CDisplaySettings::Get().GetResolutionInfo(res).iScreenHeight);
+
+  if (display_stereo_mode != RENDER_STEREO_MODE_OFF && display_stereo_mode != RENDER_STEREO_MODE_MONO)
+  switch (video_stereo_mode)
+  {
+  case RENDER_STEREO_MODE_SPLIT_VERTICAL:
+    // optimisation - use simpler display mode in common case of unscaled 3d with same display mode
+    if (video_stereo_mode == display_stereo_mode && DestRect.x1 == 0.0f && DestRect.x2 * 2.0f == gui.Width() && !stereo_invert)
+    {
+      SrcRect.x2 *= 2.0f;
+      DestRect.x2 *= 2.0f;
+      video_stereo_mode = RENDER_STEREO_MODE_OFF;
+      display_stereo_mode = RENDER_STEREO_MODE_OFF;
+    }
+    else if (display_stereo_mode == RENDER_STEREO_MODE_ANAGLYPH_RED_CYAN || display_stereo_mode == RENDER_STEREO_MODE_ANAGLYPH_GREEN_MAGENTA || display_stereo_mode == RENDER_STEREO_MODE_ANAGLYPH_YELLOW_BLUE)
+    {
+      SrcRect.x2 *= 2.0f;
+    }
+    break;
+
+  case RENDER_STEREO_MODE_SPLIT_HORIZONTAL:
+    // optimisation - use simpler display mode in common case of unscaled 3d with same display mode
+    if (video_stereo_mode == display_stereo_mode && DestRect.y1 == 0.0f && DestRect.y2 * 2.0f == gui.Height() && !stereo_invert)
+    {
+      SrcRect.y2 *= 2.0f;
+      DestRect.y2 *= 2.0f;
+      video_stereo_mode = RENDER_STEREO_MODE_OFF;
+      display_stereo_mode = RENDER_STEREO_MODE_OFF;
+    }
+    else if (display_stereo_mode == RENDER_STEREO_MODE_ANAGLYPH_RED_CYAN || display_stereo_mode == RENDER_STEREO_MODE_ANAGLYPH_GREEN_MAGENTA || display_stereo_mode == RENDER_STEREO_MODE_ANAGLYPH_YELLOW_BLUE)
+    {
+      SrcRect.y2 *= 2.0f;
+    }
+    break;
+
+  default: break;
+  }
+
+  if (gui != display)
+  {
+    float xscale = display.Width()  / gui.Width();
+    float yscale = display.Height() / gui.Height();
+    DestRect.x1 *= xscale;
+    DestRect.x2 *= xscale;
+    DestRect.y1 *= yscale;
+    DestRect.y2 *= yscale;
+  }
+
+  MMAL_DISPLAYREGION_T region;
+  memset(&region, 0, sizeof region);
+
+  region.set                 = MMAL_DISPLAY_SET_DEST_RECT|MMAL_DISPLAY_SET_SRC_RECT|MMAL_DISPLAY_SET_FULLSCREEN|MMAL_DISPLAY_SET_NOASPECT|MMAL_DISPLAY_SET_MODE;
+  region.dest_rect.x         = lrintf(DestRect.x1);
+  region.dest_rect.y         = lrintf(DestRect.y1);
+  region.dest_rect.width     = lrintf(DestRect.Width());
+  region.dest_rect.height    = lrintf(DestRect.Height());
+
+  region.src_rect.x          = lrintf(SrcRect.x1);
+  region.src_rect.y          = lrintf(SrcRect.y1);
+  region.src_rect.width      = lrintf(SrcRect.Width());
+  region.src_rect.height     = lrintf(SrcRect.Height());
+
+  region.fullscreen = MMAL_FALSE;
+  region.noaspect = MMAL_TRUE;
+
+  if (m_renderOrientation)
+  {
+    region.set |= MMAL_DISPLAY_SET_TRANSFORM;
+    if (m_renderOrientation == 90)
+      region.transform = MMAL_DISPLAY_ROT90;
+    else if (m_renderOrientation == 180)
+      region.transform = MMAL_DISPLAY_ROT180;
+    else if (m_renderOrientation == 270)
+      region.transform = MMAL_DISPLAY_ROT270;
+    else assert(0);
+  }
+
+  if (video_stereo_mode == RENDER_STEREO_MODE_SPLIT_HORIZONTAL && display_stereo_mode == RENDER_STEREO_MODE_SPLIT_HORIZONTAL)
+    region.mode = MMAL_DISPLAY_MODE_STEREO_TOP_TO_TOP;
+  else if (video_stereo_mode == RENDER_STEREO_MODE_SPLIT_HORIZONTAL && display_stereo_mode == RENDER_STEREO_MODE_SPLIT_VERTICAL)
+    region.mode = MMAL_DISPLAY_MODE_STEREO_TOP_TO_LEFT;
+  else if (video_stereo_mode == RENDER_STEREO_MODE_SPLIT_VERTICAL && display_stereo_mode == RENDER_STEREO_MODE_SPLIT_HORIZONTAL)
+    region.mode = MMAL_DISPLAY_MODE_STEREO_LEFT_TO_TOP;
+  else if (video_stereo_mode == RENDER_STEREO_MODE_SPLIT_VERTICAL && display_stereo_mode == RENDER_STEREO_MODE_SPLIT_VERTICAL)
+    region.mode = MMAL_DISPLAY_MODE_STEREO_LEFT_TO_LEFT;
+  else
+    region.mode = MMAL_DISPLAY_MODE_LETTERBOX;
+
+  MMAL_STATUS_T status = mmal_util_set_display_region(m_vout_input, &region);
+  if (status != MMAL_SUCCESS)
+    CLog::Log(LOGERROR, "%s::%s Failed to set display region (status=%x %s)", CLASSNAME, __func__, status, mmal_status_to_string(status));
+
+  CLog::Log(LOGDEBUG, "%s::%s %d,%d,%d,%d -> %d,%d,%d,%d mode:%d", CLASSNAME, __func__,
+      region.src_rect.x, region.src_rect.y, region.src_rect.width, region.src_rect.height,
+      region.dest_rect.x, region.dest_rect.y, region.dest_rect.width, region.dest_rect.height, region.mode);
+}
diff --git a/xbmc/cores/VideoRenderers/HwDecRender/MMALRenderer.h b/xbmc/cores/VideoRenderers/HwDecRender/MMALRenderer.h
new file mode 100644
index 0000000..1404fb3
--- /dev/null
+++ b/xbmc/cores/VideoRenderers/HwDecRender/MMALRenderer.h
@@ -0,0 +1,117 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "guilib/GraphicContext.h"
+#include "RenderFlags.h"
+#include "RenderFormats.h"
+#include "BaseRenderer.h"
+#include "RenderCapture.h"
+#include "settings/VideoSettings.h"
+#include "cores/dvdplayer/DVDStreamInfo.h"
+#include "guilib/Geometry.h"
+#include "BaseRenderer.h"
+
+#include <interface/mmal/mmal.h>
+#include <interface/mmal/util/mmal_util.h>
+#include <interface/mmal/util/mmal_default_components.h>
+#include <interface/mmal/util/mmal_util_params.h>
+
+#define AUTOSOURCE -1
+
+class CBaseTexture;
+class CMMALVideoBuffer;
+
+struct DVDVideoPicture;
+
+class CMMALRenderer : public CBaseRenderer
+{
+  struct YUVBUFFER
+  {
+    CMMALVideoBuffer *MMALBuffer; // used for hw decoded buffers
+    MMAL_BUFFER_HEADER_T *mmal_buffer;  // used for sw decoded buffers
+  };
+public:
+  CMMALRenderer();
+  ~CMMALRenderer();
+
+  virtual void Update();
+  virtual void SetupScreenshot() {};
+
+  bool RenderCapture(CRenderCapture* capture);
+
+  // Player functions
+  virtual bool         Configure(unsigned int width, unsigned int height, unsigned int d_width, unsigned int d_height, float fps, unsigned flags, ERenderFormat format, unsigned extended_format, unsigned int orientation);
+  virtual int          GetImage(YV12Image *image, int source = AUTOSOURCE, bool readonly = false);
+  virtual void         ReleaseImage(int source, bool preserve = false);
+  virtual void         ReleaseBuffer(int idx);
+  virtual void         FlipPage(int source);
+  virtual unsigned int PreInit();
+  virtual void         UnInit();
+  virtual void         Reset(); /* resets renderer after seek for example */
+  virtual void         Flush();
+  virtual bool         IsConfigured() { return m_bConfigured; }
+  virtual void         AddProcessor(CMMALVideoBuffer *buffer, int index);
+  virtual CRenderInfo GetRenderInfo();
+
+  virtual bool         Supports(ERENDERFEATURE feature);
+  virtual bool         Supports(EDEINTERLACEMODE mode);
+  virtual bool         Supports(EINTERLACEMETHOD method);
+  virtual bool         Supports(ESCALINGMETHOD method);
+
+  virtual EINTERLACEMETHOD AutoInterlaceMethod();
+
+  void                 RenderUpdate(bool clear, DWORD flags = 0, DWORD alpha = 255);
+
+  virtual void         SetBufferSize(int numBuffers) { m_NumYV12Buffers = numBuffers; }
+  virtual void SetVideoRect(const CRect& SrcRect, const CRect& DestRect);
+  virtual bool         IsGuiLayer() { return false; }
+
+  void vout_input_port_cb(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer);
+protected:
+  int m_iYV12RenderBuffer;
+  int m_NumYV12Buffers;
+
+  std::vector<ERenderFormat> m_formats;
+
+  YUVBUFFER            m_buffers[NUM_BUFFERS];
+  bool                 m_bConfigured;
+  bool                 m_bMMALConfigured;
+  unsigned int         m_extended_format;
+  unsigned int         m_destWidth;
+  unsigned int         m_destHeight;
+  int                  m_neededBuffers;
+
+  CRect                     m_src_rect;
+  CRect                     m_dst_rect;
+  RENDER_STEREO_MODE        m_video_stereo_mode;
+  RENDER_STEREO_MODE        m_display_stereo_mode;
+  bool                      m_StereoInvert;
+
+  CCriticalSection m_sharedSection;
+  MMAL_COMPONENT_T *m_vout;
+  MMAL_PORT_T *m_vout_input;
+  MMAL_POOL_T *m_vout_input_pool;
+
+  bool init_vout(ERenderFormat format);
+  void ReleaseBuffers();
+  void UnInitMMAL();
+};
diff --git a/xbmc/cores/VideoRenderers/HwDecRender/Makefile b/xbmc/cores/VideoRenderers/HwDecRender/Makefile
new file mode 100644
index 0000000..8bff279
--- /dev/null
+++ b/xbmc/cores/VideoRenderers/HwDecRender/Makefile
@@ -0,0 +1,15 @@
+SRCS=
+
+ifeq (1,1)
+SRCS += RendererVAAPI.cpp
+SRCS += RendererVDPAU.cpp
+endif
+
+ifeq (,1)
+SRCS += MMALRenderer.cpp
+endif
+     
+LIB=HwDecRender.a
+
+include ../../../../Makefile.include
+-include $(patsubst %.cpp,%.P,$(patsubst %.c,%.P,$(SRCS)))
diff --git a/xbmc/cores/VideoRenderers/HwDecRender/Makefile.in b/xbmc/cores/VideoRenderers/HwDecRender/Makefile.in
new file mode 100644
index 0000000..a302e28
--- /dev/null
+++ b/xbmc/cores/VideoRenderers/HwDecRender/Makefile.in
@@ -0,0 +1,15 @@
+SRCS=
+
+ifeq (@USE_OPENGL@,1)
+SRCS += RendererVAAPI.cpp
+SRCS += RendererVDPAU.cpp
+endif
+
+ifeq (@USE_MMAL@,1)
+SRCS += MMALRenderer.cpp
+endif
+     
+LIB=HwDecRender.a
+
+include ../../../../Makefile.include
+-include $(patsubst %.cpp,%.P,$(patsubst %.c,%.P,$(SRCS)))
\ No newline at end of file
diff --git a/xbmc/cores/VideoRenderers/HwDecRender/RendererVAAPI.cpp b/xbmc/cores/VideoRenderers/HwDecRender/RendererVAAPI.cpp
new file mode 100644
index 0000000..2744a5a
--- /dev/null
+++ b/xbmc/cores/VideoRenderers/HwDecRender/RendererVAAPI.cpp
@@ -0,0 +1,264 @@
+/*
+ *      Copyright (C) 2007-2015 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "RendererVAAPI.h"
+
+#ifdef HAVE_LIBVA
+
+#include "cores/dvdplayer/DVDCodecs/Video/VAAPI.h"
+#include "cores/dvdplayer/DVDCodecs/DVDCodecUtils.h"
+#include "settings/Settings.h"
+#include "settings/AdvancedSettings.h"
+#include "utils/log.h"
+
+CRendererVAAPI::CRendererVAAPI()
+{
+
+}
+
+CRendererVAAPI::~CRendererVAAPI()
+{
+  for (int i = 0; i < NUM_BUFFERS; ++i)
+  {
+    DeleteTexture(i);
+  }
+}
+
+void CRendererVAAPI::AddVideoPictureHW(DVDVideoPicture &picture, int index)
+{
+  VAAPI::CVaapiRenderPicture *vaapi = picture.vaapi;
+  YUVBUFFER &buf = m_buffers[index];
+  VAAPI::CVaapiRenderPicture *pic = vaapi->Acquire();
+  if (buf.hwDec)
+    ((VAAPI::CVaapiRenderPicture*)buf.hwDec)->Release();
+  buf.hwDec = pic;
+
+  if (m_format == RENDER_FMT_VAAPINV12)
+  {
+    YV12Image &im = m_buffers[index].image;
+    CDVDCodecUtils::CopyNV12Picture(&im, &vaapi->DVDPic);
+  }
+}
+
+void CRendererVAAPI::ReleaseBuffer(int idx)
+{
+  YUVBUFFER &buf = m_buffers[idx];
+  if (buf.hwDec)
+    ((VAAPI::CVaapiRenderPicture*)buf.hwDec)->Release();
+  buf.hwDec = NULL;
+}
+
+CRenderInfo CRendererVAAPI::GetRenderInfo()
+{
+  CRenderInfo info;
+  info.formats = m_formats;
+  info.max_buffer_size = NUM_BUFFERS;
+  if (m_format == RENDER_FMT_VAAPINV12)
+    info.optimal_buffer_size = 3;
+  else
+    info.optimal_buffer_size = 5;
+  return info;
+}
+
+bool CRendererVAAPI::Supports(ERENDERFEATURE feature)
+{
+  if (m_format == RENDER_FMT_VAAPINV12)
+    return CLinuxRendererGL::Supports(feature);
+
+  if (feature == RENDERFEATURE_STRETCH         ||
+      feature == RENDERFEATURE_ZOOM            ||
+      feature == RENDERFEATURE_VERTICAL_SHIFT  ||
+      feature == RENDERFEATURE_PIXEL_RATIO     ||
+      feature == RENDERFEATURE_POSTPROCESS     ||
+      feature == RENDERFEATURE_ROTATION        ||
+      feature == RENDERFEATURE_NONLINSTRETCH)
+    return true;
+
+  return false;
+}
+
+bool CRendererVAAPI::Supports(EINTERLACEMETHOD method)
+{
+  VAAPI::CVaapiRenderPicture *vaapiPic = (VAAPI::CVaapiRenderPicture*)m_buffers[m_iYV12RenderBuffer].hwDec;
+  if(vaapiPic && vaapiPic->vaapi)
+    return vaapiPic->vaapi->Supports(method);
+  return false;
+}
+
+bool CRendererVAAPI::Supports(ESCALINGMETHOD method)
+{
+  if (m_format == RENDER_FMT_VAAPINV12)
+    return CLinuxRendererGL::Supports(method);
+
+  //nearest neighbor doesn't work on YUY2 and UYVY
+  if (method == VS_SCALINGMETHOD_NEAREST &&
+      m_format != RENDER_FMT_YUYV422 &&
+      m_format != RENDER_FMT_UYVY422)
+    return true;
+
+  if(method == VS_SCALINGMETHOD_LINEAR
+  || method == VS_SCALINGMETHOD_AUTO)
+    return true;
+
+  if(method == VS_SCALINGMETHOD_CUBIC
+  || method == VS_SCALINGMETHOD_LANCZOS2
+  || method == VS_SCALINGMETHOD_SPLINE36_FAST
+  || method == VS_SCALINGMETHOD_LANCZOS3_FAST
+  || method == VS_SCALINGMETHOD_SPLINE36
+  || method == VS_SCALINGMETHOD_LANCZOS3)
+  {
+    // if scaling is below level, avoid hq scaling
+    float scaleX = fabs(((float)m_sourceWidth - m_destRect.Width())/m_sourceWidth)*100;
+    float scaleY = fabs(((float)m_sourceHeight - m_destRect.Height())/m_sourceHeight)*100;
+    int minScale = CSettings::Get().GetInt("videoplayer.hqscalers");
+    if (scaleX < minScale && scaleY < minScale)
+      return false;
+
+    // spline36 and lanczos3 are only allowed through advancedsettings.xml
+    if(method != VS_SCALINGMETHOD_SPLINE36
+        && method != VS_SCALINGMETHOD_LANCZOS3)
+      return true;
+    else
+      return g_advancedSettings.m_videoEnableHighQualityHwScalers;
+  }
+
+  return false;
+}
+
+bool CRendererVAAPI::LoadShadersHook()
+{
+  if (m_format == RENDER_FMT_VAAPINV12)
+    return false;
+
+  CLog::Log(LOGNOTICE, "GL: Using VAAPI render method");
+  m_renderMethod = RENDER_VAAPI;
+  return true;
+}
+
+bool CRendererVAAPI::RenderHook(int idx)
+{
+  if (m_format == RENDER_FMT_VAAPINV12)
+    return false;
+
+  UpdateVideoFilter();
+  RenderRGB(idx, m_currentField);
+  YUVBUFFER &buf = m_buffers[idx];
+  if (buf.hwDec)
+  {
+    ((VAAPI::CVaapiRenderPicture*)buf.hwDec)->Sync();
+  }
+  return true;
+}
+
+bool CRendererVAAPI::CreateTexture(int index)
+{
+  if (m_format == RENDER_FMT_VAAPINV12)
+  {
+    return CreateNV12Texture(index);
+  }
+
+  YV12Image &im     = m_buffers[index].image;
+  YUVFIELDS &fields = m_buffers[index].fields;
+  YUVPLANE  &plane  = fields[0][0];
+
+  DeleteTexture(index);
+
+  memset(&im    , 0, sizeof(im));
+  memset(&fields, 0, sizeof(fields));
+  im.height = m_sourceHeight;
+  im.width  = m_sourceWidth;
+
+  plane.texwidth  = im.width;
+  plane.texheight = im.height;
+
+  plane.pixpertex_x = 1;
+  plane.pixpertex_y = 1;
+
+  plane.id = 1;
+
+  return true;
+}
+
+void CRendererVAAPI::DeleteTexture(int index)
+{
+  if (m_format == RENDER_FMT_VAAPINV12)
+  {
+    DeleteNV12Texture(index);
+    return;
+  }
+
+  YUVPLANE &plane = m_buffers[index].fields[FIELD_FULL][0];
+  if (m_buffers[index].hwDec)
+    ((VAAPI::CVaapiRenderPicture*)m_buffers[index].hwDec)->Release();
+  m_buffers[index].hwDec = NULL;
+  plane.id = 0;
+}
+
+bool CRendererVAAPI::UploadTexture(int index)
+{
+  if (m_format == RENDER_FMT_VAAPINV12)
+  {
+    return UploadNV12Texture(index);
+  }
+
+  VAAPI::CVaapiRenderPicture *vaapi = (VAAPI::CVaapiRenderPicture*)m_buffers[index].hwDec;
+
+  YUVFIELDS &fields = m_buffers[index].fields;
+  YUVPLANE &plane = fields[FIELD_FULL][0];
+
+  if (!vaapi || !vaapi->valid)
+  {
+    return false;
+  }
+
+  if (!vaapi->CopyGlx())
+    return false;
+
+  plane.id = vaapi->texture;
+
+  // in stereoscopic mode sourceRect may only
+  // be a part of the source video surface
+  plane.rect = m_sourceRect;
+
+  // clip rect
+  if (vaapi->crop.x1 > plane.rect.x1)
+    plane.rect.x1 = vaapi->crop.x1;
+  if (vaapi->crop.x2 < plane.rect.x2)
+    plane.rect.x2 = vaapi->crop.x2;
+  if (vaapi->crop.y1 > plane.rect.y1)
+    plane.rect.y1 = vaapi->crop.y1;
+  if (vaapi->crop.y2 < plane.rect.y2)
+    plane.rect.y2 = vaapi->crop.y2;
+
+  plane.texheight = vaapi->texHeight;
+  plane.texwidth  = vaapi->texWidth;
+
+  if (m_textureTarget == GL_TEXTURE_2D)
+  {
+    plane.rect.y1 /= plane.texheight;
+    plane.rect.y2 /= plane.texheight;
+    plane.rect.x1 /= plane.texwidth;
+    plane.rect.x2 /= plane.texwidth;
+  }
+  return true;
+}
+
+
+#endif
diff --git a/xbmc/cores/VideoRenderers/HwDecRender/RendererVAAPI.h b/xbmc/cores/VideoRenderers/HwDecRender/RendererVAAPI.h
new file mode 100644
index 0000000..c6d0615
--- /dev/null
+++ b/xbmc/cores/VideoRenderers/HwDecRender/RendererVAAPI.h
@@ -0,0 +1,56 @@
+/*
+ *      Copyright (C) 2007-2015 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#pragma once
+
+#include "system.h"
+
+#ifdef HAVE_LIBVA
+
+#include "cores/VideoRenderers/LinuxRendererGL.h"
+
+class CRendererVAAPI : public CLinuxRendererGL
+{
+public:
+  CRendererVAAPI();
+  virtual ~CRendererVAAPI();
+
+  // Player functions
+  virtual void AddVideoPictureHW(DVDVideoPicture &picture, int index);
+  virtual void ReleaseBuffer(int idx);
+  virtual CRenderInfo GetRenderInfo();
+
+  // Feature support
+  virtual bool Supports(ERENDERFEATURE feature);
+  virtual bool Supports(EINTERLACEMETHOD method);
+  virtual bool Supports(ESCALINGMETHOD method);
+
+protected:
+  virtual bool LoadShadersHook();
+  virtual bool RenderHook(int idx);
+
+  // textures
+  virtual bool UploadTexture(int index);
+  virtual void DeleteTexture(int index);
+  virtual bool CreateTexture(int index);
+};
+
+#endif
+
diff --git a/xbmc/cores/VideoRenderers/HwDecRender/RendererVDA.cpp b/xbmc/cores/VideoRenderers/HwDecRender/RendererVDA.cpp
new file mode 100644
index 0000000..41c9add
--- /dev/null
+++ b/xbmc/cores/VideoRenderers/HwDecRender/RendererVDA.cpp
@@ -0,0 +1,174 @@
+/*
+ *      Copyright (C) 2007-2015 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "RendererVDA.h"
+
+#if defined(TARGET_DARWIN_OSX)
+
+#include "settings/Settings.h"
+#include "settings/AdvancedSettings.h"
+#include "cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h"
+#include "utils/log.h"
+#include "osx/CocoaInterface.h"
+#include <CoreVideo/CoreVideo.h>
+#include <OpenGL/CGLIOSurface.h>
+#include "windowing/WindowingFactory.h"
+
+CRendererVDA::CRendererVDA()
+{
+
+}
+
+CRendererVDA::~CRendererVDA()
+{
+
+}
+
+void CRendererVDA::AddVideoPictureHW(DVDVideoPicture &picture, int index)
+{
+  YUVBUFFER &buf = m_buffers[index];
+  if (buf.hwDec)
+    CVBufferRelease((struct __CVBuffer *)buf.hwDec);
+  buf.hwDec = picture.cvBufferRef;
+  // retain another reference, this way dvdplayer and renderer can issue releases.
+  CVBufferRetain(picture.cvBufferRef);
+}
+
+void CRendererVDA::ReleaseBuffer(int idx)
+{
+  YUVBUFFER &buf = m_buffers[idx];
+  if (buf.hwDec)
+    CVBufferRelease((struct __CVBuffer *)buf.hwDec);
+  buf.hwDec = NULL;
+}
+
+
+bool CRendererVDA::Supports(EINTERLACEMETHOD method)
+{
+  return false;
+}
+
+bool CRendererVDA::Supports(EDEINTERLACEMODE mode)
+{
+  return false;
+}
+
+EINTERLACEMETHOD CRendererVDA::AutoInterlaceMethod()
+{
+  return VS_INTERLACEMETHOD_NONE;
+}
+
+bool CRendererVDA::LoadShadersHook()
+{
+  CLog::Log(LOGNOTICE, "GL: Using CVBREF render method");
+  // m_renderMethod = RENDER_CVREF;
+  m_textureTarget = GL_TEXTURE_RECTANGLE_ARB;
+  return false;
+}
+
+bool CRendererVDA::CreateTexture(int index)
+{
+  YV12Image &im     = m_buffers[index].image;
+  YUVFIELDS &fields = m_buffers[index].fields;
+  YUVPLANE  &plane  = fields[0][0];
+
+  DeleteTexture(index);
+
+  memset(&im    , 0, sizeof(im));
+  memset(&fields, 0, sizeof(fields));
+
+  im.bpp    = 1;
+  im.width  = m_sourceWidth;
+  im.height = m_sourceHeight;
+  im.cshift_x = 0;
+  im.cshift_y = 0;
+
+  plane.pixpertex_x = 2;
+  plane.pixpertex_y = 1;
+  plane.texwidth    = im.width  / plane.pixpertex_x;
+  plane.texheight   = im.height / plane.pixpertex_y;
+
+  if(m_renderMethod & RENDER_POT)
+  {
+    plane.texwidth  = NP2(plane.texwidth);
+    plane.texheight = NP2(plane.texheight);
+  }
+
+  glEnable(m_textureTarget);
+  glGenTextures(1, &plane.id);
+  glDisable(m_textureTarget);
+
+  return true;
+}
+
+void CRendererVDA::DeleteTexture(int index)
+{
+  YUVPLANE  &plane = m_buffers[index].fields[0][0];
+
+  if (m_buffers[index].hwDec)
+    CVBufferRelease((struct __CVBuffer *)m_buffers[index].hwDec);
+  m_buffers[index].hwDec = NULL;
+
+  if (plane.id && glIsTexture(plane.id))
+    glDeleteTextures(1, &plane.id), plane.id = 0;
+}
+
+bool CRendererVDA::UploadTexture(int index)
+{
+  YUVBUFFER &buf    = m_buffers[index];
+  YUVFIELDS &fields = buf.fields;
+
+  CVBufferRef cvBufferRef = (struct __CVBuffer *)m_buffers[index].hwDec;
+
+  glEnable(m_textureTarget);
+
+  if (cvBufferRef && fields[m_currentField][0].flipindex != buf.flipindex)
+  {
+
+    // It is the fastest way to render a CVPixelBuffer backed
+    // with an IOSurface as there is no CPU -> GPU upload.
+    CGLContextObj cgl_ctx  = (CGLContextObj)g_Windowing.GetCGLContextObj();
+    IOSurfaceRef	surface  = CVPixelBufferGetIOSurface(cvBufferRef);
+    GLsizei       texWidth = IOSurfaceGetWidth(surface);
+    GLsizei       texHeight= IOSurfaceGetHeight(surface);
+    OSType        format_type = IOSurfaceGetPixelFormat(surface);
+
+    glBindTexture(m_textureTarget, fields[FIELD_FULL][0].id);
+
+    if (format_type == kCVPixelFormatType_422YpCbCr8)
+      CGLTexImageIOSurface2D(cgl_ctx, m_textureTarget, GL_RGBA8,
+                             texWidth / 2, texHeight, GL_BGRA, GL_UNSIGNED_INT_8_8_8_8_REV, surface, 0);
+    else if (format_type == kCVPixelFormatType_32BGRA)
+      CGLTexImageIOSurface2D(cgl_ctx, m_textureTarget, GL_RGBA8,
+                             texWidth, texHeight, GL_BGRA, GL_UNSIGNED_INT_8_8_8_8_REV, surface, 0);
+
+    glBindTexture(m_textureTarget, 0);
+    fields[FIELD_FULL][0].flipindex = buf.flipindex;
+
+  }
+
+
+  CalculateTextureSourceRects(index, 3);
+  glDisable(m_textureTarget);
+
+  return true;
+}
+
+#endif
\ No newline at end of file
diff --git a/xbmc/cores/VideoRenderers/HwDecRender/RendererVDA.h b/xbmc/cores/VideoRenderers/HwDecRender/RendererVDA.h
new file mode 100644
index 0000000..a170dd6
--- /dev/null
+++ b/xbmc/cores/VideoRenderers/HwDecRender/RendererVDA.h
@@ -0,0 +1,54 @@
+/*
+ *      Copyright (C) 2007-2015 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#pragma once
+
+#include "system.h"
+
+#if defined(TARGET_DARWIN_OSX)
+
+#include "cores/VideoRenderers/LinuxRendererGL.h"
+
+class CRendererVDA : public CLinuxRendererGL
+{
+public:
+  CRendererVDA();
+  virtual ~CRendererVDA();
+
+  // Player functions
+  virtual void AddVideoPictureHW(DVDVideoPicture &picture, int index);
+  virtual void ReleaseBuffer(int idx);
+
+  // Feature support
+  virtual bool Supports(EINTERLACEMETHOD method);
+  virtual bool Supports(EDEINTERLACEMODE mode);
+
+  virtual EINTERLACEMETHOD AutoInterlaceMethod();
+
+protected:
+  virtual bool LoadShadersHook();
+
+  // textures
+  virtual bool UploadTexture(int index);
+  virtual void DeleteTexture(int index);
+  virtual bool CreateTexture(int index);
+};
+
+#endif
diff --git a/xbmc/cores/VideoRenderers/HwDecRender/RendererVDPAU.cpp b/xbmc/cores/VideoRenderers/HwDecRender/RendererVDPAU.cpp
new file mode 100644
index 0000000..852f4b1
--- /dev/null
+++ b/xbmc/cores/VideoRenderers/HwDecRender/RendererVDPAU.cpp
@@ -0,0 +1,418 @@
+/*
+ *      Copyright (C) 2007-2015 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "RendererVDPAU.h"
+
+#ifdef HAVE_LIBVDPAU
+
+#include "cores/dvdplayer/DVDCodecs/Video/VDPAU.h"
+#include "settings/Settings.h"
+#include "settings/AdvancedSettings.h"
+#include "utils/log.h"
+#include "utils/GLUtils.h"
+
+CRendererVDPAU::CRendererVDPAU()
+{
+
+}
+
+CRendererVDPAU::~CRendererVDPAU()
+{
+  for (int i = 0; i < NUM_BUFFERS; ++i)
+  {
+    DeleteTexture(i);
+  }
+}
+
+void CRendererVDPAU::AddVideoPictureHW(DVDVideoPicture &picture, int index)
+{
+  VDPAU::CVdpauRenderPicture *vdpau = picture.vdpau;
+  YUVBUFFER &buf = m_buffers[index];
+  VDPAU::CVdpauRenderPicture *pic = vdpau->Acquire();
+  if (buf.hwDec)
+    ((VDPAU::CVdpauRenderPicture*)buf.hwDec)->Release();
+  buf.hwDec = pic;
+}
+
+void CRendererVDPAU::ReleaseBuffer(int idx)
+{
+  YUVBUFFER &buf = m_buffers[idx];
+  if (buf.hwDec)
+    ((VDPAU::CVdpauRenderPicture*)buf.hwDec)->Release();
+  buf.hwDec = NULL;
+}
+
+CRenderInfo CRendererVDPAU::GetRenderInfo()
+{
+  CRenderInfo info;
+  info.formats = m_formats;
+  info.max_buffer_size = NUM_BUFFERS;
+  info.optimal_buffer_size = 5;
+  return info;
+}
+
+bool CRendererVDPAU::Supports(ERENDERFEATURE feature)
+{
+  if(feature == RENDERFEATURE_BRIGHTNESS ||
+     feature == RENDERFEATURE_CONTRAST)
+  {
+    if ((m_renderMethod & RENDER_VDPAU) && !CSettings::Get().GetBool("videoscreen.limitedrange"))
+      return true;
+
+    return (m_renderMethod & RENDER_GLSL)
+        || (m_renderMethod & RENDER_ARB)
+        || ((m_renderMethod & RENDER_SW) && glewIsSupported("GL_ARB_imaging") == GL_TRUE);
+  }
+  else if (feature == RENDERFEATURE_NOISE ||
+           feature == RENDERFEATURE_SHARPNESS)
+  {
+    if (m_format == RENDER_FMT_VDPAU)
+      return true;
+  }
+  else if (feature == RENDERFEATURE_STRETCH         ||
+           feature == RENDERFEATURE_ZOOM            ||
+           feature == RENDERFEATURE_VERTICAL_SHIFT  ||
+           feature == RENDERFEATURE_PIXEL_RATIO     ||
+           feature == RENDERFEATURE_POSTPROCESS     ||
+           feature == RENDERFEATURE_ROTATION        ||
+           feature == RENDERFEATURE_NONLINSTRETCH)
+    return true;
+
+  return false;
+}
+
+bool CRendererVDPAU::Supports(EINTERLACEMETHOD method)
+{
+  VDPAU::CVdpauRenderPicture *VDPAUPic = (VDPAU::CVdpauRenderPicture*)m_buffers[m_iYV12RenderBuffer].hwDec;
+  if(VDPAUPic && VDPAUPic->vdpau)
+    return VDPAUPic->vdpau->Supports(method);
+  return false;
+}
+
+bool CRendererVDPAU::Supports(ESCALINGMETHOD method)
+{
+  if (m_format == RENDER_FMT_VDPAU_420)
+    return CLinuxRendererGL::Supports(method);
+
+  //nearest neighbor doesn't work on YUY2 and UYVY
+  if (method == VS_SCALINGMETHOD_NEAREST &&
+      m_format != RENDER_FMT_YUYV422 &&
+      m_format != RENDER_FMT_UYVY422)
+    return true;
+
+  if(method == VS_SCALINGMETHOD_LINEAR
+  || method == VS_SCALINGMETHOD_AUTO)
+    return true;
+
+  if(method == VS_SCALINGMETHOD_CUBIC
+  || method == VS_SCALINGMETHOD_LANCZOS2
+  || method == VS_SCALINGMETHOD_SPLINE36_FAST
+  || method == VS_SCALINGMETHOD_LANCZOS3_FAST
+  || method == VS_SCALINGMETHOD_SPLINE36
+  || method == VS_SCALINGMETHOD_LANCZOS3)
+  {
+    // if scaling is below level, avoid hq scaling
+    float scaleX = fabs(((float)m_sourceWidth - m_destRect.Width())/m_sourceWidth)*100;
+    float scaleY = fabs(((float)m_sourceHeight - m_destRect.Height())/m_sourceHeight)*100;
+    int minScale = CSettings::Get().GetInt("videoplayer.hqscalers");
+    if (scaleX < minScale && scaleY < minScale)
+      return false;
+
+    // spline36 and lanczos3 are only allowed through advancedsettings.xml
+    if(method != VS_SCALINGMETHOD_SPLINE36
+        && method != VS_SCALINGMETHOD_LANCZOS3)
+      return true;
+    else
+      return g_advancedSettings.m_videoEnableHighQualityHwScalers;
+  }
+
+  return false;
+}
+
+bool CRendererVDPAU::LoadShadersHook()
+{
+  if (m_format == RENDER_FMT_VDPAU)
+  {
+    CLog::Log(LOGNOTICE, "GL: Using VDPAU render method");
+    m_renderMethod = RENDER_VDPAU;
+    return true;
+  }
+  return false;
+}
+
+bool CRendererVDPAU::RenderHook(int idx)
+{
+  UpdateVideoFilter();
+
+  if (m_format == RENDER_FMT_VDPAU_420)
+  {
+    switch(m_renderQuality)
+    {
+    case RQ_LOW:
+    case RQ_SINGLEPASS:
+      if (m_currentField == FIELD_FULL)
+        RenderProgressiveWeave(idx, m_currentField);
+      else
+        RenderSinglePass(idx, m_currentField);
+      VerifyGLState();
+      break;
+
+    case RQ_MULTIPASS:
+      if (m_currentField == FIELD_FULL)
+        RenderProgressiveWeave(idx, m_currentField);
+      else
+      {
+        RenderToFBO(idx, m_currentField);
+        RenderFromFBO();
+      }
+      VerifyGLState();
+      break;
+    }
+  }
+  else
+  {
+    RenderRGB(idx, m_currentField);
+  }
+
+  YUVBUFFER &buf = m_buffers[idx];
+  if (buf.hwDec)
+  {
+    ((VDPAU::CVdpauRenderPicture*)buf.hwDec)->Sync();
+  }
+  return true;
+}
+
+bool CRendererVDPAU::CreateTexture(int index)
+{
+  if (m_format == RENDER_FMT_VDPAU)
+    return CreateVDPAUTexture(index);
+  else if (m_format == RENDER_FMT_VDPAU_420)
+    return CreateVDPAUTexture420(index);
+  else
+    return false;
+}
+
+void CRendererVDPAU::DeleteTexture(int index)
+{
+  if (m_format == RENDER_FMT_VDPAU)
+    DeleteVDPAUTexture(index);
+  else if (m_format == RENDER_FMT_VDPAU_420)
+    DeleteVDPAUTexture420(index);
+}
+
+bool CRendererVDPAU::UploadTexture(int index)
+{
+  if (m_format == RENDER_FMT_VDPAU)
+    return UploadVDPAUTexture(index);
+  else if (m_format == RENDER_FMT_VDPAU_420)
+    return UploadVDPAUTexture420(index);
+  else
+    return false;
+}
+
+bool CRendererVDPAU::CreateVDPAUTexture(int index)
+{
+  YV12Image &im     = m_buffers[index].image;
+  YUVFIELDS &fields = m_buffers[index].fields;
+  YUVPLANE  &plane  = fields[FIELD_FULL][0];
+
+  DeleteVDPAUTexture(index);
+
+  memset(&im    , 0, sizeof(im));
+  memset(&fields, 0, sizeof(fields));
+  im.height = m_sourceHeight;
+  im.width  = m_sourceWidth;
+
+  plane.texwidth  = im.width;
+  plane.texheight = im.height;
+
+  plane.pixpertex_x = 1;
+  plane.pixpertex_y = 1;
+
+  plane.id = 1;
+  return true;
+}
+
+void CRendererVDPAU::DeleteVDPAUTexture(int index)
+{
+  YUVPLANE &plane = m_buffers[index].fields[FIELD_FULL][0];
+
+  if (m_buffers[index].hwDec)
+    ((VDPAU::CVdpauRenderPicture*)m_buffers[index].hwDec)->Release();
+  m_buffers[index].hwDec = NULL;
+
+  plane.id = 0;
+}
+
+bool CRendererVDPAU::UploadVDPAUTexture(int index)
+{
+  VDPAU::CVdpauRenderPicture *vdpau = (VDPAU::CVdpauRenderPicture*)m_buffers[index].hwDec;
+
+  YUVFIELDS &fields = m_buffers[index].fields;
+  YUVPLANE &plane = fields[FIELD_FULL][0];
+
+  if (!vdpau || !vdpau->valid)
+  {
+    return false;
+  }
+
+  plane.id = vdpau->texture[0];
+
+  // in stereoscopic mode sourceRect may only
+  // be a part of the source video surface
+  plane.rect = m_sourceRect;
+
+  // clip rect
+  if (vdpau->crop.x1 > plane.rect.x1)
+    plane.rect.x1 = vdpau->crop.x1;
+  if (vdpau->crop.x2 < plane.rect.x2)
+    plane.rect.x2 = vdpau->crop.x2;
+  if (vdpau->crop.y1 > plane.rect.y1)
+    plane.rect.y1 = vdpau->crop.y1;
+  if (vdpau->crop.y2 < plane.rect.y2)
+    plane.rect.y2 = vdpau->crop.y2;
+
+  plane.texheight = vdpau->texHeight;
+  plane.texwidth  = vdpau->texWidth;
+
+  if (m_textureTarget == GL_TEXTURE_2D)
+  {
+    plane.rect.y1 /= plane.texheight;
+    plane.rect.y2 /= plane.texheight;
+    plane.rect.x1 /= plane.texwidth;
+    plane.rect.x2 /= plane.texwidth;
+  }
+
+  return true;
+}
+
+bool CRendererVDPAU::CreateVDPAUTexture420(int index)
+{
+  YV12Image &im     = m_buffers[index].image;
+  YUVFIELDS &fields = m_buffers[index].fields;
+  YUVPLANE &plane = fields[0][0];
+  GLuint    *pbo    = m_buffers[index].pbo;
+
+  DeleteVDPAUTexture420(index);
+
+  memset(&im    , 0, sizeof(im));
+  memset(&fields, 0, sizeof(fields));
+
+  im.cshift_x = 1;
+  im.cshift_y = 1;
+
+  im.plane[0] = NULL;
+  im.plane[1] = NULL;
+  im.plane[2] = NULL;
+
+  for(int p=0; p<3; p++)
+  {
+    pbo[p] = None;
+  }
+
+  plane.id = 1;
+
+  return true;
+}
+
+void CRendererVDPAU::DeleteVDPAUTexture420(int index)
+{
+  YUVFIELDS &fields = m_buffers[index].fields;
+
+  if (m_buffers[index].hwDec)
+    ((VDPAU::CVdpauRenderPicture*)m_buffers[index].hwDec)->Release();
+  m_buffers[index].hwDec = NULL;
+
+  fields[0][0].id = 0;
+  fields[1][0].id = 0;
+  fields[1][1].id = 0;
+  fields[2][0].id = 0;
+  fields[2][1].id = 0;
+}
+
+bool CRendererVDPAU::UploadVDPAUTexture420(int index)
+{
+  VDPAU::CVdpauRenderPicture *vdpau = (VDPAU::CVdpauRenderPicture*)m_buffers[index].hwDec;
+  YV12Image &im = m_buffers[index].image;
+
+  YUVFIELDS &fields = m_buffers[index].fields;
+
+  if (!vdpau || !vdpau->valid)
+  {
+    return false;
+  }
+
+  im.height = vdpau->texHeight;
+  im.width  = vdpau->texWidth;
+
+  // YUV
+  for (int f = FIELD_TOP; f<=FIELD_BOT ; f++)
+  {
+    YUVPLANES &planes = fields[f];
+
+    planes[0].texwidth  = im.width;
+    planes[0].texheight = im.height >> 1;
+
+    planes[1].texwidth  = planes[0].texwidth  >> im.cshift_x;
+    planes[1].texheight = planes[0].texheight >> im.cshift_y;
+    planes[2].texwidth  = planes[1].texwidth;
+    planes[2].texheight = planes[1].texheight;
+
+    for (int p = 0; p < 3; p++)
+    {
+      planes[p].pixpertex_x = 1;
+      planes[p].pixpertex_y = 1;
+    }
+  }
+  // crop
+//  m_sourceRect.x1 += vdpau->crop.x1;
+//  m_sourceRect.x2 -= vdpau->crop.x2;
+//  m_sourceRect.y1 += vdpau->crop.y1;
+//  m_sourceRect.y2 -= vdpau->crop.y2;
+
+  // set textures
+  fields[1][0].id = vdpau->texture[0];
+  fields[1][1].id = vdpau->texture[2];
+  fields[1][2].id = vdpau->texture[2];
+  fields[2][0].id = vdpau->texture[1];
+  fields[2][1].id = vdpau->texture[3];
+  fields[2][2].id = vdpau->texture[3];
+
+  glEnable(m_textureTarget);
+  for (int f = FIELD_TOP; f <= FIELD_BOT; f++)
+  {
+    for (int p=0; p<2; p++)
+    {
+      glBindTexture(m_textureTarget,fields[f][p].id);
+      glTexParameteri(m_textureTarget, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+      glTexParameteri(m_textureTarget, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+      glTexParameteri(m_textureTarget, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+      glTexParameteri(m_textureTarget, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+
+      glBindTexture(m_textureTarget,0);
+      VerifyGLState();
+    }
+  }
+  CalculateTextureSourceRects(index, 3);
+  glDisable(m_textureTarget);
+  return true;
+}
+
+#endif
diff --git a/xbmc/cores/VideoRenderers/HwDecRender/RendererVDPAU.h b/xbmc/cores/VideoRenderers/HwDecRender/RendererVDPAU.h
new file mode 100644
index 0000000..55ab570
--- /dev/null
+++ b/xbmc/cores/VideoRenderers/HwDecRender/RendererVDPAU.h
@@ -0,0 +1,64 @@
+/*
+ *      Copyright (C) 2007-2015 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#pragma once
+
+#include "system.h"
+
+#ifdef HAVE_LIBVDPAU
+
+#include "cores/VideoRenderers/LinuxRendererGL.h"
+
+class CRendererVDPAU : public CLinuxRendererGL
+{
+public:
+  CRendererVDPAU();
+  virtual ~CRendererVDPAU();
+
+  // Player functions
+  virtual void AddVideoPictureHW(DVDVideoPicture &picture, int index);
+  virtual void ReleaseBuffer(int idx);
+  virtual CRenderInfo GetRenderInfo();
+
+  // Feature support
+  virtual bool Supports(ERENDERFEATURE feature);
+  virtual bool Supports(EINTERLACEMETHOD method);
+  virtual bool Supports(ESCALINGMETHOD method);
+
+protected:
+  virtual bool LoadShadersHook();
+  virtual bool RenderHook(int idx);
+
+  // textures
+  virtual bool UploadTexture(int index);
+  virtual void DeleteTexture(int index);
+  virtual bool CreateTexture(int index);
+
+  bool CreateVDPAUTexture(int index);
+  void DeleteVDPAUTexture(int index);
+  bool UploadVDPAUTexture(int index);
+
+  bool CreateVDPAUTexture420(int index);
+  void DeleteVDPAUTexture420(int index);
+  bool UploadVDPAUTexture420(int index);
+};
+
+#endif
+
diff --git a/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp b/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
index f782224..ae7b8a6 100644
--- a/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
+++ b/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
@@ -54,20 +54,11 @@ extern "C" {
 #include "libswscale/swscale.h"
 }
 
-#ifdef HAVE_LIBVDPAU
-#include "cores/dvdplayer/DVDCodecs/Video/VDPAU.h"
-#endif
-#ifdef HAVE_LIBVA
-#include "cores/dvdplayer/DVDCodecs/Video/VAAPI.h"
-#endif
-
-#ifdef TARGET_DARWIN
-  #include "osx/CocoaInterface.h"
-  #include <CoreVideo/CoreVideo.h>
-  #include <OpenGL/CGLIOSurface.h>
-  #ifdef TARGET_DARWIN_OSX
-    #include "osx/DarwinUtils.h"
-  #endif
+#ifdef TARGET_DARWIN_OSX
+#include "osx/CocoaInterface.h"
+#include <CoreVideo/CoreVideo.h>
+#include <OpenGL/CGLIOSurface.h>
+#include "osx/DarwinUtils.h"
 #endif
 
 //due to a bug on osx nvidia, using gltexsubimage2d with a pbo bound and a null pointer
@@ -119,23 +110,12 @@ CLinuxRendererGL::YUVBUFFER::YUVBUFFER()
   memset(&image , 0, sizeof(image));
   memset(&pbo   , 0, sizeof(pbo));
   flipindex = 0;
-#ifdef HAVE_LIBVDPAU
-  vdpau = NULL;
-#endif
-#ifdef HAVE_LIBVA
-  vaapi = NULL;
-#endif
-#ifdef TARGET_DARWIN_OSX
-  cvBufferRef = NULL;
-#endif
+  hwDec = NULL;
 }
 
 CLinuxRendererGL::YUVBUFFER::~YUVBUFFER()
 {
-#ifdef TARGET_DARWIN_OSX
-  if (cvBufferRef)
-    CVBufferRelease(cvBufferRef);
-#endif
+
 }
 
 CLinuxRendererGL::CLinuxRendererGL()
@@ -156,11 +136,6 @@ CLinuxRendererGL::CLinuxRendererGL()
   m_scalingMethod = VS_SCALINGMETHOD_LINEAR;
   m_scalingMethodGui = (ESCALINGMETHOD)-1;
 
-  // default texture handlers to YUV
-  m_textureUpload = &CLinuxRendererGL::UploadYV12Texture;
-  m_textureCreate = &CLinuxRendererGL::CreateYV12Texture;
-  m_textureDelete = &CLinuxRendererGL::DeleteYV12Texture;
-
   m_rgbBuffer = NULL;
   m_rgbBufferSize = 0;
   m_context = NULL;
@@ -224,7 +199,7 @@ bool CLinuxRendererGL::ValidateRenderer()
     return false;
 
   int index = m_iYV12RenderBuffer;
-  YUVBUFFER& buf =  m_buffers[index];
+  YUVBUFFER& buf = m_buffers[index];
 
   if (!buf.fields[FIELD_FULL][0].id)
     return false;
@@ -239,20 +214,16 @@ bool CLinuxRendererGL::ValidateRenderTarget()
 {
   if (!m_bValidated)
   {
-    if ((m_format == RENDER_FMT_CVBREF) ||
-        (!glewIsSupported("GL_ARB_texture_non_power_of_two") && glewIsSupported("GL_ARB_texture_rectangle")))
+    if (!glewIsSupported("GL_ARB_texture_non_power_of_two") && glewIsSupported("GL_ARB_texture_rectangle"))
     {
-      CLog::Log(LOGNOTICE,"Using GL_TEXTURE_RECTANGLE_ARB");
       m_textureTarget = GL_TEXTURE_RECTANGLE_ARB;
     }
-    else
-      CLog::Log(LOGNOTICE,"Using GL_TEXTURE_2D");
 
     // function pointer for texture might change in
     // call to LoadShaders
     glFinish();
     for (int i = 0 ; i < NUM_BUFFERS ; i++)
-      (this->*m_textureDelete)(i);
+      DeleteTexture(i);
 
     // trigger update of video filters
     m_scalingMethodGui = (ESCALINGMETHOD)-1;
@@ -260,8 +231,13 @@ bool CLinuxRendererGL::ValidateRenderTarget()
      // create the yuv textures
     LoadShaders();
 
+    if (m_textureTarget == GL_TEXTURE_RECTANGLE_ARB)
+      CLog::Log(LOGNOTICE,"Using GL_TEXTURE_RECTANGLE_ARB");
+    else
+      CLog::Log(LOGNOTICE,"Using GL_TEXTURE_2D");
+
     for (int i = 0 ; i < m_NumYV12Buffers ; i++)
-      (this->*m_textureCreate)(i);
+      CreateTexture(i);
 
     m_bValidated = true;
     return true;
@@ -328,8 +304,11 @@ int CLinuxRendererGL::NextYV12Texture()
 
 int CLinuxRendererGL::GetImage(YV12Image *image, int source, bool readonly)
 {
-  if (!image) return -1;
-  if (!m_bValidated) return -1;
+  if (!image)
+    return -1;
+
+  if (!m_bValidated)
+    return -1;
 
   /* take next available buffer */
   if( source == AUTOSOURCE )
@@ -539,7 +518,7 @@ void CLinuxRendererGL::Flush()
   glFinish();
 
   for (int i = 0 ; i < m_NumYV12Buffers ; i++)
-    (this->*m_textureDelete)(i);
+    DeleteTexture(i);
 
   glFinish();
   m_bValidated = false;
@@ -547,24 +526,6 @@ void CLinuxRendererGL::Flush()
   m_iYV12RenderBuffer = 0;
 }
 
-void CLinuxRendererGL::ReleaseBuffer(int idx)
-{
-#if defined(HAVE_LIBVDPAU) || defined(HAVE_LIBVA) || defined(TARGET_DARWIN)
-  YUVBUFFER &buf = m_buffers[idx];
-#endif
-#ifdef HAVE_LIBVDPAU
-  SAFE_RELEASE(buf.vdpau);
-#endif
-#ifdef HAVE_LIBVA
-  SAFE_RELEASE(buf.vaapi);
-#endif
-#ifdef TARGET_DARWIN
-  if (buf.cvBufferRef)
-    CVBufferRelease(buf.cvBufferRef);
-  buf.cvBufferRef = NULL;
-#endif
-}
-
 void CLinuxRendererGL::Update()
 {
   if (!m_bConfigured) return;
@@ -713,7 +674,7 @@ void CLinuxRendererGL::FlipPage(int source)
   return;
 }
 
-unsigned int CLinuxRendererGL::PreInit()
+void CLinuxRendererGL::PreInit()
 {
   CSingleLock lock(g_graphicsContext);
   m_bConfigured = false;
@@ -755,14 +716,9 @@ unsigned int CLinuxRendererGL::PreInit()
   m_formats.push_back(RENDER_FMT_NV12);
   m_formats.push_back(RENDER_FMT_YUYV422);
   m_formats.push_back(RENDER_FMT_UYVY422);
-#ifdef TARGET_DARWIN
-  m_formats.push_back(RENDER_FMT_CVBREF);
-#endif
 
   // setup the background colour
   m_clearColour = (float)(g_advancedSettings.m_videoBlackBarColour & 0xff) / 0xff;
-
-  return true;
 }
 
 void CLinuxRendererGL::UpdateVideoFilter()
@@ -834,7 +790,7 @@ void CLinuxRendererGL::UpdateVideoFilter()
   case VS_SCALINGMETHOD_LINEAR:
     SetTextureFilter(m_scalingMethod == VS_SCALINGMETHOD_NEAREST ? GL_NEAREST : GL_LINEAR);
     m_renderQuality = RQ_SINGLEPASS;
-    if (((m_renderMethod & RENDER_VDPAU) || (m_renderMethod & RENDER_VAAPI)) && m_nonLinStretch)
+    if (Supports(RENDERFEATURE_NONLINSTRETCH) && m_nonLinStretch)
     {
       m_pVideoFilterShader = new StretchFilterShader();
       if (!m_pVideoFilterShader->CompileAndLink())
@@ -913,17 +869,7 @@ void CLinuxRendererGL::UpdateVideoFilter()
 
 void CLinuxRendererGL::LoadShaders(int field)
 {
-  if (m_format == RENDER_FMT_VDPAU)
-  {
-    CLog::Log(LOGNOTICE, "GL: Using VDPAU render method");
-    m_renderMethod = RENDER_VDPAU;
-  }
-  else if (m_format == RENDER_FMT_VAAPI)
-  {
-    CLog::Log(LOGNOTICE, "GL: Using VAAPI render method");
-    m_renderMethod = RENDER_VAAPI;
-  }
-  else
+  if (!LoadShadersHook())
   {
     int requestedMethod = CSettings::Get().GetInt("videoplayer.rendermethod");
     CLog::Log(LOGDEBUG, "GL: Requested render method: %d", requestedMethod);
@@ -1007,13 +953,6 @@ void CLinuxRendererGL::LoadShaders(int field)
     }
   }
 
-  /* cvbref format piggy back on normal glsl */
-  if (m_format == RENDER_FMT_CVBREF)
-  {
-    CLog::Log(LOGNOTICE, "GL: Using CVBREF render method");
-    m_renderMethod |= RENDER_CVREF;
-  }
-
   // determine whether GPU supports NPOT textures
   if (!glewIsSupported("GL_ARB_texture_non_power_of_two"))
   {
@@ -1039,57 +978,6 @@ void CLinuxRendererGL::LoadShaders(int field)
   }
   else
     m_pboUsed = false;
-
-  // Now that we now the render method, setup texture function handlers
-  if (m_format == RENDER_FMT_NV12 ||
-      m_format == RENDER_FMT_VAAPINV12)
-  {
-    m_textureUpload = &CLinuxRendererGL::UploadNV12Texture;
-    m_textureCreate = &CLinuxRendererGL::CreateNV12Texture;
-    m_textureDelete = &CLinuxRendererGL::DeleteNV12Texture;
-  }
-  else if (m_format == RENDER_FMT_YUYV422 ||
-           m_format == RENDER_FMT_UYVY422)
-  {
-    m_textureUpload = &CLinuxRendererGL::UploadYUV422PackedTexture;
-    m_textureCreate = &CLinuxRendererGL::CreateYUV422PackedTexture;
-    m_textureDelete = &CLinuxRendererGL::DeleteYUV422PackedTexture;
-  }
-  else if (m_format == RENDER_FMT_VDPAU)
-  {
-    m_textureUpload = &CLinuxRendererGL::UploadVDPAUTexture;
-    m_textureCreate = &CLinuxRendererGL::CreateVDPAUTexture;
-    m_textureDelete = &CLinuxRendererGL::DeleteVDPAUTexture;
-  }
-  else if (m_format == RENDER_FMT_VDPAU_420)
-  {
-    m_textureUpload = &CLinuxRendererGL::UploadVDPAUTexture420;
-    m_textureCreate = &CLinuxRendererGL::CreateVDPAUTexture420;
-    m_textureDelete = &CLinuxRendererGL::DeleteVDPAUTexture420;
-  }
-  else if (m_format == RENDER_FMT_VAAPI)
-  {
-    m_textureUpload = &CLinuxRendererGL::UploadVAAPITexture;
-    m_textureCreate = &CLinuxRendererGL::CreateVAAPITexture;
-    m_textureDelete = &CLinuxRendererGL::DeleteVAAPITexture;
-  }
-  else if (m_format == RENDER_FMT_CVBREF)
-  {
-    m_textureUpload = &CLinuxRendererGL::UploadCVRefTexture;
-    m_textureCreate = &CLinuxRendererGL::CreateCVRefTexture;
-    m_textureDelete = &CLinuxRendererGL::DeleteCVRefTexture;
-  }
-  else
-  {
-    // setup default YV12 texture handlers
-    m_textureUpload = &CLinuxRendererGL::UploadYV12Texture;
-    m_textureCreate = &CLinuxRendererGL::CreateYV12Texture;
-    m_textureDelete = &CLinuxRendererGL::DeleteYV12Texture;
-  }
-
-  //in case of software colorspace conversion, all formats are handled by the same method
-  if (m_renderMethod & RENDER_SW)
-    m_textureUpload = &CLinuxRendererGL::UploadRGBTexture;
 }
 
 void CLinuxRendererGL::UnInit()
@@ -1121,8 +1009,7 @@ void CLinuxRendererGL::UnInit()
   // YV12 textures
   for (int i = 0; i < NUM_BUFFERS; ++i)
   {
-    (this->*m_textureDelete)(i);
-    DeleteVAAPITexture(i);
+    DeleteTexture(i);
   }
 
   // cleanup framebuffer object if it was in use
@@ -1145,31 +1032,25 @@ void CLinuxRendererGL::Render(DWORD flags, int renderBuffer)
     m_currentField = FIELD_FULL;
 
   // call texture load function
-  if (!(this->*m_textureUpload)(renderBuffer))
+  if (!UploadTexture(renderBuffer))
     return;
 
-  if (m_renderMethod & RENDER_GLSL)
+  if (RenderHook(renderBuffer))
+    ;
+  else if (m_renderMethod & RENDER_GLSL)
   {
     UpdateVideoFilter();
     switch(m_renderQuality)
     {
     case RQ_LOW:
     case RQ_SINGLEPASS:
-      if (m_format == RENDER_FMT_VDPAU_420 && m_currentField == FIELD_FULL)
-        RenderProgressiveWeave(renderBuffer, m_currentField);
-      else
-        RenderSinglePass(renderBuffer, m_currentField);
+      RenderSinglePass(renderBuffer, m_currentField);
       VerifyGLState();
       break;
 
     case RQ_MULTIPASS:
-      if (m_format == RENDER_FMT_VDPAU_420 && m_currentField == FIELD_FULL)
-        RenderProgressiveWeave(renderBuffer, m_currentField);
-      else
-      {
-        RenderToFBO(renderBuffer, m_currentField);
-        RenderFromFBO();
-      }
+      RenderToFBO(renderBuffer, m_currentField);
+      RenderFromFBO();
       VerifyGLState();
       break;
     }
@@ -1178,46 +1059,11 @@ void CLinuxRendererGL::Render(DWORD flags, int renderBuffer)
   {
     RenderSinglePass(renderBuffer, m_currentField);
   }
-#ifdef HAVE_LIBVDPAU
-  else if (m_renderMethod & RENDER_VDPAU)
-  {
-    UpdateVideoFilter();
-    RenderRGB(renderBuffer, m_currentField);
-  }
-#endif
-#ifdef HAVE_LIBVA
-  else if (m_renderMethod & RENDER_VAAPI)
-  {
-    UpdateVideoFilter();
-    RenderRGB(renderBuffer, m_currentField);
-  }
-#endif
   else
   {
     RenderSoftware(renderBuffer, m_currentField);
     VerifyGLState();
   }
-
-#ifdef HAVE_LIBVDPAU
-  if (m_format == RENDER_FMT_VDPAU || m_format == RENDER_FMT_VDPAU_420)
-  {
-    YUVBUFFER &buf = m_buffers[renderBuffer];
-    if (buf.vdpau)
-    {
-      buf.vdpau->Sync();
-    }
-  }
-#endif
-#ifdef HAVE_LIBVA
-  if (m_format == RENDER_FMT_VAAPI)
-  {
-    YUVBUFFER &buf = m_buffers[renderBuffer];
-    if (buf.vaapi)
-    {
-      buf.vaapi->Sync();
-    }
-  }
-#endif
 }
 
 void CLinuxRendererGL::RenderSinglePass(int index, int field)
@@ -1557,7 +1403,6 @@ void CLinuxRendererGL::RenderProgressiveWeave(int index, int field)
 
 void CLinuxRendererGL::RenderRGB(int index, int field)
 {
-#if defined(HAVE_LIBVDPAU) || defined(HAVE_LIBVA)
   YUVPLANE &plane = m_buffers[index].fields[FIELD_FULL][0];
 
   glEnable(m_textureTarget);
@@ -1626,7 +1471,6 @@ void CLinuxRendererGL::RenderRGB(int index, int field)
 
   glBindTexture (m_textureTarget, 0);
   glDisable(m_textureTarget);
-#endif
 }
 
 void CLinuxRendererGL::RenderSoftware(int index, int field)
@@ -1705,132 +1549,6 @@ bool CLinuxRendererGL::RenderCapture(CRenderCapture* capture)
   return true;
 }
 
-//********************************************************************************************************
-// YV12 Texture creation, deletion, copying + clearing
-//********************************************************************************************************
-bool CLinuxRendererGL::UploadYV12Texture(int source)
-{
-  YUVBUFFER& buf    =  m_buffers[source];
-  YV12Image* im     = &buf.image;
-  YUVFIELDS& fields =  buf.fields;
-
-  if (!(im->flags&IMAGE_FLAG_READY))
-    return false;
-  bool deinterlacing;
-  if (m_currentField == FIELD_FULL)
-    deinterlacing = false;
-  else
-    deinterlacing = true;
-
-  glEnable(m_textureTarget);
-  VerifyGLState();
-
-  glPixelStorei(GL_UNPACK_ALIGNMENT,1);
-
-  if (deinterlacing)
-  {
-    // Load Even Y Field
-    LoadPlane( fields[FIELD_TOP][0] , GL_LUMINANCE, buf.flipindex
-             , im->width, im->height >> 1
-             , im->stride[0]*2, im->bpp, im->plane[0] );
-
-    //load Odd Y Field
-    LoadPlane( fields[FIELD_BOT][0], GL_LUMINANCE, buf.flipindex
-             , im->width, im->height >> 1
-             , im->stride[0]*2, im->bpp, im->plane[0] + im->stride[0]) ;
-
-    // Load Even U & V Fields
-    LoadPlane( fields[FIELD_TOP][1], GL_LUMINANCE, buf.flipindex
-             , im->width >> im->cshift_x, im->height >> (im->cshift_y + 1)
-             , im->stride[1]*2, im->bpp, im->plane[1] );
-
-    LoadPlane( fields[FIELD_TOP][2], GL_ALPHA, buf.flipindex
-             , im->width >> im->cshift_x, im->height >> (im->cshift_y + 1)
-             , im->stride[2]*2, im->bpp, im->plane[2] );
-
-    // Load Odd U & V Fields
-    LoadPlane( fields[FIELD_BOT][1], GL_LUMINANCE, buf.flipindex
-             , im->width >> im->cshift_x, im->height >> (im->cshift_y + 1)
-             , im->stride[1]*2, im->bpp, im->plane[1] + im->stride[1] );
-
-    LoadPlane( fields[FIELD_BOT][2], GL_ALPHA, buf.flipindex
-             , im->width >> im->cshift_x, im->height >> (im->cshift_y + 1)
-             , im->stride[2]*2, im->bpp, im->plane[2] + im->stride[2] );
-  }
-  else
-  {
-    //Load Y plane
-    LoadPlane( fields[FIELD_FULL][0], GL_LUMINANCE, buf.flipindex
-             , im->width, im->height
-             , im->stride[0], im->bpp, im->plane[0] );
-
-    //load U plane
-    LoadPlane( fields[FIELD_FULL][1], GL_LUMINANCE, buf.flipindex
-             , im->width >> im->cshift_x, im->height >> im->cshift_y
-             , im->stride[1], im->bpp, im->plane[1] );
-
-    //load V plane
-    LoadPlane( fields[FIELD_FULL][2], GL_ALPHA, buf.flipindex
-             , im->width >> im->cshift_x, im->height >> im->cshift_y
-             , im->stride[2], im->bpp, im->plane[2] );
-  }
-
-  VerifyGLState();
-
-  CalculateTextureSourceRects(source, 3);
-
-  glDisable(m_textureTarget);
-  return true;
-}
-
-void CLinuxRendererGL::DeleteYV12Texture(int index)
-{
-  YV12Image &im     = m_buffers[index].image;
-  YUVFIELDS &fields = m_buffers[index].fields;
-  GLuint    *pbo    = m_buffers[index].pbo;
-
-  if( fields[FIELD_FULL][0].id == 0 ) return;
-
-  /* finish up all textures, and delete them */
-  g_graphicsContext.BeginPaint();  //FIXME
-  for(int f = 0;f<MAX_FIELDS;f++)
-  {
-    for(int p = 0;p<MAX_PLANES;p++)
-    {
-      if( fields[f][p].id )
-      {
-        if (glIsTexture(fields[f][p].id))
-          glDeleteTextures(1, &fields[f][p].id);
-        fields[f][p].id = 0;
-      }
-    }
-  }
-  g_graphicsContext.EndPaint();
-
-  for(int p = 0;p<MAX_PLANES;p++)
-  {
-    if (pbo[p])
-    {
-      if (im.plane[p])
-      {
-        glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, pbo[p]);
-        glUnmapBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB);
-        im.plane[p] = NULL;
-        glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, 0);
-      }
-      glDeleteBuffersARB(1, pbo + p);
-      pbo[p] = 0;
-    }
-    else
-    {
-      if (im.plane[p])
-      {
-        delete[] im.plane[p];
-        im.plane[p] = NULL;
-      }
-    }
-  }
-}
 
 static GLint GetInternalFormat(GLint format, int bpp)
 {
@@ -1851,6 +1569,52 @@ static GLint GetInternalFormat(GLint format, int bpp)
     return format;
 }
 
+//-----------------------------------------------------------------------------
+// Textures
+//-----------------------------------------------------------------------------
+
+bool CLinuxRendererGL::CreateTexture(int index)
+{
+  if (m_format == RENDER_FMT_NV12)
+    return CreateNV12Texture(index);
+  else if (m_format == RENDER_FMT_YUYV422 ||
+           m_format == RENDER_FMT_UYVY422)
+    return CreateYUV422PackedTexture(index);
+  else
+    return CreateYV12Texture(index);
+}
+
+void CLinuxRendererGL::DeleteTexture(int index)
+{
+  if (m_format == RENDER_FMT_NV12)
+    DeleteNV12Texture(index);
+  else if (m_format == RENDER_FMT_YUYV422 ||
+           m_format == RENDER_FMT_UYVY422)
+    DeleteYUV422PackedTexture(index);
+  else
+    DeleteYV12Texture(index);
+}
+
+bool CLinuxRendererGL::UploadTexture(int index)
+{
+  if (m_format == RENDER_FMT_NV12)
+    return UploadNV12Texture(index);
+  else if (m_format == RENDER_FMT_YUYV422 ||
+           m_format == RENDER_FMT_UYVY422)
+    return UploadYUV422PackedTexture(index);
+  //in case of software colorspace conversion, all formats are handled by the same method
+  else if (m_renderMethod & RENDER_SW)
+    return UploadRGBTexture(index);
+  else
+    return UploadYV12Texture(index);
+
+  return false;
+}
+
+//********************************************************************************************************
+// YV12 Texture creation, deletion, copying + clearing
+//********************************************************************************************************
+
 bool CLinuxRendererGL::CreateYV12Texture(int index)
 {
   /* since we also want the field textures, pitch must be texture aligned */
@@ -2014,16 +1778,13 @@ bool CLinuxRendererGL::CreateYV12Texture(int index)
   return true;
 }
 
-//********************************************************************************************************
-// NV12 Texture loading, creation and deletion
-//********************************************************************************************************
-bool CLinuxRendererGL::UploadNV12Texture(int source)
+bool CLinuxRendererGL::UploadYV12Texture(int source)
 {
   YUVBUFFER& buf    =  m_buffers[source];
   YV12Image* im     = &buf.image;
   YUVFIELDS& fields =  buf.fields;
 
-  if (!(im->flags & IMAGE_FLAG_READY))
+  if (!(im->flags&IMAGE_FLAG_READY))
     return false;
   bool deinterlacing;
   if (m_currentField == FIELD_FULL)
@@ -2034,29 +1795,156 @@ bool CLinuxRendererGL::UploadNV12Texture(int source)
   glEnable(m_textureTarget);
   VerifyGLState();
 
-  glPixelStorei(GL_UNPACK_ALIGNMENT, im->bpp);
+  glPixelStorei(GL_UNPACK_ALIGNMENT,1);
 
   if (deinterlacing)
   {
-    // Load Odd Y field
+    // Load Even Y Field
     LoadPlane( fields[FIELD_TOP][0] , GL_LUMINANCE, buf.flipindex
              , im->width, im->height >> 1
              , im->stride[0]*2, im->bpp, im->plane[0] );
 
-    // Load Even Y field
+    //load Odd Y Field
     LoadPlane( fields[FIELD_BOT][0], GL_LUMINANCE, buf.flipindex
              , im->width, im->height >> 1
              , im->stride[0]*2, im->bpp, im->plane[0] + im->stride[0]) ;
 
-    // Load Odd UV Fields
-    LoadPlane( fields[FIELD_TOP][1], GL_LUMINANCE_ALPHA, buf.flipindex
+    // Load Even U & V Fields
+    LoadPlane( fields[FIELD_TOP][1], GL_LUMINANCE, buf.flipindex
              , im->width >> im->cshift_x, im->height >> (im->cshift_y + 1)
              , im->stride[1]*2, im->bpp, im->plane[1] );
 
-    // Load Even UV Fields
-    LoadPlane( fields[FIELD_BOT][1], GL_LUMINANCE_ALPHA, buf.flipindex
+    LoadPlane( fields[FIELD_TOP][2], GL_ALPHA, buf.flipindex
              , im->width >> im->cshift_x, im->height >> (im->cshift_y + 1)
-             , im->stride[1]*2, im->bpp, im->plane[1] + im->stride[1] );
+             , im->stride[2]*2, im->bpp, im->plane[2] );
+
+    // Load Odd U & V Fields
+    LoadPlane( fields[FIELD_BOT][1], GL_LUMINANCE, buf.flipindex
+             , im->width >> im->cshift_x, im->height >> (im->cshift_y + 1)
+             , im->stride[1]*2, im->bpp, im->plane[1] + im->stride[1] );
+
+    LoadPlane( fields[FIELD_BOT][2], GL_ALPHA, buf.flipindex
+             , im->width >> im->cshift_x, im->height >> (im->cshift_y + 1)
+             , im->stride[2]*2, im->bpp, im->plane[2] + im->stride[2] );
+  }
+  else
+  {
+    //Load Y plane
+    LoadPlane( fields[FIELD_FULL][0], GL_LUMINANCE, buf.flipindex
+             , im->width, im->height
+             , im->stride[0], im->bpp, im->plane[0] );
+
+    //load U plane
+    LoadPlane( fields[FIELD_FULL][1], GL_LUMINANCE, buf.flipindex
+             , im->width >> im->cshift_x, im->height >> im->cshift_y
+             , im->stride[1], im->bpp, im->plane[1] );
+
+    //load V plane
+    LoadPlane( fields[FIELD_FULL][2], GL_ALPHA, buf.flipindex
+             , im->width >> im->cshift_x, im->height >> im->cshift_y
+             , im->stride[2], im->bpp, im->plane[2] );
+  }
+
+  VerifyGLState();
+
+  CalculateTextureSourceRects(source, 3);
+
+  glDisable(m_textureTarget);
+  return true;
+}
+
+void CLinuxRendererGL::DeleteYV12Texture(int index)
+{
+  YV12Image &im     = m_buffers[index].image;
+  YUVFIELDS &fields = m_buffers[index].fields;
+  GLuint    *pbo    = m_buffers[index].pbo;
+
+  if( fields[FIELD_FULL][0].id == 0 ) return;
+
+  /* finish up all textures, and delete them */
+  g_graphicsContext.BeginPaint();  //FIXME
+  for(int f = 0;f<MAX_FIELDS;f++)
+  {
+    for(int p = 0;p<MAX_PLANES;p++)
+    {
+      if( fields[f][p].id )
+      {
+        if (glIsTexture(fields[f][p].id))
+          glDeleteTextures(1, &fields[f][p].id);
+        fields[f][p].id = 0;
+      }
+    }
+  }
+  g_graphicsContext.EndPaint();
+
+  for(int p = 0;p<MAX_PLANES;p++)
+  {
+    if (pbo[p])
+    {
+      if (im.plane[p])
+      {
+        glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, pbo[p]);
+        glUnmapBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB);
+        im.plane[p] = NULL;
+        glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, 0);
+      }
+      glDeleteBuffersARB(1, pbo + p);
+      pbo[p] = 0;
+    }
+    else
+    {
+      if (im.plane[p])
+      {
+        delete[] im.plane[p];
+        im.plane[p] = NULL;
+      }
+    }
+  }
+}
+
+//********************************************************************************************************
+// NV12 Texture loading, creation and deletion
+//********************************************************************************************************
+bool CLinuxRendererGL::UploadNV12Texture(int source)
+{
+  YUVBUFFER& buf    =  m_buffers[source];
+  YV12Image* im     = &buf.image;
+  YUVFIELDS& fields =  buf.fields;
+
+  if (!(im->flags & IMAGE_FLAG_READY))
+    return false;
+  bool deinterlacing;
+  if (m_currentField == FIELD_FULL)
+    deinterlacing = false;
+  else
+    deinterlacing = true;
+
+  glEnable(m_textureTarget);
+  VerifyGLState();
+
+  glPixelStorei(GL_UNPACK_ALIGNMENT, im->bpp);
+
+  if (deinterlacing)
+  {
+    // Load Odd Y field
+    LoadPlane( fields[FIELD_TOP][0] , GL_LUMINANCE, buf.flipindex
+             , im->width, im->height >> 1
+             , im->stride[0]*2, im->bpp, im->plane[0] );
+
+    // Load Even Y field
+    LoadPlane( fields[FIELD_BOT][0], GL_LUMINANCE, buf.flipindex
+             , im->width, im->height >> 1
+             , im->stride[0]*2, im->bpp, im->plane[0] + im->stride[0]) ;
+
+    // Load Odd UV Fields
+    LoadPlane( fields[FIELD_TOP][1], GL_LUMINANCE_ALPHA, buf.flipindex
+             , im->width >> im->cshift_x, im->height >> (im->cshift_y + 1)
+             , im->stride[1]*2, im->bpp, im->plane[1] );
+
+    // Load Even UV Fields
+    LoadPlane( fields[FIELD_BOT][1], GL_LUMINANCE_ALPHA, buf.flipindex
+             , im->width >> im->cshift_x, im->height >> (im->cshift_y + 1)
+             , im->stride[1]*2, im->bpp, im->plane[1] + im->stride[1] );
 
   }
   else
@@ -2291,384 +2179,6 @@ void CLinuxRendererGL::DeleteNV12Texture(int index)
   }
 }
 
-void CLinuxRendererGL::DeleteVDPAUTexture(int index)
-{
-#ifdef HAVE_LIBVDPAU
-  YUVPLANE &plane = m_buffers[index].fields[FIELD_FULL][0];
-
-  SAFE_RELEASE(m_buffers[index].vdpau);
-
-  plane.id = 0;
-#endif
-}
-
-bool CLinuxRendererGL::CreateVDPAUTexture(int index)
-{
-#ifdef HAVE_LIBVDPAU
-  YV12Image &im     = m_buffers[index].image;
-  YUVFIELDS &fields = m_buffers[index].fields;
-  YUVPLANE  &plane  = fields[FIELD_FULL][0];
-
-  DeleteVDPAUTexture(index);
-
-  memset(&im    , 0, sizeof(im));
-  memset(&fields, 0, sizeof(fields));
-  im.height = m_sourceHeight;
-  im.width  = m_sourceWidth;
-
-  plane.texwidth  = im.width;
-  plane.texheight = im.height;
-
-  plane.pixpertex_x = 1;
-  plane.pixpertex_y = 1;
-
-  plane.id = 1;
-
-#endif
-  return true;
-}
-
-bool CLinuxRendererGL::UploadVDPAUTexture(int index)
-{
-#ifdef HAVE_LIBVDPAU
-  VDPAU::CVdpauRenderPicture *vdpau = m_buffers[index].vdpau;
-
-  YUVFIELDS &fields = m_buffers[index].fields;
-  YUVPLANE &plane = fields[FIELD_FULL][0];
-
-  if (!vdpau || !vdpau->valid)
-  {
-    return false;
-  }
-
-  plane.id = vdpau->texture[0];
-
-  // in stereoscopic mode sourceRect may only
-  // be a part of the source video surface
-  plane.rect = m_sourceRect;
-
-  // clip rect
-  if (vdpau->crop.x1 > plane.rect.x1)
-    plane.rect.x1 = vdpau->crop.x1;
-  if (vdpau->crop.x2 < plane.rect.x2)
-    plane.rect.x2 = vdpau->crop.x2;
-  if (vdpau->crop.y1 > plane.rect.y1)
-    plane.rect.y1 = vdpau->crop.y1;
-  if (vdpau->crop.y2 < plane.rect.y2)
-    plane.rect.y2 = vdpau->crop.y2;
-
-  plane.texheight = vdpau->texHeight;
-  plane.texwidth  = vdpau->texWidth;
-
-  if (m_textureTarget == GL_TEXTURE_2D)
-  {
-    plane.rect.y1 /= plane.texheight;
-    plane.rect.y2 /= plane.texheight;
-    plane.rect.x1 /= plane.texwidth;
-    plane.rect.x2 /= plane.texwidth;
-  }
-
-#endif
-  return true;
-}
-
-void CLinuxRendererGL::DeleteVDPAUTexture420(int index)
-{
-#ifdef HAVE_LIBVDPAU
-  YUVFIELDS &fields = m_buffers[index].fields;
-
-  SAFE_RELEASE(m_buffers[index].vdpau);
-
-  fields[0][0].id = 0;
-  fields[1][0].id = 0;
-  fields[1][1].id = 0;
-  fields[2][0].id = 0;
-  fields[2][1].id = 0;
-
-#endif
-}
-
-bool CLinuxRendererGL::CreateVDPAUTexture420(int index)
-{
-#ifdef HAVE_LIBVDPAU
-  YV12Image &im     = m_buffers[index].image;
-  YUVFIELDS &fields = m_buffers[index].fields;
-  YUVPLANE &plane = fields[0][0];
-  GLuint    *pbo    = m_buffers[index].pbo;
-
-  DeleteVDPAUTexture420(index);
-
-  memset(&im    , 0, sizeof(im));
-  memset(&fields, 0, sizeof(fields));
-
-  im.cshift_x = 1;
-  im.cshift_y = 1;
-
-  im.plane[0] = NULL;
-  im.plane[1] = NULL;
-  im.plane[2] = NULL;
-
-  for(int p=0; p<3; p++)
-  {
-    pbo[p] = None;
-  }
-
-  plane.id = 1;
-
-#endif
-  return true;
-}
-
-bool CLinuxRendererGL::UploadVDPAUTexture420(int index)
-{
-#ifdef HAVE_LIBVDPAU
-  VDPAU::CVdpauRenderPicture *vdpau = m_buffers[index].vdpau;
-  YV12Image &im = m_buffers[index].image;
-
-  YUVFIELDS &fields = m_buffers[index].fields;
-
-  if (!vdpau || !vdpau->valid)
-  {
-    return false;
-  }
-
-  im.height = vdpau->texHeight;
-  im.width  = vdpau->texWidth;
-
-  // YUV
-  for (int f = FIELD_TOP; f<=FIELD_BOT ; f++)
-  {
-    YUVPLANES &planes = fields[f];
-
-    planes[0].texwidth  = im.width;
-    planes[0].texheight = im.height >> 1;
-
-    planes[1].texwidth  = planes[0].texwidth  >> im.cshift_x;
-    planes[1].texheight = planes[0].texheight >> im.cshift_y;
-    planes[2].texwidth  = planes[1].texwidth;
-    planes[2].texheight = planes[1].texheight;
-
-    for (int p = 0; p < 3; p++)
-    {
-      planes[p].pixpertex_x = 1;
-      planes[p].pixpertex_y = 1;
-    }
-  }
-  // crop
-//  m_sourceRect.x1 += vdpau->crop.x1;
-//  m_sourceRect.x2 -= vdpau->crop.x2;
-//  m_sourceRect.y1 += vdpau->crop.y1;
-//  m_sourceRect.y2 -= vdpau->crop.y2;
-
-  // set textures
-  fields[1][0].id = vdpau->texture[0];
-  fields[1][1].id = vdpau->texture[2];
-  fields[1][2].id = vdpau->texture[2];
-  fields[2][0].id = vdpau->texture[1];
-  fields[2][1].id = vdpau->texture[3];
-  fields[2][2].id = vdpau->texture[3];
-
-  glEnable(m_textureTarget);
-  for (int f = FIELD_TOP; f <= FIELD_BOT; f++)
-  {
-    for (int p=0; p<2; p++)
-    {
-      glBindTexture(m_textureTarget,fields[f][p].id);
-      glTexParameteri(m_textureTarget, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
-      glTexParameteri(m_textureTarget, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
-      glTexParameteri(m_textureTarget, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
-      glTexParameteri(m_textureTarget, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
-
-      glBindTexture(m_textureTarget,0);
-      VerifyGLState();
-    }
-  }
-  CalculateTextureSourceRects(index, 3);
-  glDisable(m_textureTarget);
-
-#endif
-  return true;
-}
-
-void CLinuxRendererGL::DeleteVAAPITexture(int index)
-{
-#ifdef HAVE_LIBVA
-  YUVPLANE &plane = m_buffers[index].fields[FIELD_FULL][0];
-  SAFE_RELEASE(m_buffers[index].vaapi);
-  plane.id = 0;
-#endif
-}
-
-bool CLinuxRendererGL::CreateVAAPITexture(int index)
-{
-#ifdef HAVE_LIBVA
-  YV12Image &im     = m_buffers[index].image;
-  YUVFIELDS &fields = m_buffers[index].fields;
-  YUVPLANE  &plane  = fields[0][0];
-
-  DeleteVAAPITexture(index);
-
-  memset(&im    , 0, sizeof(im));
-  memset(&fields, 0, sizeof(fields));
-  im.height = m_sourceHeight;
-  im.width  = m_sourceWidth;
-
-  plane.texwidth  = im.width;
-  plane.texheight = im.height;
-
-  plane.pixpertex_x = 1;
-  plane.pixpertex_y = 1;
-
-  plane.id = 1;
-
-#endif
-  return true;
-}
-
-bool CLinuxRendererGL::UploadVAAPITexture(int index)
-{
-#ifdef HAVE_LIBVA
-  VAAPI::CVaapiRenderPicture *vaapi = m_buffers[index].vaapi;
-
-  YUVFIELDS &fields = m_buffers[index].fields;
-  YUVPLANE &plane = fields[FIELD_FULL][0];
-
-  if (!vaapi || !vaapi->valid)
-  {
-    return false;
-  }
-
-  if (!vaapi->CopyGlx())
-    return false;
-
-  plane.id = vaapi->texture;
-
-  // in stereoscopic mode sourceRect may only
-  // be a part of the source video surface
-  plane.rect = m_sourceRect;
-
-  // clip rect
-  if (vaapi->crop.x1 > plane.rect.x1)
-    plane.rect.x1 = vaapi->crop.x1;
-  if (vaapi->crop.x2 < plane.rect.x2)
-    plane.rect.x2 = vaapi->crop.x2;
-  if (vaapi->crop.y1 > plane.rect.y1)
-    plane.rect.y1 = vaapi->crop.y1;
-  if (vaapi->crop.y2 < plane.rect.y2)
-    plane.rect.y2 = vaapi->crop.y2;
-
-  plane.texheight = vaapi->texHeight;
-  plane.texwidth  = vaapi->texWidth;
-
-  if (m_textureTarget == GL_TEXTURE_2D)
-  {
-    plane.rect.y1 /= plane.texheight;
-    plane.rect.y2 /= plane.texheight;
-    plane.rect.x1 /= plane.texwidth;
-    plane.rect.x2 /= plane.texwidth;
-  }
-
-#endif
-  return true;
-}
-
-//********************************************************************************************************
-// CoreVideoRef Texture creation, deletion, copying + clearing
-//********************************************************************************************************
-bool CLinuxRendererGL::UploadCVRefTexture(int index)
-{
-#ifdef TARGET_DARWIN
-  YUVBUFFER &buf    = m_buffers[index];
-  YUVFIELDS &fields = buf.fields;
-
-  CVBufferRef cvBufferRef = m_buffers[index].cvBufferRef;
-
-  glEnable(m_textureTarget);
-
-  if (cvBufferRef && fields[m_currentField][0].flipindex != buf.flipindex)
-  {
-
-    // It is the fastest way to render a CVPixelBuffer backed
-    // with an IOSurface as there is no CPU -> GPU upload.
-    CGLContextObj cgl_ctx  = (CGLContextObj)g_Windowing.GetCGLContextObj();
-    IOSurfaceRef	surface  = CVPixelBufferGetIOSurface(cvBufferRef);
-    GLsizei       texWidth = IOSurfaceGetWidth(surface);
-    GLsizei       texHeight= IOSurfaceGetHeight(surface);
-    OSType        format_type = IOSurfaceGetPixelFormat(surface);
-
-    glBindTexture(m_textureTarget, fields[FIELD_FULL][0].id);
-
-    if (format_type == kCVPixelFormatType_422YpCbCr8)
-      CGLTexImageIOSurface2D(cgl_ctx, m_textureTarget, GL_RGBA8,
-        texWidth / 2, texHeight, GL_BGRA, GL_UNSIGNED_INT_8_8_8_8_REV, surface, 0);
-    else if (format_type == kCVPixelFormatType_32BGRA)
-      CGLTexImageIOSurface2D(cgl_ctx, m_textureTarget, GL_RGBA8,
-        texWidth, texHeight, GL_BGRA, GL_UNSIGNED_INT_8_8_8_8_REV, surface, 0);
-
-    glBindTexture(m_textureTarget, 0);
-    fields[FIELD_FULL][0].flipindex = buf.flipindex;
-
-  }
-
-
-  CalculateTextureSourceRects(index, 3);
-  glDisable(m_textureTarget);
-
-#endif
-  return true;
-}
-
-void CLinuxRendererGL::DeleteCVRefTexture(int index)
-{
-#ifdef TARGET_DARWIN
-  YUVPLANE  &plane = m_buffers[index].fields[0][0];
-
-  if (m_buffers[index].cvBufferRef)
-    CVBufferRelease(m_buffers[index].cvBufferRef);
-  m_buffers[index].cvBufferRef = NULL;
-
-  if (plane.id && glIsTexture(plane.id))
-    glDeleteTextures(1, &plane.id), plane.id = 0;
-#endif
-}
-
-bool CLinuxRendererGL::CreateCVRefTexture(int index)
-{
-#ifdef TARGET_DARWIN
-  YV12Image &im     = m_buffers[index].image;
-  YUVFIELDS &fields = m_buffers[index].fields;
-  YUVPLANE  &plane  = fields[0][0];
-
-  DeleteCVRefTexture(index);
-
-  memset(&im    , 0, sizeof(im));
-  memset(&fields, 0, sizeof(fields));
-
-  im.bpp    = 1;
-  im.width  = m_sourceWidth;
-  im.height = m_sourceHeight;
-  im.cshift_x = 0;
-  im.cshift_y = 0;
-
-  plane.pixpertex_x = 2;
-  plane.pixpertex_y = 1;
-  plane.texwidth    = im.width  / plane.pixpertex_x;
-  plane.texheight   = im.height / plane.pixpertex_y;
-
-  if(m_renderMethod & RENDER_POT)
-  {
-    plane.texwidth  = NP2(plane.texwidth);
-    plane.texheight = NP2(plane.texheight);
-  }
-
-  glEnable(m_textureTarget);
-  glGenTextures(1, &plane.id);
-  glDisable(m_textureTarget);
-
-#endif
-  return true;
-}
-
 bool CLinuxRendererGL::UploadYUV422PackedTexture(int source)
 {
   YUVBUFFER& buf    =  m_buffers[source];
@@ -3240,12 +2750,6 @@ bool CLinuxRendererGL::Supports(ERENDERFEATURE feature)
 {
   if(feature == RENDERFEATURE_BRIGHTNESS)
   {
-    if ((m_renderMethod & RENDER_VDPAU) && !CSettings::Get().GetBool("videoscreen.limitedrange"))
-      return true;
-
-    if (m_renderMethod & RENDER_VAAPI)
-      return false;
-
     return (m_renderMethod & RENDER_GLSL)
         || (m_renderMethod & RENDER_ARB)
         || ((m_renderMethod & RENDER_SW) && glewIsSupported("GL_ARB_imaging") == GL_TRUE);
@@ -3253,12 +2757,6 @@ bool CLinuxRendererGL::Supports(ERENDERFEATURE feature)
   
   if(feature == RENDERFEATURE_CONTRAST)
   {
-    if ((m_renderMethod & RENDER_VDPAU) && !CSettings::Get().GetBool("videoscreen.limitedrange"))
-      return true;
-
-    if (m_renderMethod & RENDER_VAAPI)
-      return false;
-
     return (m_renderMethod & RENDER_GLSL)
         || (m_renderMethod & RENDER_ARB)
         || ((m_renderMethod & RENDER_SW) && glewIsSupported("GL_ARB_imaging") == GL_TRUE);
@@ -3268,21 +2766,16 @@ bool CLinuxRendererGL::Supports(ERENDERFEATURE feature)
     return false;
   
   if(feature == RENDERFEATURE_NOISE)
-  {
-    if(m_renderMethod & RENDER_VDPAU)
-      return true;
-  }
+    return false;
 
   if(feature == RENDERFEATURE_SHARPNESS)
   {
-    if(m_renderMethod & RENDER_VDPAU)
-      return true;
+    return false;
   }
 
   if (feature == RENDERFEATURE_NONLINSTRETCH)
   {
-    if (((m_renderMethod & RENDER_GLSL) && !(m_renderMethod & RENDER_POT)) ||
-        (m_renderMethod & RENDER_VDPAU) || (m_renderMethod & RENDER_VAAPI))
+    if ((m_renderMethod & RENDER_GLSL) && !(m_renderMethod & RENDER_POT))
       return true;
   }
 
@@ -3322,35 +2815,6 @@ bool CLinuxRendererGL::Supports(EINTERLACEMETHOD method)
 
   if(method == VS_INTERLACEMETHOD_AUTO)
     return true;
-
-  if(m_renderMethod & RENDER_VDPAU ||
-      m_format == RENDER_FMT_VDPAU_420)
-  {
-#ifdef HAVE_LIBVDPAU
-    VDPAU::CVdpauRenderPicture *vdpauPic = m_buffers[m_iYV12RenderBuffer].vdpau;
-    if(vdpauPic && vdpauPic->vdpau)
-      return vdpauPic->vdpau->Supports(method);
-#endif
-    return false;
-  }
-
-  if(m_format == RENDER_FMT_VAAPI ||
-      m_format == RENDER_FMT_VAAPINV12)
-  {
-#ifdef HAVE_LIBVA
-    VAAPI::CVaapiRenderPicture *vaapiPic = m_buffers[m_iYV12RenderBuffer].vaapi;
-    if(vaapiPic && vaapiPic->vaapi)
-      return vaapiPic->vaapi->Supports(method);
-#endif
-    return false;
-  }
-
-#ifdef TARGET_DARWIN_IOS
-  // iOS has not the power for YADIF - TODO evaluate if its
-  // enough to disable it for TARGET_DARWIN_IOS_ATV2
-  if(method == VS_INTERLACEMETHOD_DEINTERLACE)
-    return false;
-#endif
   
   if(method == VS_INTERLACEMETHOD_DEINTERLACE
   || method == VS_INTERLACEMETHOD_DEINTERLACE_HALF
@@ -3393,8 +2857,7 @@ bool CLinuxRendererGL::Supports(ESCALINGMETHOD method)
     if (scaleX < minScale && scaleY < minScale)
       return false;
 
-    if ((glewIsSupported("GL_EXT_framebuffer_object") && (m_renderMethod & RENDER_GLSL)) ||
-        (m_renderMethod & RENDER_VDPAU) || (m_renderMethod & RENDER_VAAPI))
+    if (glewIsSupported("GL_EXT_framebuffer_object") && (m_renderMethod & RENDER_GLSL))
     {
       // spline36 and lanczos3 are only allowed through advancedsettings.xml
       if(method != VS_SCALINGMETHOD_SPLINE36
@@ -3410,12 +2873,6 @@ bool CLinuxRendererGL::Supports(ESCALINGMETHOD method)
 
 EINTERLACEMETHOD CLinuxRendererGL::AutoInterlaceMethod()
 {
-  if(m_renderMethod & RENDER_CVREF)
-    return VS_INTERLACEMETHOD_NONE;
-
-  if(m_renderMethod & RENDER_VDPAU)
-    return VS_INTERLACEMETHOD_NONE;
-
   if(Supports(VS_INTERLACEMETHOD_RENDER_BOB))
     return VS_INTERLACEMETHOD_RENDER_BOB;
 
@@ -3461,54 +2918,8 @@ CRenderInfo CLinuxRendererGL::GetRenderInfo()
   CRenderInfo info;
   info.formats = m_formats;
   info.max_buffer_size = NUM_BUFFERS;
-  if(m_format == RENDER_FMT_CVBREF)
-    info.optimal_buffer_size = 2;
-  else if (m_format == RENDER_FMT_VAAPI ||
-           m_format == RENDER_FMT_VAAPINV12 ||
-           m_format == RENDER_FMT_VDPAU ||
-           m_format == RENDER_FMT_VDPAU_420)
-    info.optimal_buffer_size = 5;
-  else
-    info.optimal_buffer_size = 3;
+  info.optimal_buffer_size = 3;
   return info;
 }
 
-void CLinuxRendererGL::AddVideoPictureHW(DVDVideoPicture &picture, int index)
-{
-  if (picture.format == RENDER_FMT_VDPAU ||
-      picture.format == RENDER_FMT_VDPAU_420)
-  {
-#ifdef HAVE_LIBVDPAU
-    VDPAU::CVdpauRenderPicture *vdpau = picture.vdpau;
-    YUVBUFFER &buf = m_buffers[index];
-    VDPAU::CVdpauRenderPicture *pic = vdpau->Acquire();
-    SAFE_RELEASE(buf.vdpau);
-    buf.vdpau = pic;
-#endif
-  }
-  else if (picture.format == RENDER_FMT_VAAPI ||
-           picture.format == RENDER_FMT_VAAPINV12)
-  {
-#ifdef HAVE_LIBVA
-    VAAPI::CVaapiRenderPicture *vaapi = picture.vaapi;
-    YUVBUFFER &buf = m_buffers[index];
-    VAAPI::CVaapiRenderPicture *pic = vaapi->Acquire();
-    SAFE_RELEASE(buf.vaapi);
-    buf.vaapi = pic;
-#endif
-  }
-  else if (picture.format == RENDER_FMT_CVBREF)
-  {
-#ifdef TARGET_DARWIN
-    struct __CVBuffer *cvBufferRef = picture.cvBufferRef;
-    YUVBUFFER &buf = m_buffers[index];
-    if (buf.cvBufferRef)
-       CVBufferRelease(buf.cvBufferRef);
-    buf.cvBufferRef = cvBufferRef;
-    // retain another reference, this way dvdplayer and renderer can issue releases.
-    CVBufferRetain(buf.cvBufferRef);
-#endif
-  }
-}
-
 #endif
diff --git a/xbmc/cores/VideoRenderers/LinuxRendererGL.h b/xbmc/cores/VideoRenderers/LinuxRendererGL.h
index 2ae7ad6..249b82d 100644
--- a/xbmc/cores/VideoRenderers/LinuxRendererGL.h
+++ b/xbmc/cores/VideoRenderers/LinuxRendererGL.h
@@ -40,8 +40,6 @@ class CRenderCapture;
 class CBaseTexture;
 namespace Shaders { class BaseYUV2RGBShader; }
 namespace Shaders { class BaseVideoFilterShader; }
-namespace VAAPI   { class CVaapiRenderPicture; }
-namespace VDPAU   { class CVdpauRenderPicture; }
 
 #undef ALIGN
 #define ALIGN(value, alignment) (((value)+((alignment)-1))&~((alignment)-1))
@@ -122,13 +120,11 @@ public:
   virtual bool IsConfigured() { return m_bConfigured; }
   virtual int GetImage(YV12Image *image, int source = AUTOSOURCE, bool readonly = false);
   virtual void ReleaseImage(int source, bool preserve = false);
-  virtual void AddVideoPictureHW(DVDVideoPicture &picture, int index);
   virtual void FlipPage(int source);
-  virtual unsigned int PreInit();
+  virtual void PreInit();
   virtual void UnInit();
   virtual void Reset(); /* resets renderer after seek for example */
   virtual void Flush();
-  virtual void ReleaseBuffer(int idx);
   virtual void SetBufferSize(int numBuffers) { m_NumYV12Buffers = numBuffers; }
   virtual void RenderUpdate(bool clear, DWORD flags = 0, DWORD alpha = 255);
   virtual void Update();
@@ -146,8 +142,8 @@ public:
 
 protected:
   virtual void Render(DWORD flags, int renderBuffer);
-  void         ClearBackBuffer();
-  void         DrawBlackBars();
+  void ClearBackBuffer();
+  void DrawBlackBars();
 
   bool ValidateRenderer();
   int  NextYV12Texture();
@@ -157,9 +153,9 @@ protected:
   void UpdateVideoFilter();
 
   // textures
-  bool (CLinuxRendererGL::*m_textureUpload)(int index);
-  void (CLinuxRendererGL::*m_textureDelete)(int index);
-  bool (CLinuxRendererGL::*m_textureCreate)(int index);
+  virtual bool UploadTexture(int index);
+  virtual void DeleteTexture(int index);
+  virtual bool CreateTexture(int index);
 
   bool UploadYV12Texture(int index);
   void DeleteYV12Texture(int index);
@@ -168,22 +164,6 @@ protected:
   bool UploadNV12Texture(int index);
   void DeleteNV12Texture(int index);
   bool CreateNV12Texture(int index);
-  
-  bool UploadVDPAUTexture(int index);
-  void DeleteVDPAUTexture(int index);
-  bool CreateVDPAUTexture(int index);
-
-  bool UploadVDPAUTexture420(int index);
-  void DeleteVDPAUTexture420(int index);
-  bool CreateVDPAUTexture420(int index);
-
-  bool UploadVAAPITexture(int index);
-  void DeleteVAAPITexture(int index);
-  bool CreateVAAPITexture(int index);
-
-  bool UploadCVRefTexture(int index);
-  void DeleteCVRefTexture(int index);
-  bool CreateCVRefTexture(int index);
 
   bool UploadYUV422PackedTexture(int index);
   void DeleteYUV422PackedTexture(int index);
@@ -204,6 +184,10 @@ protected:
   void RenderRGB(int renderBuffer, int field);      // render using vdpau/vaapi hardware
   void RenderProgressiveWeave(int renderBuffer, int field); // render using vdpau hardware
 
+  // hooks for HwDec Renderered
+  virtual bool LoadShadersHook() { return false; };
+  virtual bool RenderHook(int idx) { return false; };
+
   struct
   {
     CFrameBufferObject fbo;
@@ -260,15 +244,7 @@ protected:
     unsigned  flipindex; /* used to decide if this has been uploaded */
     GLuint    pbo[MAX_PLANES];
 
-#ifdef HAVE_LIBVDPAU
-    VDPAU::CVdpauRenderPicture *vdpau;
-#endif
-#ifdef HAVE_LIBVA
-    VAAPI::CVaapiRenderPicture *vaapi;
-#endif
-#ifdef TARGET_DARWIN_OSX
-    struct __CVBuffer *cvBufferRef;
-#endif
+    void *hwDec;
   };
 
   typedef YUVBUFFER          YUVBUFFERS[NUM_BUFFERS];
diff --git a/xbmc/cores/VideoRenderers/MMALRenderer.cpp b/xbmc/cores/VideoRenderers/MMALRenderer.cpp
deleted file mode 100644
index 9f1f803..0000000
--- a/xbmc/cores/VideoRenderers/MMALRenderer.cpp
+++ /dev/null
@@ -1,722 +0,0 @@
-/*
- *      Copyright (C) 2005-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-
-#include "Util.h"
-#include "MMALRenderer.h"
-#include "cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h"
-#include "filesystem/File.h"
-#include "settings/AdvancedSettings.h"
-#include "settings/DisplaySettings.h"
-#include "settings/MediaSettings.h"
-#include "settings/Settings.h"
-#include "threads/SingleLock.h"
-#include "utils/log.h"
-#include "utils/MathUtils.h"
-#include "windowing/WindowingFactory.h"
-#include "cores/dvdplayer/DVDCodecs/Video/MMALCodec.h"
-#include "xbmc/Application.h"
-
-#define CLASSNAME "CMMALRenderer"
-
-#ifdef _DEBUG
-#define MMAL_DEBUG_VERBOSE
-#endif
-
-CRenderInfo CMMALRenderer::GetRenderInfo()
-{
-  CSingleLock lock(m_sharedSection);
-  CRenderInfo info;
-
-  // we'll assume that video is accelerated (RENDER_FMT_MMAL) for now
-  // we will reconfigure renderer later if necessary
-  if (!m_bMMALConfigured)
-    m_bMMALConfigured = init_vout(RENDER_FMT_MMAL);
-
-  #if defined(MMAL_DEBUG_VERBOSE)
-  CLog::Log(LOGDEBUG, "%s::%s cookie:%p", CLASSNAME, __func__, (void *)m_vout_input_pool);
-  #endif
-
-  info.max_buffer_size = NUM_BUFFERS;
-  info.optimal_buffer_size = NUM_BUFFERS;
-  info.opaque_pointer = (void *)m_vout_input_pool;
-  info.formats = m_formats;
-  return info;
-}
-
-static void vout_control_port_cb(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)
-{
-  mmal_buffer_header_release(buffer);
-}
-
-void CMMALRenderer::vout_input_port_cb(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)
-{
-  #if defined(MMAL_DEBUG_VERBOSE)
-  CMMALVideoBuffer *omvb = (CMMALVideoBuffer *)buffer->user_data;
-  CLog::Log(LOGDEBUG, "%s::%s port:%p buffer %p (%p), len %d cmd:%x f:%x", CLASSNAME, __func__, port, buffer, omvb, buffer->length, buffer->cmd, buffer->flags);
-  #endif
-
-  assert(!(buffer->flags & MMAL_BUFFER_HEADER_FLAG_TRANSMISSION_FAILED));
-  buffer->flags &= ~MMAL_BUFFER_HEADER_FLAG_USER2;
-  if (m_format == RENDER_FMT_MMAL)
-  {
-    CMMALVideoBuffer *omvb = (CMMALVideoBuffer *)buffer->user_data;
-    omvb->Release();
-  }
-  else if (m_format == RENDER_FMT_YUV420P)
-  {
-    mmal_buffer_header_release(buffer);
-  }
-  else assert(0);
-}
-
-static void vout_input_port_cb_static(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)
-{
-  CMMALRenderer *mmal = reinterpret_cast<CMMALRenderer*>(port->userdata);
-  mmal->vout_input_port_cb(port, buffer);
-}
-
-bool CMMALRenderer::init_vout(ERenderFormat format)
-{
-  CSingleLock lock(m_sharedSection);
-  bool formatChanged = m_format != format;
-  MMAL_STATUS_T status;
-
-  CLog::Log(LOGDEBUG, "%s::%s configured:%d format:%d->%d", CLASSNAME, __func__, m_bConfigured, m_format, format);
-
-  if (m_bMMALConfigured && formatChanged)
-    UnInitMMAL();
-
-  if (m_bMMALConfigured)
-    return true;
-
-  m_format = format;
-  if (m_format != RENDER_FMT_MMAL && m_format != RENDER_FMT_YUV420P)
-    return true;
-
-  /* Create video renderer */
-  status = mmal_component_create(MMAL_COMPONENT_DEFAULT_VIDEO_RENDERER, &m_vout);
-  if(status != MMAL_SUCCESS)
-  {
-    CLog::Log(LOGERROR, "%s::%s Failed to create vout component (status=%x %s)", CLASSNAME, __func__, status, mmal_status_to_string(status));
-    return false;
-  }
-
-  m_vout->control->userdata = (struct MMAL_PORT_USERDATA_T *)this;
-  status = mmal_port_enable(m_vout->control, vout_control_port_cb);
-  if(status != MMAL_SUCCESS)
-  {
-    CLog::Log(LOGERROR, "%s::%s Failed to enable vout control port (status=%x %s)", CLASSNAME, __func__, status, mmal_status_to_string(status));
-    return false;
-  }
-  m_vout_input = m_vout->input[0];
-  m_vout_input->userdata = (struct MMAL_PORT_USERDATA_T *)this;
-  MMAL_ES_FORMAT_T *es_format = m_vout_input->format;
-
-  es_format->type = MMAL_ES_TYPE_VIDEO;
-  es_format->es->video.crop.width = m_sourceWidth;
-  es_format->es->video.crop.height = m_sourceHeight;
-
-  if (m_format == RENDER_FMT_MMAL)
-  {
-    es_format->encoding = MMAL_ENCODING_OPAQUE;
-    es_format->es->video.width = m_sourceWidth;
-    es_format->es->video.height = m_sourceHeight;
-  }
-  else if (m_format == RENDER_FMT_YUV420P)
-  {
-    const int pitch = ALIGN_UP(m_sourceWidth, 32);
-    const int aligned_height = ALIGN_UP(m_sourceHeight, 16);
-
-    es_format->encoding = MMAL_ENCODING_I420;
-    es_format->es->video.width = pitch;
-    es_format->es->video.height = aligned_height;
-
-    if (CONF_FLAGS_YUVCOEF_MASK(m_iFlags) == CONF_FLAGS_YUVCOEF_BT709)
-      es_format->es->video.color_space = MMAL_COLOR_SPACE_ITUR_BT709;
-    else if (CONF_FLAGS_YUVCOEF_MASK(m_iFlags) == CONF_FLAGS_YUVCOEF_BT601)
-      es_format->es->video.color_space = MMAL_COLOR_SPACE_ITUR_BT601;
-    else if (CONF_FLAGS_YUVCOEF_MASK(m_iFlags) == CONF_FLAGS_YUVCOEF_240M)
-      es_format->es->video.color_space = MMAL_COLOR_SPACE_SMPTE240M;
-  }
-
-  if (m_format == RENDER_FMT_MMAL)
-  {
-    status = mmal_port_parameter_set_boolean(m_vout_input, MMAL_PARAMETER_ZERO_COPY,  MMAL_TRUE);
-    if (status != MMAL_SUCCESS)
-       CLog::Log(LOGERROR, "%s::%s Failed to enable zero copy mode on %s (status=%x %s)", CLASSNAME, __func__, m_vout_input->name, status, mmal_status_to_string(status));
-  }
-  status = mmal_port_format_commit(m_vout_input);
-  if (status != MMAL_SUCCESS)
-  {
-    CLog::Log(LOGERROR, "%s::%s Failed to commit vout input format (status=%x %s)", CLASSNAME, __func__, status, mmal_status_to_string(status));
-    return false;
-  }
-
-  m_vout_input->buffer_num = std::max(m_vout_input->buffer_num_recommended, (uint32_t)m_NumYV12Buffers);
-  m_vout_input->buffer_size = m_vout_input->buffer_size_recommended;
-
-  status = mmal_port_enable(m_vout_input, vout_input_port_cb_static);
-  if(status != MMAL_SUCCESS)
-  {
-    CLog::Log(LOGERROR, "%s::%s Failed to vout enable input port (status=%x %s)", CLASSNAME, __func__, status, mmal_status_to_string(status));
-    return false;
-  }
-
-  status = mmal_component_enable(m_vout);
-  if(status != MMAL_SUCCESS)
-  {
-    CLog::Log(LOGERROR, "%s::%s Failed to enable vout component (status=%x %s)", CLASSNAME, __func__, status, mmal_status_to_string(status));
-    return false;
-  }
-
-  m_vout_input_pool = mmal_port_pool_create(m_vout_input , m_vout_input->buffer_num, m_vout_input->buffer_size);
-  if (!m_vout_input_pool)
-  {
-    CLog::Log(LOGERROR, "%s::%s Failed to create pool for decoder input port (status=%x %s)", CLASSNAME, __func__, status, mmal_status_to_string(status));
-    return false;
-  }
-  return true;
-}
-
-CMMALRenderer::CMMALRenderer()
-{
-  CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
-  m_vout = NULL;
-  m_vout_input = NULL;
-  m_vout_input_pool = NULL;
-  memset(m_buffers, 0, sizeof m_buffers);
-  m_iFlags = 0;
-  m_format = RENDER_FMT_NONE;
-  m_bConfigured = false;
-  m_bMMALConfigured = false;
-  m_iYV12RenderBuffer = 0;
-}
-
-CMMALRenderer::~CMMALRenderer()
-{
-  CSingleLock lock(m_sharedSection);
-  CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
-  UnInit();
-}
-
-void CMMALRenderer::AddProcessor(CMMALVideoBuffer *buffer, int index)
-{
-#if defined(MMAL_DEBUG_VERBOSE)
-  CLog::Log(LOGDEBUG, "%s::%s - %p (%p) %i", CLASSNAME, __func__, buffer, buffer->mmal_buffer, index);
-#endif
-
-  YUVBUFFER &buf = m_buffers[index];
-  assert(!buf.MMALBuffer);
-  memset(&buf, 0, sizeof buf);
-  buf.MMALBuffer = buffer->Acquire();
-}
-
-bool CMMALRenderer::Configure(unsigned int width, unsigned int height, unsigned int d_width, unsigned int d_height, float fps, unsigned flags, ERenderFormat format, unsigned extended_format, unsigned int orientation)
-{
-  CSingleLock lock(m_sharedSection);
-  ReleaseBuffers();
-
-  m_sourceWidth  = width;
-  m_sourceHeight = height;
-  m_renderOrientation = orientation;
-
-  m_fps = fps;
-  m_iFlags = flags;
-
-  CLog::Log(LOGDEBUG, "%s::%s - %dx%d->%dx%d@%.2f flags:%x format:%d ext:%x orient:%d", CLASSNAME, __func__, width, height, d_width, d_height, fps, flags, format, extended_format, orientation);
-
-  m_RenderUpdateCallBackFn = NULL;
-  m_RenderUpdateCallBackCtx = NULL;
-
-  // calculate the input frame aspect ratio
-  CalculateFrameAspectRatio(d_width, d_height);
-  ChooseBestResolution(fps);
-  m_destWidth = g_graphicsContext.GetResInfo(m_resolution).iWidth;
-  m_destHeight = g_graphicsContext.GetResInfo(m_resolution).iHeight;
-  SetViewMode(CMediaSettings::Get().GetCurrentVideoSettings().m_ViewMode);
-  ManageDisplay();
-
-  m_bMMALConfigured = init_vout(format);
-  m_bConfigured = m_bMMALConfigured;
-  assert(m_bConfigured);
-  return m_bConfigured;
-}
-
-int CMMALRenderer::GetImage(YV12Image *image, int source, bool readonly)
-{
-#if defined(MMAL_DEBUG_VERBOSE)
-  CLog::Log(LOGDEBUG, "%s::%s - %p %d %d", CLASSNAME, __func__, image, source, readonly);
-#endif
-  if (!image) return -1;
-
-  if( source < 0)
-    return -1;
-
-  if (m_format == RENDER_FMT_MMAL)
-  {
-  }
-  else if (m_format == RENDER_FMT_YUV420P)
-  {
-    const int pitch = ALIGN_UP(m_sourceWidth, 32);
-    const int aligned_height = ALIGN_UP(m_sourceHeight, 16);
-
-    MMAL_BUFFER_HEADER_T *buffer = mmal_queue_timedwait(m_vout_input_pool->queue, 500);
-    if (!buffer)
-    {
-      CLog::Log(LOGERROR, "%s::%s - mmal_queue_get failed", CLASSNAME, __func__);
-      return -1;
-    }
-
-    mmal_buffer_header_reset(buffer);
-
-    buffer->length = 3 * pitch * aligned_height >> 1;
-    assert(buffer->length <= buffer->alloc_size);
-
-    image->width    = m_sourceWidth;
-    image->height   = m_sourceHeight;
-    image->flags    = 0;
-    image->cshift_x = 1;
-    image->cshift_y = 1;
-    image->bpp      = 1;
-
-    image->stride[0] = pitch;
-    image->stride[1] = image->stride[2] = pitch>>image->cshift_x;
-
-    image->planesize[0] = pitch * aligned_height;
-    image->planesize[1] = image->planesize[2] = (pitch>>image->cshift_x)*(aligned_height>>image->cshift_y);
-
-    image->plane[0] = (uint8_t *)buffer->data;
-    image->plane[1] = image->plane[0] + image->planesize[0];
-    image->plane[2] = image->plane[1] + image->planesize[1];
-
-    CLog::Log(LOGDEBUG, "%s::%s - %p %d", CLASSNAME, __func__, buffer, source);
-    YUVBUFFER &buf = m_buffers[source];
-    memset(&buf, 0, sizeof buf);
-    buf.mmal_buffer = buffer;
-  }
-  else assert(0);
-
-  return source;
-}
-
-void CMMALRenderer::ReleaseBuffer(int idx)
-{
-  CSingleLock lock(m_sharedSection);
-  if (!m_bMMALConfigured || m_format == RENDER_FMT_BYPASS)
-    return;
-
-#if defined(MMAL_DEBUG_VERBOSE)
-  CLog::Log(LOGDEBUG, "%s::%s - %d (%p)", CLASSNAME, __func__, idx, m_buffers[idx].MMALBuffer);
-#endif
-  YUVBUFFER &buf = m_buffers[idx];
-  SAFE_RELEASE(buf.MMALBuffer);
-}
-
-void CMMALRenderer::ReleaseImage(int source, bool preserve)
-{
-#if defined(MMAL_DEBUG_VERBOSE)
-  CLog::Log(LOGDEBUG, "%s::%s - %d %d (%p)", CLASSNAME, __func__, source, preserve, m_buffers[source].MMALBuffer);
-#endif
-}
-
-void CMMALRenderer::Reset()
-{
-  CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
-}
-
-void CMMALRenderer::Flush()
-{
-  m_iYV12RenderBuffer = 0;
-  CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
-}
-
-void CMMALRenderer::Update()
-{
-#if defined(MMAL_DEBUG_VERBOSE)
-  CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
-#endif
-  if (!m_bConfigured) return;
-  ManageDisplay();
-}
-
-void CMMALRenderer::RenderUpdate(bool clear, DWORD flags, DWORD alpha)
-{
-  CSingleLock lock(m_sharedSection);
-  int source = m_iYV12RenderBuffer;
-#if defined(MMAL_DEBUG_VERBOSE)
-  CLog::Log(LOGDEBUG, "%s::%s - %d %x %d %d", CLASSNAME, __func__, clear, flags, alpha, source);
-#endif
-
-  if (!m_bConfigured) return;
-
-  if (g_graphicsContext.GetStereoMode())
-    g_graphicsContext.SetStereoView(RENDER_STEREO_VIEW_LEFT);
-  ManageDisplay();
-  if (g_graphicsContext.GetStereoMode())
-    g_graphicsContext.SetStereoView(RENDER_STEREO_VIEW_OFF);
-
-  // if running bypass, then the player might need the src/dst rects
-  // for sizing video playback on a layer other than the gles layer.
-  if (m_RenderUpdateCallBackFn)
-    (*m_RenderUpdateCallBackFn)(m_RenderUpdateCallBackCtx, m_sourceRect, m_destRect);
-
-  if (m_format == RENDER_FMT_BYPASS)
-    return;
-
-  SetVideoRect(m_sourceRect, m_destRect);
-
-  YUVBUFFER *buffer = &m_buffers[source];
-  if (m_format == RENDER_FMT_MMAL)
-  {
-    CMMALVideoBuffer *omvb = buffer->MMALBuffer;
-    if (omvb)
-    {
-#if defined(MMAL_DEBUG_VERBOSE)
-      CLog::Log(LOGDEBUG, "%s::%s %p (%p) f:%x", CLASSNAME, __func__, omvb, omvb->mmal_buffer, omvb->mmal_buffer->flags);
-#endif
-      // we only want to upload frames once
-      if (omvb->mmal_buffer->flags & MMAL_BUFFER_HEADER_FLAG_USER1)
-        return;
-      omvb->Acquire();
-      omvb->mmal_buffer->flags |= MMAL_BUFFER_HEADER_FLAG_USER1 | MMAL_BUFFER_HEADER_FLAG_USER2;
-      mmal_port_send_buffer(m_vout_input, omvb->mmal_buffer);
-    }
-    else
-      CLog::Log(LOGDEBUG, "%s::%s - No buffer to update", CLASSNAME, __func__);
-  }
-  else if (m_format == RENDER_FMT_YUV420P)
-  {
-    if (buffer->mmal_buffer)
-    {
-      CLog::Log(LOGDEBUG, "%s::%s - %p %d f:%x", CLASSNAME, __func__, buffer->mmal_buffer, source, buffer->mmal_buffer->flags);
-      // we only want to upload frames once
-      if (buffer->mmal_buffer->flags & MMAL_BUFFER_HEADER_FLAG_USER1)
-        return;
-      // sanity check it is not on display
-      buffer->mmal_buffer->flags |= MMAL_BUFFER_HEADER_FLAG_USER1 | MMAL_BUFFER_HEADER_FLAG_USER2;
-      mmal_port_send_buffer(m_vout_input, buffer->mmal_buffer);
-    }
-    else
-      CLog::Log(LOGDEBUG, "%s::%s - No buffer to update", CLASSNAME, __func__);
-  }
-  else assert(0);
-}
-
-void CMMALRenderer::FlipPage(int source)
-{
-  CSingleLock lock(m_sharedSection);
-  if (!m_bConfigured || m_format == RENDER_FMT_BYPASS)
-    return;
-
-#if defined(MMAL_DEBUG_VERBOSE)
-  CLog::Log(LOGDEBUG, "%s::%s - %d", CLASSNAME, __func__, source);
-#endif
-
-  m_iYV12RenderBuffer = source;
-}
-
-unsigned int CMMALRenderer::PreInit()
-{
-  CSingleLock lock(m_sharedSection);
-  m_bConfigured = false;
-  UnInit();
-
-  m_iFlags = 0;
-
-  m_resolution = CDisplaySettings::Get().GetCurrentResolution();
-  if ( m_resolution == RES_WINDOW )
-    m_resolution = RES_DESKTOP;
-
-  CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
-
-  m_formats.clear();
-  m_formats.push_back(RENDER_FMT_YUV420P);
-  m_formats.push_back(RENDER_FMT_MMAL);
-  m_formats.push_back(RENDER_FMT_BYPASS);
-
-  memset(m_buffers, 0, sizeof m_buffers);
-  m_iYV12RenderBuffer = 0;
-  m_NumYV12Buffers = NUM_BUFFERS;
-
-  return 0;
-}
-
-void CMMALRenderer::ReleaseBuffers()
-{
-  for (int i=0; i<NUM_BUFFERS; i++)
-    ReleaseBuffer(i);
-}
-
-void CMMALRenderer::UnInitMMAL()
-{
-  CSingleLock lock(m_sharedSection);
-  CLog::Log(LOGDEBUG, "%s::%s pool(%p)", CLASSNAME, __func__, m_vout_input_pool);
-  if (m_vout)
-  {
-    mmal_component_disable(m_vout);
-    mmal_port_disable(m_vout->control);
-  }
-
-  if (m_vout_input)
-  {
-    mmal_port_flush(m_vout_input);
-    mmal_port_disable(m_vout_input);
-    m_vout_input = NULL;
-  }
-
-  ReleaseBuffers();
-
-  if (m_vout_input_pool)
-  {
-    mmal_pool_destroy(m_vout_input_pool);
-    m_vout_input_pool = NULL;
-  }
-
-  if (m_vout)
-  {
-    mmal_component_release(m_vout);
-    m_vout = NULL;
-  }
-
-  m_RenderUpdateCallBackFn = NULL;
-  m_RenderUpdateCallBackCtx = NULL;
-
-  m_src_rect.SetRect(0, 0, 0, 0);
-  m_dst_rect.SetRect(0, 0, 0, 0);
-  m_video_stereo_mode = RENDER_STEREO_MODE_OFF;
-  m_display_stereo_mode = RENDER_STEREO_MODE_OFF;
-  m_StereoInvert = false;
-  m_format = RENDER_FMT_NONE;
-
-  m_bConfigured = false;
-  m_bMMALConfigured = false;
-}
-
-void CMMALRenderer::UnInit()
-{
-  UnInitMMAL();
-}
-
-bool CMMALRenderer::RenderCapture(CRenderCapture* capture)
-{
-  if (!m_bConfigured)
-    return false;
-
-  CLog::Log(LOGDEBUG, "%s::%s - %p", CLASSNAME, __func__, capture);
-
-  capture->BeginRender();
-  capture->EndRender();
-
-  return true;
-}
-
-//********************************************************************************************************
-// YV12 Texture creation, deletion, copying + clearing
-//********************************************************************************************************
-
-bool CMMALRenderer::Supports(EDEINTERLACEMODE mode)
-{
-  if(mode == VS_DEINTERLACEMODE_OFF
-  || mode == VS_DEINTERLACEMODE_AUTO
-  || mode == VS_DEINTERLACEMODE_FORCE)
-    return true;
-
-  return false;
-}
-
-bool CMMALRenderer::Supports(EINTERLACEMETHOD method)
-{
-  if (method == VS_INTERLACEMETHOD_AUTO)
-    return true;
-  if (method == VS_INTERLACEMETHOD_MMAL_ADVANCED)
-    return true;
-  if (method == VS_INTERLACEMETHOD_MMAL_ADVANCED_HALF)
-    return true;
-  if (method == VS_INTERLACEMETHOD_MMAL_BOB)
-    return true;
-  if (method == VS_INTERLACEMETHOD_MMAL_BOB_HALF)
-    return true;
-
-  return false;
-}
-
-bool CMMALRenderer::Supports(ERENDERFEATURE feature)
-{
-  if (feature == RENDERFEATURE_STRETCH         ||
-      feature == RENDERFEATURE_ZOOM            ||
-      feature == RENDERFEATURE_ROTATION        ||
-      feature == RENDERFEATURE_VERTICAL_SHIFT  ||
-      feature == RENDERFEATURE_PIXEL_RATIO)
-    return true;
-
-  return false;
-}
-
-bool CMMALRenderer::Supports(ESCALINGMETHOD method)
-{
-  return false;
-}
-
-EINTERLACEMETHOD CMMALRenderer::AutoInterlaceMethod()
-{
-  return VS_INTERLACEMETHOD_MMAL_ADVANCED;
-}
-
-void CMMALRenderer::SetVideoRect(const CRect& InSrcRect, const CRect& InDestRect)
-{
-  // we get called twice a frame for left/right. Can ignore the rights.
-  if (g_graphicsContext.GetStereoView() == RENDER_STEREO_VIEW_RIGHT)
-    return;
-  CSingleLock lock(m_sharedSection);
-
-  if (!m_vout_input)
-    return;
-
-  CRect SrcRect = InSrcRect, DestRect = InDestRect;
-  RENDER_STEREO_MODE video_stereo_mode = (m_iFlags & CONF_FLAGS_STEREO_MODE_SBS) ? RENDER_STEREO_MODE_SPLIT_VERTICAL :
-                                         (m_iFlags & CONF_FLAGS_STEREO_MODE_TAB) ? RENDER_STEREO_MODE_SPLIT_HORIZONTAL : RENDER_STEREO_MODE_OFF;
-  bool stereo_invert                   = (m_iFlags & CONF_FLAGS_STEREO_CADANCE_RIGHT_LEFT) ? true : false;
-  RENDER_STEREO_MODE display_stereo_mode = g_graphicsContext.GetStereoMode();
-
-  // fix up transposed video
-  if (m_renderOrientation == 90 || m_renderOrientation == 270)
-  {
-    float diff = (DestRect.Height() - DestRect.Width()) * 0.5f;
-    DestRect.x1 -= diff;
-    DestRect.x2 += diff;
-    DestRect.y1 += diff;
-    DestRect.y2 -= diff;
-  }
-
-  // check if destination rect or video view mode has changed
-  if (!(m_dst_rect != DestRect) && !(m_src_rect != SrcRect) && m_video_stereo_mode == video_stereo_mode && m_display_stereo_mode == display_stereo_mode && m_StereoInvert == stereo_invert)
-    return;
-
-  CLog::Log(LOGDEBUG, "%s::%s %d,%d,%d,%d -> %d,%d,%d,%d (o:%d v:%d d:%d i:%d)", CLASSNAME, __func__,
-      (int)SrcRect.x1, (int)SrcRect.y1, (int)SrcRect.x2, (int)SrcRect.y2,
-      (int)DestRect.x1, (int)DestRect.y1, (int)DestRect.x2, (int)DestRect.y2,
-      m_renderOrientation, video_stereo_mode, display_stereo_mode, stereo_invert);
-
-  m_src_rect = SrcRect;
-  m_dst_rect = DestRect;
-  m_video_stereo_mode = video_stereo_mode;
-  m_display_stereo_mode = display_stereo_mode;
-  m_StereoInvert = stereo_invert;
-
-  // might need to scale up m_dst_rect to display size as video decodes
-  // to separate video plane that is at display size.
-  RESOLUTION res = g_graphicsContext.GetVideoResolution();
-  CRect gui(0, 0, CDisplaySettings::Get().GetResolutionInfo(res).iWidth, CDisplaySettings::Get().GetResolutionInfo(res).iHeight);
-  CRect display(0, 0, CDisplaySettings::Get().GetResolutionInfo(res).iScreenWidth, CDisplaySettings::Get().GetResolutionInfo(res).iScreenHeight);
-
-  if (display_stereo_mode != RENDER_STEREO_MODE_OFF && display_stereo_mode != RENDER_STEREO_MODE_MONO)
-  switch (video_stereo_mode)
-  {
-  case RENDER_STEREO_MODE_SPLIT_VERTICAL:
-    // optimisation - use simpler display mode in common case of unscaled 3d with same display mode
-    if (video_stereo_mode == display_stereo_mode && DestRect.x1 == 0.0f && DestRect.x2 * 2.0f == gui.Width() && !stereo_invert)
-    {
-      SrcRect.x2 *= 2.0f;
-      DestRect.x2 *= 2.0f;
-      video_stereo_mode = RENDER_STEREO_MODE_OFF;
-      display_stereo_mode = RENDER_STEREO_MODE_OFF;
-    }
-    else if (display_stereo_mode == RENDER_STEREO_MODE_ANAGLYPH_RED_CYAN || display_stereo_mode == RENDER_STEREO_MODE_ANAGLYPH_GREEN_MAGENTA || display_stereo_mode == RENDER_STEREO_MODE_ANAGLYPH_YELLOW_BLUE)
-    {
-      SrcRect.x2 *= 2.0f;
-    }
-    break;
-
-  case RENDER_STEREO_MODE_SPLIT_HORIZONTAL:
-    // optimisation - use simpler display mode in common case of unscaled 3d with same display mode
-    if (video_stereo_mode == display_stereo_mode && DestRect.y1 == 0.0f && DestRect.y2 * 2.0f == gui.Height() && !stereo_invert)
-    {
-      SrcRect.y2 *= 2.0f;
-      DestRect.y2 *= 2.0f;
-      video_stereo_mode = RENDER_STEREO_MODE_OFF;
-      display_stereo_mode = RENDER_STEREO_MODE_OFF;
-    }
-    else if (display_stereo_mode == RENDER_STEREO_MODE_ANAGLYPH_RED_CYAN || display_stereo_mode == RENDER_STEREO_MODE_ANAGLYPH_GREEN_MAGENTA || display_stereo_mode == RENDER_STEREO_MODE_ANAGLYPH_YELLOW_BLUE)
-    {
-      SrcRect.y2 *= 2.0f;
-    }
-    break;
-
-  default: break;
-  }
-
-  if (gui != display)
-  {
-    float xscale = display.Width()  / gui.Width();
-    float yscale = display.Height() / gui.Height();
-    DestRect.x1 *= xscale;
-    DestRect.x2 *= xscale;
-    DestRect.y1 *= yscale;
-    DestRect.y2 *= yscale;
-  }
-
-  MMAL_DISPLAYREGION_T region;
-  memset(&region, 0, sizeof region);
-
-  region.set                 = MMAL_DISPLAY_SET_DEST_RECT|MMAL_DISPLAY_SET_SRC_RECT|MMAL_DISPLAY_SET_FULLSCREEN|MMAL_DISPLAY_SET_NOASPECT|MMAL_DISPLAY_SET_MODE;
-  region.dest_rect.x         = lrintf(DestRect.x1);
-  region.dest_rect.y         = lrintf(DestRect.y1);
-  region.dest_rect.width     = lrintf(DestRect.Width());
-  region.dest_rect.height    = lrintf(DestRect.Height());
-
-  region.src_rect.x          = lrintf(SrcRect.x1);
-  region.src_rect.y          = lrintf(SrcRect.y1);
-  region.src_rect.width      = lrintf(SrcRect.Width());
-  region.src_rect.height     = lrintf(SrcRect.Height());
-
-  region.fullscreen = MMAL_FALSE;
-  region.noaspect = MMAL_TRUE;
-
-  if (m_renderOrientation)
-  {
-    region.set |= MMAL_DISPLAY_SET_TRANSFORM;
-    if (m_renderOrientation == 90)
-      region.transform = MMAL_DISPLAY_ROT90;
-    else if (m_renderOrientation == 180)
-      region.transform = MMAL_DISPLAY_ROT180;
-    else if (m_renderOrientation == 270)
-      region.transform = MMAL_DISPLAY_ROT270;
-    else assert(0);
-  }
-
-  if (video_stereo_mode == RENDER_STEREO_MODE_SPLIT_HORIZONTAL && display_stereo_mode == RENDER_STEREO_MODE_SPLIT_HORIZONTAL)
-    region.mode = MMAL_DISPLAY_MODE_STEREO_TOP_TO_TOP;
-  else if (video_stereo_mode == RENDER_STEREO_MODE_SPLIT_HORIZONTAL && display_stereo_mode == RENDER_STEREO_MODE_SPLIT_VERTICAL)
-    region.mode = MMAL_DISPLAY_MODE_STEREO_TOP_TO_LEFT;
-  else if (video_stereo_mode == RENDER_STEREO_MODE_SPLIT_VERTICAL && display_stereo_mode == RENDER_STEREO_MODE_SPLIT_HORIZONTAL)
-    region.mode = MMAL_DISPLAY_MODE_STEREO_LEFT_TO_TOP;
-  else if (video_stereo_mode == RENDER_STEREO_MODE_SPLIT_VERTICAL && display_stereo_mode == RENDER_STEREO_MODE_SPLIT_VERTICAL)
-    region.mode = MMAL_DISPLAY_MODE_STEREO_LEFT_TO_LEFT;
-  else
-    region.mode = MMAL_DISPLAY_MODE_LETTERBOX;
-
-  MMAL_STATUS_T status = mmal_util_set_display_region(m_vout_input, &region);
-  if (status != MMAL_SUCCESS)
-    CLog::Log(LOGERROR, "%s::%s Failed to set display region (status=%x %s)", CLASSNAME, __func__, status, mmal_status_to_string(status));
-
-  CLog::Log(LOGDEBUG, "%s::%s %d,%d,%d,%d -> %d,%d,%d,%d mode:%d", CLASSNAME, __func__,
-      region.src_rect.x, region.src_rect.y, region.src_rect.width, region.src_rect.height,
-      region.dest_rect.x, region.dest_rect.y, region.dest_rect.width, region.dest_rect.height, region.mode);
-}
diff --git a/xbmc/cores/VideoRenderers/MMALRenderer.h b/xbmc/cores/VideoRenderers/MMALRenderer.h
deleted file mode 100644
index 1404fb3..0000000
--- a/xbmc/cores/VideoRenderers/MMALRenderer.h
+++ /dev/null
@@ -1,117 +0,0 @@
-#pragma once
-
-/*
- *      Copyright (C) 2005-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-
-#include "guilib/GraphicContext.h"
-#include "RenderFlags.h"
-#include "RenderFormats.h"
-#include "BaseRenderer.h"
-#include "RenderCapture.h"
-#include "settings/VideoSettings.h"
-#include "cores/dvdplayer/DVDStreamInfo.h"
-#include "guilib/Geometry.h"
-#include "BaseRenderer.h"
-
-#include <interface/mmal/mmal.h>
-#include <interface/mmal/util/mmal_util.h>
-#include <interface/mmal/util/mmal_default_components.h>
-#include <interface/mmal/util/mmal_util_params.h>
-
-#define AUTOSOURCE -1
-
-class CBaseTexture;
-class CMMALVideoBuffer;
-
-struct DVDVideoPicture;
-
-class CMMALRenderer : public CBaseRenderer
-{
-  struct YUVBUFFER
-  {
-    CMMALVideoBuffer *MMALBuffer; // used for hw decoded buffers
-    MMAL_BUFFER_HEADER_T *mmal_buffer;  // used for sw decoded buffers
-  };
-public:
-  CMMALRenderer();
-  ~CMMALRenderer();
-
-  virtual void Update();
-  virtual void SetupScreenshot() {};
-
-  bool RenderCapture(CRenderCapture* capture);
-
-  // Player functions
-  virtual bool         Configure(unsigned int width, unsigned int height, unsigned int d_width, unsigned int d_height, float fps, unsigned flags, ERenderFormat format, unsigned extended_format, unsigned int orientation);
-  virtual int          GetImage(YV12Image *image, int source = AUTOSOURCE, bool readonly = false);
-  virtual void         ReleaseImage(int source, bool preserve = false);
-  virtual void         ReleaseBuffer(int idx);
-  virtual void         FlipPage(int source);
-  virtual unsigned int PreInit();
-  virtual void         UnInit();
-  virtual void         Reset(); /* resets renderer after seek for example */
-  virtual void         Flush();
-  virtual bool         IsConfigured() { return m_bConfigured; }
-  virtual void         AddProcessor(CMMALVideoBuffer *buffer, int index);
-  virtual CRenderInfo GetRenderInfo();
-
-  virtual bool         Supports(ERENDERFEATURE feature);
-  virtual bool         Supports(EDEINTERLACEMODE mode);
-  virtual bool         Supports(EINTERLACEMETHOD method);
-  virtual bool         Supports(ESCALINGMETHOD method);
-
-  virtual EINTERLACEMETHOD AutoInterlaceMethod();
-
-  void                 RenderUpdate(bool clear, DWORD flags = 0, DWORD alpha = 255);
-
-  virtual void         SetBufferSize(int numBuffers) { m_NumYV12Buffers = numBuffers; }
-  virtual void SetVideoRect(const CRect& SrcRect, const CRect& DestRect);
-  virtual bool         IsGuiLayer() { return false; }
-
-  void vout_input_port_cb(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer);
-protected:
-  int m_iYV12RenderBuffer;
-  int m_NumYV12Buffers;
-
-  std::vector<ERenderFormat> m_formats;
-
-  YUVBUFFER            m_buffers[NUM_BUFFERS];
-  bool                 m_bConfigured;
-  bool                 m_bMMALConfigured;
-  unsigned int         m_extended_format;
-  unsigned int         m_destWidth;
-  unsigned int         m_destHeight;
-  int                  m_neededBuffers;
-
-  CRect                     m_src_rect;
-  CRect                     m_dst_rect;
-  RENDER_STEREO_MODE        m_video_stereo_mode;
-  RENDER_STEREO_MODE        m_display_stereo_mode;
-  bool                      m_StereoInvert;
-
-  CCriticalSection m_sharedSection;
-  MMAL_COMPONENT_T *m_vout;
-  MMAL_PORT_T *m_vout_input;
-  MMAL_POOL_T *m_vout_input_pool;
-
-  bool init_vout(ERenderFormat format);
-  void ReleaseBuffers();
-  void UnInitMMAL();
-};
diff --git a/xbmc/cores/VideoRenderers/Makefile.in b/xbmc/cores/VideoRenderers/Makefile.in
index 7fcc322..d964285 100644
--- a/xbmc/cores/VideoRenderers/Makefile.in
+++ b/xbmc/cores/VideoRenderers/Makefile.in
@@ -20,10 +20,6 @@ SRCS += LinuxRendererGLES.cpp
 SRCS += OverlayRendererGL.cpp
 endif
 
-ifeq (@USE_MMAL@,1)
-SRCS += MMALRenderer.cpp
-endif
-
 LIB = VideoRenderer.a
 
 include @abs_top_srcdir@/Makefile.include
diff --git a/xbmc/cores/VideoRenderers/RenderManager.cpp b/xbmc/cores/VideoRenderers/RenderManager.cpp
index dfd7a87..098556d 100644
--- a/xbmc/cores/VideoRenderers/RenderManager.cpp
+++ b/xbmc/cores/VideoRenderers/RenderManager.cpp
@@ -19,9 +19,6 @@
  */
 
 #include "system.h"
-#if defined(HAS_GL)
-  #include "system_gl.h"
-#endif
 #include "RenderManager.h"
 #include "RenderFlags.h"
 #include "threads/CriticalSection.h"
@@ -40,7 +37,12 @@
 #include "cores/DataCacheCore.h"
 
 #if defined(HAS_GL)
-  #include "LinuxRendererGL.h"
+#include "LinuxRendererGL.h"
+#include "HwDecRender/RendererVAAPI.h"
+#include "HwDecRender/RendererVDPAU.h"
+#if defined(TARGET_DARWIN_OSX)
+#include "HwDecRender/RendererVDA.h"
+#endif
 #elif defined(HAS_MMAL)
   #include "MMALRenderer.h"
 #elif HAS_GLES == 2
@@ -58,10 +60,6 @@
 #include "../dvdplayer/DVDCodecs/Video/DVDVideoCodec.h"
 #include "../dvdplayer/DVDCodecs/DVDCodecUtils.h"
 
-#ifdef HAVE_LIBVA
-  #include "../dvdplayer/DVDCodecs/Video/VAAPI.h"
-#endif
-
 #define MAXPRESENTDELAY 0.500
 
 /* at any point we want an exclusive lock on rendermanager */
@@ -101,10 +99,37 @@ static void requeue(std::deque<int> &trg, std::deque<int> &src)
   src.pop_front();
 }
 
+static std::string GetRenderFormatName(ERenderFormat format)
+{
+  switch(format)
+  {
+    case RENDER_FMT_YUV420P:   return "YV12";
+    case RENDER_FMT_YUV420P16: return "YV12P16";
+    case RENDER_FMT_YUV420P10: return "YV12P10";
+    case RENDER_FMT_NV12:      return "NV12";
+    case RENDER_FMT_UYVY422:   return "UYVY";
+    case RENDER_FMT_YUYV422:   return "YUY2";
+    case RENDER_FMT_VDPAU:     return "VDPAU";
+    case RENDER_FMT_VDPAU_420: return "VDPAU_420";
+    case RENDER_FMT_DXVA:      return "DXVA";
+    case RENDER_FMT_VAAPI:     return "VAAPI";
+    case RENDER_FMT_VAAPINV12: return "VAAPI_NV12";
+    case RENDER_FMT_OMXEGL:    return "OMXEGL";
+    case RENDER_FMT_CVBREF:    return "BGRA";
+    case RENDER_FMT_EGLIMG:    return "EGLIMG";
+    case RENDER_FMT_BYPASS:    return "BYPASS";
+    case RENDER_FMT_MEDIACODEC:return "MEDIACODEC";
+    case RENDER_FMT_IMXMAP:    return "IMXMAP";
+    case RENDER_FMT_MMAL:      return "MMAL";
+    case RENDER_FMT_NONE:      return "NONE";
+  }
+  return "UNKNOWN";
+}
+
 CXBMCRenderManager::CXBMCRenderManager()
 {
   m_pRenderer = NULL;
-  m_bIsStarted = false;
+  m_renderState = STATE_UNCONFIGURED;
 
   m_presentstep = PRESENT_IDLE;
   m_rendermethod = 0;
@@ -125,7 +150,6 @@ CXBMCRenderManager::CXBMCRenderManager()
 CXBMCRenderManager::~CXBMCRenderManager()
 {
   delete m_pRenderer;
-  m_pRenderer = NULL;
 }
 
 void CXBMCRenderManager::GetVideoRect(CRect &source, CRect &dest, CRect &view)
@@ -211,14 +235,11 @@ void CXBMCRenderManager::WaitPresentTime(double presenttime)
 
   avgerror /= ERRORBUFFSIZE;
 
-
   //we change the clock speed slightly
   //to make every frame's presenttime end up in the middle of two vblanks
   //integral correction, clamp to -0.5:0.5 range
   m_presentcorr = std::max(std::min(m_presentcorr + avgerror * 0.01, 0.1), -0.1);
   g_VideoReferenceClock.SetFineAdjust(1.0 - avgerror * 0.01 - m_presentcorr * 0.01);
-
-  //printf("%f %f % 2.0f%% % f % f\n", presenttime, clock, m_presentcorr * 100, error, error_org);
 }
 
 std::string CXBMCRenderManager::GetVSyncState()
@@ -235,56 +256,118 @@ std::string CXBMCRenderManager::GetVSyncState()
   return state;
 }
 
-bool CXBMCRenderManager::Configure(unsigned int width, unsigned int height, unsigned int d_width, unsigned int d_height, float fps, unsigned flags, ERenderFormat format, unsigned extended_format, unsigned int orientation, int buffers)
+bool CXBMCRenderManager::Configure(DVDVideoPicture& picture, float fps, unsigned flags, unsigned int orientation, int buffers)
 {
 
-  CSingleLock    lock2(m_presentlock);
+  // check if something has changed
+  {
+    float config_framerate = fps;
+    float render_framerate = g_graphicsContext.GetFPS();
+    if (CSettings::Get().GetInt("videoplayer.adjustrefreshrate") == ADJUST_REFRESHRATE_OFF)
+      render_framerate = config_framerate;
+    bool changerefresh = (fps != 0) &&
+                         (m_fps == 0.0 || fmod(m_fps, fps) != 0.0) &&
+                         (render_framerate != config_framerate);
+
+    CSharedLock lock(m_sharedSection);
+    if (m_width == picture.iWidth &&
+        m_height == picture.iHeight &&
+        m_dwidth == picture.iDisplayWidth &&
+        m_dheight == picture.iDisplayHeight &&
+        !changerefresh &&
+        m_flags == flags &&
+        m_format == picture.format &&
+        m_extended_format == picture.extended_format &&
+        m_orientation == orientation &&
+        m_NumberBuffers == buffers &&
+        m_pRenderer != NULL)
+      return true;
+  }
+
+  std::string formatstr = GetRenderFormatName(picture.format);
+  CLog::Log(LOGDEBUG, "CXBMCRenderManager::Configure - change configuration. %dx%d. display: %dx%d. framerate: %4.2f. format: %s", picture.iWidth, picture.iHeight, picture.iDisplayWidth, picture.iDisplayHeight, fps, formatstr.c_str());
 
-  /* make sure any queued frame was fully presented */
-  XbmcThreads::EndTime endtime(5000);
-  while(m_presentstep != PRESENT_IDLE && m_presentstep != PRESENT_READY)
+  // make sure any queued frame was fully presented
   {
-    if(endtime.IsTimePast())
+    CSingleLock lock(m_presentlock);
+    XbmcThreads::EndTime endtime(5000);
+    while(m_presentstep != PRESENT_IDLE && m_presentstep != PRESENT_READY)
     {
-      CLog::Log(LOGWARNING, "CRenderManager::Configure - timeout waiting for state");
-      return false;
+      if(endtime.IsTimePast())
+      {
+        CLog::Log(LOGWARNING, "CRenderManager::Configure - timeout waiting for state");
+        return false;
+      }
+      m_presentevent.wait(lock, endtime.MillisLeft());
     }
-    m_presentevent.wait(lock2, endtime.MillisLeft());
-  };
-  lock2.Leave();
+  }
 
-  CExclusiveLock lock(m_sharedSection);
-  if(!m_pRenderer)
   {
-    CLog::Log(LOGERROR, "%s called without a valid Renderer object", __FUNCTION__);
+    CExclusiveLock lock(m_sharedSection);
+    m_width = picture.iWidth;
+    m_height = picture.iHeight,
+    m_dwidth = picture.iDisplayWidth;
+    m_dheight = picture.iDisplayHeight;
+    m_fps = fps;
+    m_flags = flags;
+    m_format = picture.format;
+    m_extended_format = picture.extended_format;
+    m_orientation = orientation;
+    m_NumberBuffers  = buffers;
+    m_renderState = STATE_CONFIGURING;
+    m_stateEvent.Reset();
+  }
+
+  if (!m_stateEvent.WaitMSec(1000))
+  {
+    CLog::Log(LOGWARNING, "CRenderManager::Configure - timeout waiting for configure");
+    return false;
+  }
+
+  CSharedLock lock(m_sharedSection);
+  if (m_renderState != STATE_CONFIGURED)
+  {
+    CLog::Log(LOGWARNING, "CRenderManager::Configure - failed to configure");
     return false;
   }
 
+  return true;
+}
+
+bool CXBMCRenderManager::Configure()
+{
+  CExclusiveLock lock(m_sharedSection);
+  CSingleLock lock2(m_presentlock);
 
-  bool result = m_pRenderer->Configure(width, height, d_width, d_height, fps, flags, format, extended_format, orientation);
-  if(result)
+  if (m_pRenderer && m_pRenderer->GetRenderFormat() != m_format)
   {
-    if( flags & CONF_FLAGS_FULLSCREEN )
-    {
-      lock.Leave();
-      CApplicationMessenger::Get().SwitchToFullscreen();
-      lock.Enter();
-    }
-    lock2.Enter();
-    m_format = format;
+    DeleteRenderer();
+  }
+
+  if(!m_pRenderer)
+  {
+    CreateRenderer();
+    if (!m_pRenderer)
+      return false;
+    else
+      m_pRenderer->PreInit();
+  }
 
+  bool result = m_pRenderer->Configure(m_width, m_height, m_dwidth, m_dheight, m_fps, m_flags, m_format, m_extended_format, m_orientation);
+  if (result)
+  {
     CRenderInfo info = m_pRenderer->GetRenderInfo();
     int renderbuffers = info.optimal_buffer_size;
     m_QueueSize = renderbuffers;
-    if (buffers > 0)
-      m_QueueSize = std::min(buffers, renderbuffers);
+    if (m_NumberBuffers > 0)
+      m_QueueSize = std::min(m_NumberBuffers, renderbuffers);
 
     m_QueueSize = std::min(m_QueueSize, (int)info.max_buffer_size);
     m_QueueSize = std::min(m_QueueSize, NUM_BUFFERS);
     if(m_QueueSize < 2)
     {
       m_QueueSize = 2;
-      CLog::Log(LOGWARNING, "CXBMCRenderManager::Configure - queue size too small (%d, %d, %d)", m_QueueSize, renderbuffers, buffers);
+      CLog::Log(LOGWARNING, "CXBMCRenderManager::Configure - queue size too small (%d, %d, %d)", m_QueueSize, renderbuffers, m_NumberBuffers);
     }
 
     m_pRenderer->SetBufferSize(m_QueueSize);
@@ -297,7 +380,6 @@ bool CXBMCRenderManager::Configure(unsigned int width, unsigned int height, unsi
     for (int i=1; i < m_QueueSize; i++)
       m_free.push_back(i);
 
-    m_bIsStarted = true;
     m_bRenderGUI = true;
     m_waitForBufferCount = 0;
     m_bReconfigured = true;
@@ -307,17 +389,24 @@ bool CXBMCRenderManager::Configure(unsigned int width, unsigned int height, unsi
     m_presentevent.notifyAll();
     m_renderedOverlay = false;
 
+    m_renderState = STATE_CONFIGURED;
+
     CLog::Log(LOGDEBUG, "CXBMCRenderManager::Configure - %d", m_QueueSize);
   }
+  else
+    m_renderState = STATE_UNCONFIGURED;
 
+  m_stateEvent.Set();
   return result;
 }
 
 bool CXBMCRenderManager::IsConfigured() const
 {
-  if (!m_pRenderer)
+  CSharedLock lock(m_sharedSection);
+  if (m_renderState == STATE_CONFIGURED)
+    return true;
+  else
     return false;
-  return m_pRenderer->IsConfigured();
 }
 
 void CXBMCRenderManager::Update()
@@ -347,54 +436,66 @@ bool CXBMCRenderManager::HasFrame()
 
 void CXBMCRenderManager::FrameMove()
 {
-  { CSharedLock lock(m_sharedSection);
-    CSingleLock lock2(m_presentlock);
+  CSharedLock lock(m_sharedSection);
 
-    if (!m_pRenderer)
+  if (m_renderState == STATE_UNCONFIGURED)
+    return;
+  else if (m_renderState == STATE_CONFIGURING)
+  {
+    lock.Leave();
+    if (!Configure())
       return;
 
-    if (m_presentstep == PRESENT_FRAME2)
+    if (m_flags & CONF_FLAGS_FULLSCREEN)
     {
-      if(!m_queued.empty())
-      {
-        double timestamp = GetPresentTime();
-        SPresent& m = m_Queue[m_presentsource];
-        SPresent& q = m_Queue[m_queued.front()];
-        if(timestamp > m.timestamp + (q.timestamp - m.timestamp) * 0.5)
-        {
-          m_presentstep = PRESENT_READY;
-          m_presentevent.notifyAll();
-        }
-      }
+      CApplicationMessenger::Get().SwitchToFullscreen();
     }
+    lock.Enter();
+  }
 
-    if (m_presentstep == PRESENT_READY)
-      PrepareNextRender();
-
-    if(m_presentstep == PRESENT_FLIP)
-    {
-      m_pRenderer->FlipPage(m_presentsource);
-      m_presentstep = PRESENT_FRAME;
-      m_presentevent.notifyAll();
-    }
+  CSingleLock lock2(m_presentlock);
 
-    /* release all previous */
-    for(std::deque<int>::iterator it = m_discard.begin(); it != m_discard.end(); )
+  if (m_presentstep == PRESENT_FRAME2)
+  {
+    if (!m_queued.empty())
     {
-      // renderer may want to keep the frame for postprocessing
-      if (!m_pRenderer->NeedBufferForRef(*it) || !m_bRenderGUI)
+      double timestamp = GetPresentTime();
+      SPresent& m = m_Queue[m_presentsource];
+      SPresent& q = m_Queue[m_queued.front()];
+      if(timestamp > m.timestamp + (q.timestamp - m.timestamp) * 0.5)
       {
-        m_pRenderer->ReleaseBuffer(*it);
-        m_overlays.Release(*it);
-        m_free.push_back(*it);
-        it = m_discard.erase(it);
+        m_presentstep = PRESENT_READY;
+        m_presentevent.notifyAll();
       }
-      else
-        ++it;
     }
+  }
 
-    m_bRenderGUI = true;
+  if (m_presentstep == PRESENT_READY)
+    PrepareNextRender();
+
+  if(m_presentstep == PRESENT_FLIP)
+  {
+    m_pRenderer->FlipPage(m_presentsource);
+    m_presentstep = PRESENT_FRAME;
+    m_presentevent.notifyAll();
   }
+
+  /* release all previous */
+  for (std::deque<int>::iterator it = m_discard.begin(); it != m_discard.end(); )
+  {
+    // renderer may want to keep the frame for postprocessing
+    if (!m_pRenderer->NeedBufferForRef(*it) || !m_bRenderGUI)
+    {
+      m_pRenderer->ReleaseBuffer(*it);
+      m_overlays.Release(*it);
+      m_free.push_back(*it);
+      it = m_discard.erase(it);
+    }
+    else
+      ++it;
+  }
+
+  m_bRenderGUI = true;
 }
 
 void CXBMCRenderManager::FrameFinish()
@@ -434,8 +535,14 @@ void CXBMCRenderManager::FrameFinish()
   }
 }
 
-unsigned int CXBMCRenderManager::PreInit()
+void CXBMCRenderManager::PreInit()
 {
+  if (!g_application.IsCurrentThread())
+  {
+    CLog::Log(LOGERROR, "CXBMCRenderManager::UnInit - not called from render thread");
+    return;
+  }
+
   CRetakeLock<CExclusiveLock> lock(m_sharedSection);
 
   m_presentcorr = 0.0;
@@ -443,44 +550,35 @@ unsigned int CXBMCRenderManager::PreInit()
   m_errorindex  = 0;
   memset(m_errorbuff, 0, sizeof(m_errorbuff));
 
-  m_bIsStarted = false;
   if (!m_pRenderer)
   {
-#if defined(HAS_GL)
-    m_pRenderer = new CLinuxRendererGL();
-#elif defined(HAS_MMAL)
-    m_pRenderer = new CMMALRenderer();
-#elif HAS_GLES == 2
-    m_pRenderer = new CLinuxRendererGLES();
-#elif defined(HAS_DX)
-    m_pRenderer = new CWinRenderer();
-#elif defined(HAS_SDL)
-    m_pRenderer = new CLinuxRenderer();
-#endif
+    m_format = RENDER_FMT_NONE;
+    CreateRenderer();
   }
 
   UpdateDisplayLatency();
 
   m_QueueSize   = 2;
   m_QueueSkip   = 0;
-
-  return m_pRenderer->PreInit();
 }
 
 void CXBMCRenderManager::UnInit()
 {
-  CRetakeLock<CExclusiveLock> lock(m_sharedSection);
+  if (!g_application.IsCurrentThread())
+  {
+    CLog::Log(LOGERROR, "CXBMCRenderManager::UnInit - not called from render thread");
+    return;
+  }
 
-  m_bIsStarted = false;
+  CRetakeLock<CExclusiveLock> lock(m_sharedSection);
 
   m_overlays.Flush();
   g_fontManager.Unload("__subtitle__");
   g_fontManager.Unload("__subtitleborder__");
 
-  // free renderer resources.
-  // TODO: we may also want to release the renderer here.
-  if (m_pRenderer)
-    m_pRenderer->UnInit();
+  DeleteRenderer();
+
+  m_renderState = STATE_UNCONFIGURED;
 }
 
 bool CXBMCRenderManager::Flush()
@@ -493,9 +591,13 @@ bool CXBMCRenderManager::Flush()
     CLog::Log(LOGDEBUG, "%s - flushing renderer", __FUNCTION__);
 
     CRetakeLock<CExclusiveLock> lock(m_sharedSection);
-    m_pRenderer->Flush();
-    m_overlays.Flush();
-    m_flushEvent.Set();
+
+    if (m_pRenderer)
+    {
+      m_pRenderer->Flush();
+      m_overlays.Flush();
+      m_flushEvent.Set();
+    }
   }
   else
   {
@@ -511,6 +613,7 @@ bool CXBMCRenderManager::Flush()
       return true;
   }
 
+  CSingleLock lock(m_presentlock);
   m_queued.clear();
   m_discard.clear();
   m_free.clear();
@@ -520,6 +623,56 @@ bool CXBMCRenderManager::Flush()
 
   return true;
 }
+void CXBMCRenderManager::CreateRenderer()
+{
+  if (!m_pRenderer)
+  {
+#if defined(HAS_MMAL)
+    m_pRenderer = new CMMALRenderer();
+#elif HAS_GLES == 2
+    m_pRenderer = new CLinuxRendererGLES();
+#elif defined(HAS_DX)
+    m_pRenderer = new CWinRenderer();
+#endif
+#if defined(HAS_GL)
+    if (m_format == RENDER_FMT_VAAPI || m_format == RENDER_FMT_VAAPINV12)
+    {
+#if defined(HAVE_LIBVA)
+      m_pRenderer = new CRendererVAAPI;
+#endif
+    }
+    else if (m_format == RENDER_FMT_VDPAU || m_format == RENDER_FMT_VDPAU_420)
+    {
+#if defined(HAVE_LIBVDPAU)
+      m_pRenderer = new CRendererVDPAU;
+#endif
+    }
+    else if (m_format == RENDER_FMT_CVBREF)
+    {
+#if defined(TARGET_DARWIN_OSX)
+      m_pRenderer = new CRendererVDA;
+#endif
+    }
+    else if (m_format != RENDER_FMT_NONE)
+    {
+      m_pRenderer = new CLinuxRendererGL;
+    }
+#endif
+    if (m_pRenderer)
+      m_pRenderer->PreInit();
+  }
+}
+
+void CXBMCRenderManager::DeleteRenderer()
+{
+  CLog::Log(LOGDEBUG, "%s - deleting renderer", __FUNCTION__);
+
+  if (m_pRenderer)
+  {
+    delete m_pRenderer;
+    m_pRenderer = NULL;
+  }
+}
 
 void CXBMCRenderManager::SetupScreenshot()
 {
@@ -754,13 +907,6 @@ void CXBMCRenderManager::FlipPage(volatile bool& bStop, double timestamp /* = 0L
   }
 }
 
-void CXBMCRenderManager::Reset()
-{
-  CSharedLock lock(m_sharedSection);
-  if (m_pRenderer)
-    m_pRenderer->Reset();
-}
-
 RESOLUTION CXBMCRenderManager::GetResolution()
 {
   CSharedLock lock(m_sharedSection);
@@ -801,6 +947,9 @@ void CXBMCRenderManager::Render(bool clear, DWORD flags, DWORD alpha, bool gui)
 {
   CSharedLock lock(m_sharedSection);
 
+  if (m_renderState != STATE_CONFIGURED)
+    return;
+
   if (!gui && m_pRenderer->IsGuiLayer())
     return;
 
@@ -909,10 +1058,6 @@ void CXBMCRenderManager::PresentBlend(bool clear, DWORD flags, DWORD alpha)
 
 void CXBMCRenderManager::Recover()
 {
-#if defined(HAS_GL) && !defined(TARGET_DARWIN)
-  glFlush(); // attempt to have gpu done with pixmap and vdpau
-#endif
-
   UpdateDisplayLatency();
 }
 
@@ -947,8 +1092,8 @@ CRenderInfo CXBMCRenderManager::GetRenderInfo()
   CRenderInfo info;
   if (!m_pRenderer)
   {
-    CLog::Log(LOGERROR, "%s - renderer is NULL", __FUNCTION__);
-    return CRenderInfo();
+    info.max_buffer_size = NUM_BUFFERS;
+    return info;;
   }
   return m_pRenderer->GetRenderInfo();
 }
@@ -999,16 +1144,12 @@ int CXBMCRenderManager::AddVideoPicture(DVDVideoPicture& pic)
        || pic.format == RENDER_FMT_OMXEGL
        || pic.format == RENDER_FMT_CVBREF
        || pic.format == RENDER_FMT_VAAPI
+       || pic.format == RENDER_FMT_VAAPINV12
        || pic.format == RENDER_FMT_EGLIMG
        || pic.format == RENDER_FMT_MEDIACODEC
        || pic.format == RENDER_FMT_IMXMAP
        || pic.format == RENDER_FMT_MMAL)
     m_pRenderer->AddVideoPictureHW(pic, index);
-  else if(pic.format == RENDER_FMT_VAAPINV12)
-  {
-    m_pRenderer->AddVideoPictureHW(pic, index);
-    CDVDCodecUtils::CopyNV12Picture(&image, &pic.vaapi->DVDPic);
-  }
 
   m_pRenderer->ReleaseImage(index, false);
 
@@ -1073,7 +1214,7 @@ EINTERLACEMETHOD CXBMCRenderManager::AutoInterlaceMethodInternal(EINTERLACEMETHO
 
 int CXBMCRenderManager::WaitForBuffer(volatile bool& bStop, int timeout)
 {
-  CSingleLock lock2(m_presentlock);
+  CSingleLock lock(m_presentlock);
 
   // check if gui is active and discard buffer if not
   // this keeps videoplayer going
@@ -1094,7 +1235,7 @@ int CXBMCRenderManager::WaitForBuffer(volatile bool& bStop, int timeout)
     if (sleeptime < 0)
       sleeptime = 0;
     sleeptime = std::min(sleeptime, 20);
-    m_presentevent.wait(lock2, sleeptime);
+    m_presentevent.wait(lock, sleeptime);
     DiscardBuffer();
     return 0;
   }
@@ -1102,7 +1243,7 @@ int CXBMCRenderManager::WaitForBuffer(volatile bool& bStop, int timeout)
   XbmcThreads::EndTime endtime(timeout);
   while(m_free.empty())
   {
-    m_presentevent.wait(lock2, std::min(50, timeout));
+    m_presentevent.wait(lock, std::min(50, timeout));
     if(endtime.IsTimePast() || bStop)
     {
       if (timeout != 0 && !bStop)
diff --git a/xbmc/cores/VideoRenderers/RenderManager.h b/xbmc/cores/VideoRenderers/RenderManager.h
index 87573a5..d57e32c 100644
--- a/xbmc/cores/VideoRenderers/RenderManager.h
+++ b/xbmc/cores/VideoRenderers/RenderManager.h
@@ -53,7 +53,7 @@ public:
   CXBMCRenderManager();
   ~CXBMCRenderManager();
 
-  // Functions called from the GUI
+  // Functions called from render thread
   void GetVideoRect(CRect &source, CRect &dest, CRect &view);
   float GetAspectRatio();
   void Update();
@@ -64,31 +64,43 @@ public:
   void Render(bool clear, DWORD flags = 0, DWORD alpha = 255, bool gui = true);
   bool IsGuiLayer();
   bool IsVideoLayer();
-  void SetupScreenshot();
+  RESOLUTION GetResolution();
+  void UpdateResolution();
+  void SetViewMode(int iViewMode);
+  void Recover(); // called after resolution switch if something special is needed
+  void PreInit();
+  void UnInit();
+  bool Flush();
+  bool IsConfigured() const;
 
+  void SetupScreenshot();
   CRenderCapture* AllocRenderCapture();
   void ReleaseRenderCapture(CRenderCapture* capture);
   void Capture(CRenderCapture *capture, unsigned int width, unsigned int height, int flags);
   void ManageCaptures();
 
-  void SetViewMode(int iViewMode);
+  // Functions called from GUI
+  bool Supports(ERENDERFEATURE feature);
+  bool Supports(EDEINTERLACEMODE method);
+  bool Supports(EINTERLACEMETHOD method);
+  bool Supports(ESCALINGMETHOD method);
+  EINTERLACEMETHOD AutoInterlaceMethod(EINTERLACEMETHOD mInt);
+
+  static float GetMaximumFPS();
+  double GetDisplayLatency() { return m_displayLatency; }
+  int GetSkippedFrames()  { return m_QueueSkip; }
+  std::string GetVSyncState();
 
   // Functions called from mplayer
   /**
    * Called by video player to configure renderer
-   * @param width width of decoded frame
-   * @param height height of decoded frame
-   * @param d_width displayed width of frame (aspect ratio)
-   * @param d_height displayed height of frame
+   * @param picture
    * @param fps frames per second of video
    * @param flags see RenderFlags.h
-   * @param format see RenderFormats.h
-   * @param extended_format used by DXVA
    * @param orientation
    * @param numbers of kept buffer references
    */
-  bool Configure(unsigned int width, unsigned int height, unsigned int d_width, unsigned int d_height, float fps, unsigned flags, ERenderFormat format, unsigned extended_format,  unsigned int orientation, int buffers = 0);
-  bool IsConfigured() const;
+  bool Configure(DVDVideoPicture& picture, float fps, unsigned flags, unsigned int orientation, int buffers = 0);
 
   int AddVideoPicture(DVDVideoPicture& picture);
 
@@ -107,9 +119,6 @@ public:
    * @param sync signals frame, top, or bottom field
    */
   void FlipPage(volatile bool& bStop, double timestamp = 0.0, double pts = 0.0, int source = -1, EFIELDSYNC sync = FS_NONE);
-  unsigned int PreInit();
-  void UnInit();
-  bool Flush();
 
   void AddOverlay(CDVDOverlay* o, double pts)
   {
@@ -127,41 +136,9 @@ public:
     m_overlays.AddCleanup(o);
   }
 
-  void Reset();
-
-  RESOLUTION GetResolution();
-
-  static float GetMaximumFPS();
-  inline bool IsStarted() { return m_bIsStarted;}
-  double GetDisplayLatency() { return m_displayLatency; }
-  int    GetSkippedFrames()  { return m_QueueSkip; }
-
-  bool Supports(ERENDERFEATURE feature);
-  bool Supports(EDEINTERLACEMODE method);
-  bool Supports(EINTERLACEMETHOD method);
-  bool Supports(ESCALINGMETHOD method);
-
-  EINTERLACEMETHOD AutoInterlaceMethod(EINTERLACEMETHOD mInt);
-
-  static double GetPresentTime();
-  void  WaitPresentTime(double presenttime);
-
-  std::string GetVSyncState();
-
-  void UpdateResolution();
-
-  CBaseRenderer *m_pRenderer;
-
   // Get renderer info, can be called before configure
   CRenderInfo GetRenderInfo();
 
-  void Recover(); // called after resolution switch if something special is needed
-
-  CSharedSection& GetSection() { return m_sharedSection; };
-
-  void RegisterRenderUpdateCallBack(const void *ctx, RenderUpdateCallBackFn fn);
-  void RegisterRenderFeaturesCallBack(const void *ctx, RenderFeaturesCallBackFn fn);
-
   /**
    * If player uses buffering it has to wait for a buffer before it calls
    * AddVideoPicture and AddOverlay. It waits for max 50 ms before it returns -1
@@ -183,6 +160,10 @@ public:
    */
   void DiscardBuffer();
 
+  // TODO: trash those
+  void RegisterRenderUpdateCallBack(const void *ctx, RenderUpdateCallBackFn fn);
+  void RegisterRenderFeaturesCallBack(const void *ctx, RenderFeaturesCallBackFn fn);
+
 protected:
 
   void PresentSingle(bool clear, DWORD flags, DWORD alpha);
@@ -190,17 +171,22 @@ protected:
   void PresentBlend(bool clear, DWORD flags, DWORD alpha);
 
   void PrepareNextRender();
+  static double GetPresentTime();
+  void  WaitPresentTime(double presenttime);
 
   EINTERLACEMETHOD AutoInterlaceMethodInternal(EINTERLACEMETHOD mInt);
+  bool Configure();
+  void CreateRenderer();
+  void DeleteRenderer();
 
+  CBaseRenderer *m_pRenderer;
+  OVERLAY::CRenderer m_overlays;
   CSharedSection m_sharedSection;
-
-  bool m_bIsStarted;
   bool m_bReconfigured;
   bool m_bRenderGUI;
   int m_waitForBufferCount;
-
   int m_rendermethod;
+  bool m_renderedOverlay;
 
   enum EPRESENTSTEP
   {
@@ -219,6 +205,15 @@ protected:
     PRESENT_METHOD_BOB,
   };
 
+  enum ERENDERSTATE
+  {
+    STATE_UNCONFIGURED = 0,
+    STATE_CONFIGURING,
+    STATE_CONFIGURED,
+  };
+  ERENDERSTATE m_renderState;
+  CEvent m_stateEvent;
+
   double m_displayLatency;
   void UpdateDisplayLatency();
 
@@ -238,6 +233,12 @@ protected:
   std::deque<int> m_discard;
 
   ERenderFormat m_format;
+  unsigned int m_width, m_height, m_dwidth, m_dheight;
+  unsigned int m_flags;
+  float m_fps;
+  unsigned int m_extended_format;
+  unsigned int m_orientation;
+  int m_NumberBuffers;
 
   double m_sleeptime;
   double m_presentpts;
@@ -252,9 +253,6 @@ protected:
   CEvent m_flushEvent;
   double m_clock_framefinish;
 
-  OVERLAY::CRenderer m_overlays;
-  bool m_renderedOverlay;
-
   void RenderCapture(CRenderCapture* capture);
   void RemoveCapture(CRenderCapture* capture);
   CCriticalSection m_captCritSect;
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp
index 51333d4..1b66c84 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp
@@ -1087,7 +1087,6 @@ bool CDecoder::ConfigVAAPI()
     return false;
   }
 
-
   m_hwContext.config_id = m_vaapiConfig.configId;
   m_hwContext.context_id = m_vaapiConfig.contextId;
   m_hwContext.display = m_vaapiConfig.dpy;
diff --git a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
index 56395cf..a48468a 100644
--- a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
+++ b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
@@ -153,7 +153,6 @@ CDVDPlayerVideo::CDVDPlayerVideo( CDVDClock* pClock
   m_iFrameRateLength = 0;
   m_bFpsInvalid = false;
   m_bAllowFullscreen = false;
-  memset(&m_output, 0, sizeof(m_output));
 }
 
 CDVDPlayerVideo::~CDVDPlayerVideo()
@@ -937,33 +936,6 @@ void CDVDPlayerVideo::ProcessOverlays(DVDVideoPicture* pSource, double pts)
 }
 #endif
 
-static std::string GetRenderFormatName(ERenderFormat format)
-{
-  switch(format)
-  {
-    case RENDER_FMT_YUV420P:   return "YV12";
-    case RENDER_FMT_YUV420P16: return "YV12P16";
-    case RENDER_FMT_YUV420P10: return "YV12P10";
-    case RENDER_FMT_NV12:      return "NV12";
-    case RENDER_FMT_UYVY422:   return "UYVY";
-    case RENDER_FMT_YUYV422:   return "YUY2";
-    case RENDER_FMT_VDPAU:     return "VDPAU";
-    case RENDER_FMT_VDPAU_420: return "VDPAU_420";
-    case RENDER_FMT_DXVA:      return "DXVA";
-    case RENDER_FMT_VAAPI:     return "VAAPI";
-    case RENDER_FMT_VAAPINV12: return "VAAPI_NV12";
-    case RENDER_FMT_OMXEGL:    return "OMXEGL";
-    case RENDER_FMT_CVBREF:    return "BGRA";
-    case RENDER_FMT_EGLIMG:    return "EGLIMG";
-    case RENDER_FMT_BYPASS:    return "BYPASS";
-    case RENDER_FMT_MEDIACODEC:return "MEDIACODEC";
-    case RENDER_FMT_IMXMAP:    return "IMXMAP";
-    case RENDER_FMT_MMAL:      return "MMAL";
-    case RENDER_FMT_NONE:      return "NONE";
-  }
-  return "UNKNOWN";
-}
-
 std::string CDVDPlayerVideo::GetStereoMode()
 {
   std::string  stereo_mode;
@@ -993,97 +965,40 @@ int CDVDPlayerVideo::OutputPicture(const DVDVideoPicture* src, double pts)
   /* figure out steremode expected based on user settings and hints */
   unsigned int stereo_flags = GetStereoModeFlags(GetStereoMode());
 
-#ifdef HAS_VIDEO_PLAYBACK
   double config_framerate = m_bFpsInvalid ? 0.0 : m_fFrameRate;
-  double render_framerate = g_graphicsContext.GetFPS();
-  if (CSettings::Get().GetInt("videoplayer.adjustrefreshrate") == ADJUST_REFRESHRATE_OFF)
-    render_framerate = config_framerate;
-  bool changerefresh = !m_bFpsInvalid &&
-                       (m_output.framerate == 0.0 || fmod(m_output.framerate, config_framerate) != 0.0) &&
-                       (render_framerate != config_framerate);
-
-  /* check so that our format or aspect has changed. if it has, reconfigure renderer */
-  if (!g_renderManager.IsConfigured()
-   || ( m_output.width           != pPicture->iWidth )
-   || ( m_output.height          != pPicture->iHeight )
-   || ( m_output.dwidth          != pPicture->iDisplayWidth )
-   || ( m_output.dheight         != pPicture->iDisplayHeight )
-   || changerefresh
-   || ( m_output.color_format    != (unsigned int)pPicture->format )
-   || ( m_output.extended_format != pPicture->extended_format )
-   || ( m_output.color_matrix    != pPicture->color_matrix    && pPicture->color_matrix    != 0 ) // don't reconfigure on unspecified
-   || ( m_output.chroma_position != pPicture->chroma_position && pPicture->chroma_position != 0 )
-   || ( m_output.color_primaries != pPicture->color_primaries && pPicture->color_primaries != 0 )
-   || ( m_output.color_transfer  != pPicture->color_transfer  && pPicture->color_transfer  != 0 )
-   || ( m_output.color_range     != pPicture->color_range )
-   || ( m_output.stereo_flags    != stereo_flags))
-  {
-    CLog::Log(LOGNOTICE, " fps: %f, pwidth: %i, pheight: %i, dwidth: %i, dheight: %i"
-                       , config_framerate
-                       , pPicture->iWidth
-                       , pPicture->iHeight
-                       , pPicture->iDisplayWidth
-                       , pPicture->iDisplayHeight);
-
-    unsigned flags = 0;
-    if(pPicture->color_range == 1)
-      flags |= CONF_FLAGS_YUV_FULLRANGE;
 
-    flags |= GetFlagsChromaPosition(pPicture->chroma_position)
-          |  GetFlagsColorMatrix(pPicture->color_matrix, pPicture->iWidth, pPicture->iHeight)
-          |  GetFlagsColorPrimaries(pPicture->color_primaries)
-          |  GetFlagsColorTransfer(pPicture->color_transfer);
+  unsigned flags = 0;
+  if(pPicture->color_range == 1)
+    flags |= CONF_FLAGS_YUV_FULLRANGE;
 
-    std::string formatstr = GetRenderFormatName(pPicture->format);
-
-    if(m_bAllowFullscreen)
-    {
-      flags |= CONF_FLAGS_FULLSCREEN;
-      m_bAllowFullscreen = false; // only allow on first configure
-    }
+  flags |= GetFlagsChromaPosition(pPicture->chroma_position)
+              |  GetFlagsColorMatrix(pPicture->color_matrix, pPicture->iWidth, pPicture->iHeight)
+              |  GetFlagsColorPrimaries(pPicture->color_primaries)
+              |  GetFlagsColorTransfer(pPicture->color_transfer);
 
-    flags |= stereo_flags;
-
-    CLog::Log(LOGDEBUG,"%s - change configuration. %dx%d. framerate: %4.2f. format: %s",__FUNCTION__,pPicture->iWidth, pPicture->iHeight, config_framerate, formatstr.c_str());
-    if(!g_renderManager.Configure(pPicture->iWidth
-                                , pPicture->iHeight
-                                , pPicture->iDisplayWidth
-                                , pPicture->iDisplayHeight
-                                , config_framerate
-                                , flags
-                                , pPicture->format
-                                , pPicture->extended_format
-                                , m_hints.orientation
-                                , m_pVideoCodec->GetAllowedReferences()))
-    {
-      CLog::Log(LOGERROR, "%s - failed to configure renderer", __FUNCTION__);
-      return EOS_ABORT;
-    }
 
-    m_output.width           = pPicture->iWidth;
-    m_output.height          = pPicture->iHeight;
-    m_output.dwidth          = pPicture->iDisplayWidth;
-    m_output.dheight         = pPicture->iDisplayHeight;
-    m_output.framerate       = config_framerate;
-    m_output.color_format    = pPicture->format;
-    m_output.extended_format = pPicture->extended_format;
-    m_output.color_matrix    = pPicture->color_matrix;
-    m_output.chroma_position = pPicture->chroma_position;
-    m_output.color_primaries = pPicture->color_primaries;
-    m_output.color_transfer  = pPicture->color_transfer;
-    m_output.color_range     = pPicture->color_range;
-    m_output.stereo_flags    = stereo_flags;
+  if(m_bAllowFullscreen)
+  {
+    flags |= CONF_FLAGS_FULLSCREEN;
+    m_bAllowFullscreen = false; // only allow on first configure
   }
 
-  int    result  = 0;
+  flags |= stereo_flags;
 
-  if (!g_renderManager.IsStarted()) {
-    CLog::Log(LOGERROR, "%s - renderer not started", __FUNCTION__);
+  if(!g_renderManager.Configure(picture,
+                                config_framerate,
+                                flags,
+                                m_hints.orientation,
+                                m_pVideoCodec->GetAllowedReferences()))
+  {
+    CLog::Log(LOGERROR, "%s - failed to configure renderer", __FUNCTION__);
     return EOS_ABORT;
   }
 
+  int    result  = 0;
+
   //correct any pattern in the timestamps
-  if (m_output.color_format != RENDER_FMT_BYPASS)
+  if (picture.format != RENDER_FMT_BYPASS)
   {
     m_pullupCorrection.Add(pts);
     pts += m_pullupCorrection.GetCorrection();
@@ -1104,7 +1019,7 @@ int CDVDPlayerVideo::OutputPicture(const DVDVideoPicture* src, double pts)
     pts -= DVD_TIME_BASE * interval;
   }
 
-  if (m_output.color_format != RENDER_FMT_BYPASS)
+  if (picture.format != RENDER_FMT_BYPASS)
   {
     // Correct pts by user set delay and rendering delay
     pts += m_iVideoDelay - DVD_SEC_TO_TIME(g_renderManager.GetDisplayLatency());
@@ -1236,10 +1151,6 @@ int CDVDPlayerVideo::OutputPicture(const DVDVideoPicture* src, double pts)
   g_renderManager.FlipPage(CThread::m_bStop, (iCurrentClock + iSleepTime) / DVD_TIME_BASE, pts_org, -1, mDisplayField);
 
   return result;
-#else
-  // no video renderer, let's mark it as dropped
-  return EOS_DROPPED;
-#endif
 }
 
 std::string CDVDPlayerVideo::GetPlayerInfo()
diff --git a/xbmc/cores/dvdplayer/DVDPlayerVideo.h b/xbmc/cores/dvdplayer/DVDPlayerVideo.h
index 68e5210..80fe782 100644
--- a/xbmc/cores/dvdplayer/DVDPlayerVideo.h
+++ b/xbmc/cores/dvdplayer/DVDPlayerVideo.h
@@ -161,23 +161,6 @@ protected:
 
   bool   m_bFpsInvalid;      // needed to ignore fps (e.g. dvd stills)
 
-  struct SOutputConfiguration
-  {
-    unsigned int width;
-    unsigned int height;
-    unsigned int dwidth;
-    unsigned int dheight;
-    unsigned int color_format;
-    unsigned int extended_format;
-    unsigned int color_matrix : 4;
-    unsigned int color_range  : 1;
-    unsigned int chroma_position;
-    unsigned int color_primaries;
-    unsigned int color_transfer;
-    unsigned int stereo_flags;
-    double       framerate;
-  } m_output; //holds currently configured output
-
   bool m_bAllowFullscreen;
   bool m_bRenderSubs;
 
diff --git a/xbmc/guilib/GUIVideoControl.cpp b/xbmc/guilib/GUIVideoControl.cpp
index 27efb64..a844725 100644
--- a/xbmc/guilib/GUIVideoControl.cpp
+++ b/xbmc/guilib/GUIVideoControl.cpp
@@ -55,7 +55,7 @@ void CGUIVideoControl::Render()
   // don't render if we aren't playing video, or if the renderer isn't started
   // (otherwise the lock we have from CApplication::Render() may clash with the startup
   // locks in the RenderManager.)
-  if (g_application.m_pPlayer->IsPlayingVideo() && g_renderManager.IsStarted())
+  if (g_application.m_pPlayer->IsPlayingVideo() && g_renderManager.IsConfigured())
   {
 #else
   if (g_application.m_pPlayer->IsPlayingVideo())
@@ -101,7 +101,7 @@ void CGUIVideoControl::Render()
 void CGUIVideoControl::RenderEx()
 {
 #ifdef HAS_VIDEO_PLAYBACK
-  if (g_application.m_pPlayer->IsPlayingVideo() && g_renderManager.IsStarted())
+  if (g_application.m_pPlayer->IsPlayingVideo() && g_renderManager.IsConfigured())
     g_renderManager.Render(false, 0, 255, false);
   g_renderManager.FrameFinish();
 #endif
-- 
1.9.1


From e4bcb7b443ca88021d72c248b2574ed9e1f0064b Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Thu, 4 Jun 2015 09:48:31 +0200
Subject: [PATCH 03/21] X11 EGL wip

---
 configure.ac                                       |   3 +
 .../VideoRenderers/HwDecRender/RendererVAAPI.cpp   |   3 -
 .../VideoRenderers/HwDecRender/RendererVDPAU.cpp   |   3 +-
 xbmc/cores/VideoRenderers/LinuxRendererGL.cpp      |  21 +-
 xbmc/cores/VideoRenderers/RenderManager.cpp        |   2 +-
 .../VideoShaders/VideoFilterShader.cpp             |   3 +-
 xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp     | 491 +++++++++++----------
 xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.h       |  48 +-
 xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp     |   4 +-
 xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.h       |   7 +-
 xbmc/guilib/Shader.cpp                             |  48 --
 xbmc/rendering/gl/RenderSystemGL.cpp               |  27 +-
 xbmc/system_gl.h                                   |   4 -
 xbmc/windowing/WinEventsX11.cpp                    |   3 +-
 xbmc/windowing/WindowingFactory.h                  |   7 +-
 xbmc/windowing/X11/GLContext.h                     |  66 +++
 xbmc/windowing/X11/GLContextEGL.cpp                | 367 +++++++++++++++
 xbmc/windowing/X11/GLContextEGL.h                  |  44 ++
 xbmc/windowing/X11/GLContextGLX.cpp                | 309 +++++++++++++
 xbmc/windowing/X11/GLContextGLX.h                  |  49 ++
 xbmc/windowing/X11/Makefile                        |   5 +-
 xbmc/windowing/X11/WinSystemX11.cpp                | 425 +-----------------
 xbmc/windowing/X11/WinSystemX11.h                  |  70 +--
 xbmc/windowing/X11/WinSystemX11GL.cpp              | 221 ----------
 xbmc/windowing/X11/WinSystemX11GL.h                |  60 ---
 xbmc/windowing/X11/WinSystemX11GLContext.cpp       | 188 ++++++++
 xbmc/windowing/X11/WinSystemX11GLContext.h         |  67 +++
 xbmc/windowing/X11/WinSystemX11GLES.cpp            | 107 -----
 xbmc/windowing/X11/WinSystemX11GLES.h              |  50 ---
 xbmc/windowing/windows/WinSystemWin32GL.cpp        |   1 -
 30 files changed, 1444 insertions(+), 1259 deletions(-)
 create mode 100644 xbmc/windowing/X11/GLContext.h
 create mode 100644 xbmc/windowing/X11/GLContextEGL.cpp
 create mode 100644 xbmc/windowing/X11/GLContextEGL.h
 create mode 100644 xbmc/windowing/X11/GLContextGLX.cpp
 create mode 100644 xbmc/windowing/X11/GLContextGLX.h
 delete mode 100644 xbmc/windowing/X11/WinSystemX11GL.cpp
 delete mode 100644 xbmc/windowing/X11/WinSystemX11GL.h
 create mode 100644 xbmc/windowing/X11/WinSystemX11GLContext.cpp
 create mode 100644 xbmc/windowing/X11/WinSystemX11GLContext.h
 delete mode 100644 xbmc/windowing/X11/WinSystemX11GLES.cpp
 delete mode 100644 xbmc/windowing/X11/WinSystemX11GLES.h

diff --git a/configure.ac b/configure.ac
index 56e3734..136189f 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1413,6 +1413,9 @@ if test "$use_x11" = "yes"; then
   PKG_CHECK_MODULES([DRM],  [libdrm],
     [INCLUDES="$INCLUDES $DRM_CFLAGS"; LIBS="$LIBS $DRM_LIBS"],
     AC_MSG_ERROR($missing_library))
+  PKG_CHECK_MODULES([EGL], [egl],
+    [INCLUDES="$INCLUDES $EGL_CFLAGS"; LIBS="$LIBS $EGL_LIBS"],
+    AC_MSG_ERROR($missing_library))
   AC_DEFINE([HAVE_X11], [1], [Define to 1 if you have X11 libs installed.])
 else
   AC_MSG_RESULT($x11_disabled)
diff --git a/xbmc/cores/VideoRenderers/HwDecRender/RendererVAAPI.cpp b/xbmc/cores/VideoRenderers/HwDecRender/RendererVAAPI.cpp
index 2744a5a..a7df758 100644
--- a/xbmc/cores/VideoRenderers/HwDecRender/RendererVAAPI.cpp
+++ b/xbmc/cores/VideoRenderers/HwDecRender/RendererVAAPI.cpp
@@ -228,9 +228,6 @@ bool CRendererVAAPI::UploadTexture(int index)
     return false;
   }
 
-  if (!vaapi->CopyGlx())
-    return false;
-
   plane.id = vaapi->texture;
 
   // in stereoscopic mode sourceRect may only
diff --git a/xbmc/cores/VideoRenderers/HwDecRender/RendererVDPAU.cpp b/xbmc/cores/VideoRenderers/HwDecRender/RendererVDPAU.cpp
index 852f4b1..df69d60 100644
--- a/xbmc/cores/VideoRenderers/HwDecRender/RendererVDPAU.cpp
+++ b/xbmc/cores/VideoRenderers/HwDecRender/RendererVDPAU.cpp
@@ -27,6 +27,7 @@
 #include "settings/AdvancedSettings.h"
 #include "utils/log.h"
 #include "utils/GLUtils.h"
+#include "windowing/WindowingFactory.h"
 
 CRendererVDPAU::CRendererVDPAU()
 {
@@ -78,7 +79,7 @@ bool CRendererVDPAU::Supports(ERENDERFEATURE feature)
 
     return (m_renderMethod & RENDER_GLSL)
         || (m_renderMethod & RENDER_ARB)
-        || ((m_renderMethod & RENDER_SW) && glewIsSupported("GL_ARB_imaging") == GL_TRUE);
+        || ((m_renderMethod & RENDER_SW) && g_Windowing.IsExtSupported("GL_ARB_imaging") == GL_TRUE);
   }
   else if (feature == RENDERFEATURE_NOISE ||
            feature == RENDERFEATURE_SHARPNESS)
diff --git a/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp b/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
index ae7b8a6..31f3a13 100644
--- a/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
+++ b/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
@@ -214,7 +214,8 @@ bool CLinuxRendererGL::ValidateRenderTarget()
 {
   if (!m_bValidated)
   {
-    if (!glewIsSupported("GL_ARB_texture_non_power_of_two") && glewIsSupported("GL_ARB_texture_rectangle"))
+    if (!g_Windowing.IsExtSupported("GL_ARB_texture_non_power_of_two") &&
+         g_Windowing.IsExtSupported("GL_ARB_texture_rectangle"))
     {
       m_textureTarget = GL_TEXTURE_RECTANGLE_ARB;
     }
@@ -279,7 +280,7 @@ bool CLinuxRendererGL::Configure(unsigned int width, unsigned int height, unsign
   m_nonLinStretchGui = false;
   m_pixelRatio       = 1.0;
 
-  m_pboSupported = glewIsSupported("GL_ARB_pixel_buffer_object");
+  m_pboSupported = g_Windowing.IsExtSupported("GL_ARB_pixel_buffer_object");
 
 #ifdef TARGET_DARWIN_OSX
   // on osx 10.9 mavericks we get a strange ripple
@@ -918,7 +919,7 @@ void CLinuxRendererGL::LoadShaders(int field)
       }
       case RENDER_METHOD_ARB:
       // Try ARB shaders if supported and user requested it or GLSL shaders failed.
-      if (glewIsSupported("GL_ARB_fragment_program"))
+      if (g_Windowing.IsExtSupported("GL_ARB_fragment_program"))
       {
         CLog::Log(LOGNOTICE, "GL: ARB shaders support detected");
         m_renderMethod = RENDER_ARB ;
@@ -954,9 +955,9 @@ void CLinuxRendererGL::LoadShaders(int field)
   }
 
   // determine whether GPU supports NPOT textures
-  if (!glewIsSupported("GL_ARB_texture_non_power_of_two"))
+  if (!g_Windowing.IsExtSupported("GL_ARB_texture_non_power_of_two"))
   {
-    if (!glewIsSupported("GL_ARB_texture_rectangle"))
+    if (!g_Windowing.IsExtSupported("GL_ARB_texture_rectangle"))
     {
       CLog::Log(LOGNOTICE, "GL: GL_ARB_texture_rectangle not supported and OpenGL version is not 2.x");
       CLog::Log(LOGNOTICE, "GL: Reverting to POT textures");
@@ -2638,7 +2639,7 @@ bool CLinuxRendererGL::UploadRGBTexture(int source)
   if (imaging==-1)
   {
     imaging = 0;
-    if (glewIsSupported("GL_ARB_imaging"))
+    if (g_Windowing.IsExtSupported("GL_ARB_imaging"))
     {
       CLog::Log(LOGINFO, "GL: ARB Imaging extension supported");
       imaging = 1;
@@ -2752,14 +2753,14 @@ bool CLinuxRendererGL::Supports(ERENDERFEATURE feature)
   {
     return (m_renderMethod & RENDER_GLSL)
         || (m_renderMethod & RENDER_ARB)
-        || ((m_renderMethod & RENDER_SW) && glewIsSupported("GL_ARB_imaging") == GL_TRUE);
+        || ((m_renderMethod & RENDER_SW) && g_Windowing.IsExtSupported("GL_ARB_imaging") == GL_TRUE);
   }
   
   if(feature == RENDERFEATURE_CONTRAST)
   {
     return (m_renderMethod & RENDER_GLSL)
         || (m_renderMethod & RENDER_ARB)
-        || ((m_renderMethod & RENDER_SW) && glewIsSupported("GL_ARB_imaging") == GL_TRUE);
+        || ((m_renderMethod & RENDER_SW) && g_Windowing.IsExtSupported("GL_ARB_imaging") == GL_TRUE);
   }
 
   if(feature == RENDERFEATURE_GAMMA)
@@ -2792,7 +2793,7 @@ bool CLinuxRendererGL::Supports(ERENDERFEATURE feature)
 
 bool CLinuxRendererGL::SupportsMultiPassRendering()
 {
-  return glewIsSupported("GL_EXT_framebuffer_object") && glCreateProgram;
+  return g_Windowing.IsExtSupported("GL_EXT_framebuffer_object") && glCreateProgram;
 }
 
 bool CLinuxRendererGL::Supports(EDEINTERLACEMODE mode)
@@ -2857,7 +2858,7 @@ bool CLinuxRendererGL::Supports(ESCALINGMETHOD method)
     if (scaleX < minScale && scaleY < minScale)
       return false;
 
-    if (glewIsSupported("GL_EXT_framebuffer_object") && (m_renderMethod & RENDER_GLSL))
+    if (g_Windowing.IsExtSupported("GL_EXT_framebuffer_object") && (m_renderMethod & RENDER_GLSL))
     {
       // spline36 and lanczos3 are only allowed through advancedsettings.xml
       if(method != VS_SCALINGMETHOD_SPLINE36
diff --git a/xbmc/cores/VideoRenderers/RenderManager.cpp b/xbmc/cores/VideoRenderers/RenderManager.cpp
index 098556d..8122f77 100644
--- a/xbmc/cores/VideoRenderers/RenderManager.cpp
+++ b/xbmc/cores/VideoRenderers/RenderManager.cpp
@@ -1067,7 +1067,7 @@ void CXBMCRenderManager::UpdateDisplayLatency()
   if (g_graphicsContext.GetVideoResolution() == RES_WINDOW)
     refresh = 0; // No idea about refresh rate when windowed, just get the default latency
   m_displayLatency = (double) g_advancedSettings.GetDisplayLatency(refresh);
-  CLog::Log(LOGDEBUG, "CRenderManager::UpdateDisplayLatency - Latency set to %1.0f msec", m_displayLatency * 1000.0f);
+  //CLog::Log(LOGDEBUG, "CRenderManager::UpdateDisplayLatency - Latency set to %1.0f msec", m_displayLatency * 1000.0f);
 }
 
 void CXBMCRenderManager::UpdateResolution()
diff --git a/xbmc/cores/VideoRenderers/VideoShaders/VideoFilterShader.cpp b/xbmc/cores/VideoRenderers/VideoShaders/VideoFilterShader.cpp
index 8c2c3e0..deb5173 100644
--- a/xbmc/cores/VideoRenderers/VideoShaders/VideoFilterShader.cpp
+++ b/xbmc/cores/VideoRenderers/VideoShaders/VideoFilterShader.cpp
@@ -29,6 +29,7 @@
 #include "utils/log.h"
 #include "utils/GLUtils.h"
 #include "ConvolutionKernels.h"
+#include "windowing/WindowingFactory.h"
 
 #if defined(HAS_GL)
   #define USE1DTEXTURE
@@ -86,7 +87,7 @@ ConvolutionFilterShader::ConvolutionFilterShader(ESCALINGMETHOD method, bool str
   string defines;
 
 #if defined(HAS_GL)
-  m_floattex = glewIsSupported("GL_ARB_texture_float");
+  m_floattex = g_Windowing.IsExtSupported("GL_ARB_texture_float");
 #elif HAS_GLES == 2
   m_floattex = false;
 #endif
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp
index 1b66c84..2df8889 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp
@@ -19,8 +19,8 @@
  */
 #include "system.h"
 #ifdef HAVE_LIBVA
-#include "windowing/WindowingFactory.h"
 #include "VAAPI.h"
+#include "windowing/WindowingFactory.h"
 #include "DVDVideoCodec.h"
 #include "cores/dvdplayer/DVDCodecs/DVDCodecUtils.h"
 #include "cores/dvdplayer/DVDClock.h"
@@ -32,6 +32,8 @@
 #include "settings/MediaSettings.h"
 #include "settings/AdvancedSettings.h"
 #include <va/va_x11.h>
+#include <va/va_drmcommon.h>
+#include <drm_fourcc.h>
 
 extern "C" {
 #include "libavutil/avutil.h"
@@ -40,11 +42,6 @@ extern "C" {
 #include "libavfilter/buffersrc.h"
 }
 
-#ifndef VA_SURFACE_ATTRIB_SETTABLE
-#define vaCreateSurfaces(d, f, w, h, s, ns, a, na) \
-vaCreateSurfaces(d, w, h, f, ns, s)
-#endif
-
 #if VA_CHECK_VERSION(0,34,0)
 #include <va/va_vpp.h>
 #define HAVE_VPP 1
@@ -1180,92 +1177,165 @@ void CVaapiRenderPicture::ReturnUnused()
     vaapi->ReturnRenderPicture(this);
 }
 
-bool CVaapiRenderPicture::CopyGlx()
+void CVaapiRenderPicture::Sync()
 {
+#ifdef GL_ARB_sync
   CSingleLock lock(renderPicSection);
-
-  if (glx.bound == true)
-    return true;
-
-  if (glx.procPic.source == CVaapiProcessedPicture::SKIP_SRC ||
-      glx.procPic.source == CVaapiProcessedPicture::VPP_SRC)
+  if (usefence)
   {
-    unsigned int colorStandard;
-    switch(glx.procPic.DVDPic.color_matrix)
+    if(glIsSync(fence))
     {
-      case AVCOL_SPC_BT709:
-        colorStandard = VA_SRC_BT709;
-        break;
-      case AVCOL_SPC_BT470BG:
-      case AVCOL_SPC_SMPTE170M:
-        colorStandard = VA_SRC_BT601;
-        break;
-      case AVCOL_SPC_SMPTE240M:
-      case AVCOL_SPC_FCC:
-      case AVCOL_SPC_UNSPECIFIED:
-      case AVCOL_SPC_RGB:
-      default:
-        if(texWidth > 1000)
-          colorStandard = VA_SRC_BT709;
-        else
-          colorStandard = VA_SRC_BT601;
+      glDeleteSync(fence);
+      fence = None;
     }
+    fence = glFenceSync(GL_SYNC_GPU_COMMANDS_COMPLETE, 0);
+  }
+#endif
+}
 
-    if (vaSyncSurface(glx.vadsp, glx.procPic.videoSurface) != VA_STATUS_SUCCESS)
-      return false;
+bool CVaapiRenderPicture::GLMapSurface()
+{
+  VAStatus status;
+  glInterop.vaImage.image_id = VA_INVALID_ID;
 
-    if (vaPutSurface(glx.vadsp,
-                     glx.procPic.videoSurface,
-                     glx.pixmap,
-                     0,0,
-                     texWidth, texHeight,
-                     0,0,
-                     texWidth, texHeight,
-                     NULL,0,
-                     VA_FRAME_PICTURE | colorStandard) != VA_STATUS_SUCCESS)
-    {
-      return false;
+  vaSyncSurface(glInterop.vadsp, glInterop.procPic.videoSurface);
+
+  status = vaDeriveImage(glInterop.vadsp, glInterop.procPic.videoSurface,
+                                                  &glInterop.vaImage);
+  if (status != VA_STATUS_SUCCESS)
+  {
+    CLog::Log(LOGERROR, "VAAPI::%s - Error: %s(%d)", __FUNCTION__, vaErrorStr(status), status);
+    return false;
+  }
+  memset(&glInterop.vBufInfo, 0, sizeof(glInterop.vBufInfo));
+  glInterop.vBufInfo.mem_type = VA_SURFACE_ATTRIB_MEM_TYPE_KERNEL_DRM; //VA_SURFACE_ATTRIB_MEM_TYPE_DRM_PRIME;
+  status = vaAcquireBufferHandle(glInterop.vadsp, glInterop.vaImage.buf,
+                                 &glInterop.vBufInfo);
+  if (status != VA_STATUS_SUCCESS)
+  {
+    CLog::Log(LOGERROR, "VAAPI::%s - Error: %s(%d)", __FUNCTION__, vaErrorStr(status), status);
+    return false;
+  }
+
+  EGLImageKHR image;
+  GLint attribs[23], *attrib;
+
+  switch (glInterop.vaImage.format.fourcc)
+  {
+    case VA_FOURCC('N','V','1','2'):
+    {
+      attrib = attribs;
+      *attrib++ = EGL_LINUX_DRM_FOURCC_EXT;
+      *attrib++ = fourcc_code('R','8',' ',' ');
+      *attrib++ = EGL_WIDTH;
+      *attrib++ = glInterop.vaImage.width / 4;
+      *attrib++ = EGL_HEIGHT;
+      *attrib++ = glInterop.vaImage.height;
+      *attrib++ = EGL_DMA_BUF_PLANE0_FD_EXT;
+      *attrib++ = (intptr_t)glInterop.vBufInfo.handle;
+      *attrib++ = EGL_DMA_BUF_PLANE0_OFFSET_EXT;
+      *attrib++ = glInterop.vaImage.offsets[0];
+      *attrib++ = EGL_DMA_BUF_PLANE0_PITCH_EXT;
+      *attrib++ = glInterop.vaImage.pitches[0];
+      *attrib++ = EGL_NONE;
+      glInterop.eglImage = glInterop.eglCreateImageKHR(glInterop.eglDisplay,
+                                          EGL_NO_CONTEXT, EGL_LINUX_DMA_BUF_EXT, (EGLClientBuffer)NULL,
+                                          attribs);
+      if (!glInterop.eglImage)
+      {
+        EGLint err = eglGetError();
+        CLog::Log(LOGERROR, "failed to import VA buffer NV12 into EGL image");
+        return false;
+      }
+      break;
     }
+    case VA_FOURCC('R','G','B','A'):
+    case VA_FOURCC('B','G','R','A'):
+    {
+//      attrib = attribs;
+//      *attrib++ = EGL_LINUX_DRM_FOURCC_EXT;
+//      *attrib++ = DRM_FORMAT_ABGR8888;
+//      *attrib++ = EGL_WIDTH;
+//      *attrib++ = glInterop.vaImage.width;
+//      *attrib++ = EGL_HEIGHT;
+//      *attrib++ = glInterop.vaImage.height;
+//      *attrib++ = EGL_DMA_BUF_PLANE0_FD_EXT;
+//      *attrib++ = (intptr_t)glInterop.vBufInfo.handle;
+//      *attrib++ = EGL_DMA_BUF_PLANE0_OFFSET_EXT;
+//      *attrib++ = glInterop.vaImage.offsets[0];
+//      *attrib++ = EGL_DMA_BUF_PLANE0_PITCH_EXT;
+//      *attrib++ = glInterop.vaImage.pitches[0];
+//      *attrib++ = EGL_NONE;
+//      glInterop.eglImage = glInterop.eglCreateImageKHR(eglDisplay,
+//                                          EGL_NO_CONTEXT, EGL_LINUX_DMA_BUF_EXT, (EGLClientBuffer)NULL,
+//                                          attribs);
+
+      attrib = attribs;
+      *attrib++ = EGL_DRM_BUFFER_FORMAT_MESA;
+      *attrib++ = EGL_DRM_BUFFER_FORMAT_ARGB32_MESA;
+      *attrib++ = EGL_WIDTH;
+      *attrib++ = glInterop.vaImage.width;
+      *attrib++ = EGL_HEIGHT;
+      *attrib++ = glInterop.vaImage.height;
+      *attrib++ = EGL_DRM_BUFFER_STRIDE_MESA;
+      *attrib++ = glInterop.vaImage.pitches[0] / 4;
+      *attrib++ = EGL_NONE;
+      glInterop.eglImage = glInterop.eglCreateImageKHR(glInterop.eglDisplay, EGL_NO_CONTEXT,
+                                         EGL_DRM_BUFFER_MESA,
+                                         (EGLClientBuffer)glInterop.vBufInfo.handle,
+                                         attribs);
+      if (!glInterop.eglImage)
+      {
+        EGLint err = eglGetError();
+        CLog::Log(LOGERROR, "failed to import VA buffer NV12 into EGL image");
+        return false;
+      }
+      break;
+    }
+    default:
+      return false;
+  }
 
-    XSync(glx.x11dsp, false);
-    glEnable(glx.textureTarget);
-    glBindTexture(glx.textureTarget, texture);
-    glx.glXBindTexImageEXT(glx.x11dsp, glx.glPixmap, GLX_FRONT_LEFT_EXT, NULL);
-    glBindTexture(glx.textureTarget, 0);
-    glDisable(glx.textureTarget);
+  GLint format;
 
-    glx.bound = true;
+  glGenTextures(1, &texture);
+  glEnable(glInterop.textureTarget);
+  glBindTexture(glInterop.textureTarget, texture);
+  glTexParameteri(glInterop.textureTarget, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+  glTexParameteri(glInterop.textureTarget, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+  glTexParameteri(glInterop.textureTarget, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+  glTexParameteri(glInterop.textureTarget, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
 
-    vaapi->ReturnProcPicture(glx.procPic.id);
-    glx.procPic.id = -1;
-  }
+  glInterop.glEGLImageTargetTexture2DOES(glInterop.textureTarget, glInterop.eglImage);
+
+  glGetIntegerv(GL_IMPLEMENTATION_COLOR_READ_FORMAT, &format);
+  glBindTexture(glInterop.textureTarget, 0);
+  glDisable(glInterop.textureTarget);
 
   return true;
 }
 
-void CVaapiRenderPicture::Sync()
+void CVaapiRenderPicture::GLUnMapSurface()
 {
-#ifdef GL_ARB_sync
-  CSingleLock lock(renderPicSection);
-  if (usefence)
+  if (glInterop.vaImage.image_id == VA_INVALID_ID)
+    return;
+
+  VAStatus status;
+  status = vaReleaseBufferHandle(glInterop.vadsp, glInterop.vaImage.buf);
+  if (status != VA_STATUS_SUCCESS)
   {
-    if(glIsSync(fence))
-    {
-      glDeleteSync(fence);
-      fence = None;
-    }
-    fence = glFenceSync(GL_SYNC_GPU_COMMANDS_COMPLETE, 0);
+    CLog::Log(LOGERROR, "VAAPI::%s - Error: %s(%d)", __FUNCTION__, vaErrorStr(status), status);
   }
-#endif
 
-  if (DVDPic.format == RENDER_FMT_VAAPI && glx.bound)
+  status = vaDestroyImage(glInterop.vadsp, glInterop.vaImage.image_id);
+  if (status != VA_STATUS_SUCCESS)
   {
-    glEnable(glx.textureTarget);
-    glBindTexture(glx.textureTarget, texture);
-    glx.glXReleaseTexImageEXT(glx.x11dsp, glx.glPixmap, GLX_FRONT_LEFT_EXT);
-    glBindTexture(glx.textureTarget, 0);
-    glDisable(glx.textureTarget);
+    CLog::Log(LOGERROR, "VAAPI::%s - Error: %s(%d)", __FUNCTION__, vaErrorStr(status), status);
   }
+  glInterop.mapped = false;
+  glInterop.vaImage.image_id = VA_INVALID_ID;
+
+  glDeleteTextures(1, &texture);
 }
 
 //-----------------------------------------------------------------------------
@@ -1623,7 +1693,6 @@ void COutput::StateMachine(int signal, Protocol *port, Message *msg)
             m_config.stats->DecProcessed();
             m_bufferPool.processedPics.pop_front();
             outPic = ProcessPicture(procPic);
-            //ReleaseProcessedPicture(procPic);
             if (outPic)
             {
               m_config.stats->IncRender();
@@ -1726,7 +1795,7 @@ void COutput::Process()
 
 bool COutput::Init()
 {
-  if (!CreateGlxContext())
+  if (!CreateEGLContext())
     return false;
 
   if (!GLInit())
@@ -1759,7 +1828,7 @@ bool COutput::Uninit()
   ReleaseBufferPool();
   delete m_pp;
   m_pp = NULL;
-  DestroyGlxContext();
+  DestroyEGLContext();
   return true;
 }
 
@@ -1924,10 +1993,14 @@ void COutput::InitCycle()
       if (!CSettings::Get().GetBool("videoplayer.prefervaapirender"))
         m_pp = new CFFmpegPostproc();
       else
-        m_pp = new CSkipPostproc();
+      {
+        m_pp = new CVppPostproc();
+        m_config.stats->SetVpp(true);
+      }
       if (m_pp->PreInit(m_config))
       {
         m_pp->Init(method);
+        m_currentDiMethod = method;
       }
       else
       {
@@ -1957,8 +2030,9 @@ CVaapiRenderPicture* COutput::ProcessPicture(CVaapiProcessedPicture &pic)
     pic.id = m_bufferPool.procPicId++;
     m_bufferPool.processedPicsAway.push_back(pic);
     retPic->DVDPic.format = RENDER_FMT_VAAPI;
-    retPic->glx.procPic = pic;
-    retPic->glx.bound = false;
+    retPic->glInterop.procPic = pic;
+    retPic->glInterop.mapped = false;
+    retPic->GLMapSurface();
   }
   else if (pic.source == CVaapiProcessedPicture::FFMPEG_SRC)
   {
@@ -2131,7 +2205,8 @@ void COutput::ProcessReturnPicture(CVaapiRenderPicture *pic)
   if (pic->avFrame)
     av_frame_unref(pic->avFrame);
 
-  ProcessReturnProcPicture(pic->glx.procPic.id);
+  pic->GLUnMapSurface();
+  ProcessReturnProcPicture(pic->glInterop.procPic.id);
   pic->valid = false;
 }
 
@@ -2154,70 +2229,19 @@ bool COutput::EnsureBufferPool()
   int fbConfigIndex = 0;
   int num;
 
-  XWindowAttributes wndattribs;
-  XGetWindowAttributes(m_Display, g_Windowing.GetWindow(), &wndattribs);
-
-  int doubleVisAttributes[] = {
-      GLX_RENDER_TYPE, GLX_RGBA_BIT,
-      GLX_RED_SIZE, 8,
-      GLX_GREEN_SIZE, 8,
-      GLX_BLUE_SIZE, 8,
-      GLX_ALPHA_SIZE, 8,
-      GLX_DEPTH_SIZE, 8,
-      GLX_DRAWABLE_TYPE, GLX_PIXMAP_BIT,
-      GLX_BIND_TO_TEXTURE_RGBA_EXT, True,
-      GLX_DOUBLEBUFFER, False,
-      GLX_Y_INVERTED_EXT, True,
-      GLX_X_RENDERABLE, True,
-      None};
-
-  int pixmapAttribs[] = {
-      GLX_TEXTURE_TARGET_EXT, GLX_TEXTURE_2D_EXT,
-      GLX_TEXTURE_FORMAT_EXT, GLX_TEXTURE_FORMAT_RGBA_EXT,
-      None};
-
-  GLXFBConfig *fbConfigs;
-  fbConfigs = glXChooseFBConfig(m_Display, g_Windowing.GetCurrentScreen(), doubleVisAttributes, &num);
-  if (fbConfigs==NULL)
-  {
-    CLog::Log(LOGERROR, "VAAPI::EnsureBufferPool - No compatible framebuffers found");
-    return false;
-  }
-
-  fbConfigIndex = 0;
-
-  // create glx surfaces and avFrames
+  // create avFrames and init interop
   CVaapiRenderPicture *pic;
   for (unsigned int i = 0; i < m_bufferPool.allRenderPics.size(); i++)
   {
     pic = m_bufferPool.allRenderPics[i];
+    pic->glInterop.vadsp = m_config.dpy;
 
-    pic->glx.pixmap = XCreatePixmap(m_Display,
-                                m_Window,
-                                m_config.outWidth,
-                                m_config.outHeight,
-                                wndattribs.depth);
-    if (!pic->glx.pixmap)
-    {
-      CLog::Log(LOGERROR, "VAAPI::COutput::EnsureBufferPool - Unable to create XPixmap");
-      return false;
-    }
-
-    // create gl pixmap
-    pic->glx.glPixmap = glXCreatePixmap(m_Display, fbConfigs[fbConfigIndex], pic->glx.pixmap, pixmapAttribs);
-
-    if (!pic->glx.glPixmap)
-    {
-      CLog::Log(LOGERROR, "VAAPI::COutput::EnsureBufferPool - Could not create glPixmap");
-      return false;
-    }
-
-    glGenTextures(1, &pic->texture);
-    pic->glx.vadsp = m_config.dpy;
-    pic->glx.x11dsp = m_Display;
-    pic->glx.glXBindTexImageEXT = glXBindTexImageEXT;
-    pic->glx.glXReleaseTexImageEXT = glXReleaseTexImageEXT;
-    pic->glx.textureTarget = m_textureTarget;
+    pic->glInterop.eglDisplay = m_eglDisplay;
+    pic->glInterop.textureTarget = m_textureTarget;
+    pic->glInterop.eglCreateImageKHR = eglCreateImageKHR;
+    pic->glInterop.glEGLImageTargetTexture2DOES = glEGLImageTargetTexture2DOES;
+    pic->glInterop.vaImage.image_id = VA_INVALID_ID;
+    pic->glInterop.mapped = false;
 
     pic->avFrame = av_frame_alloc();
     pic->valid = false;
@@ -2283,8 +2307,6 @@ void COutput::ReleaseBufferPool(bool precleanup)
     if (pic->texture)
     {
       glDeleteTextures(1, &pic->texture);
-      glXDestroyPixmap(m_Display, pic->glx.glPixmap);
-      XFreePixmap(m_Display, pic->glx.pixmap);
       pic->texture = None;
     }
     av_frame_free(&pic->avFrame);
@@ -2307,22 +2329,23 @@ void COutput::ReleaseBufferPool(bool precleanup)
 bool COutput::GLInit()
 {
 #ifdef GL_ARB_sync
-  bool hasfence = glewIsSupported("GL_ARB_sync");
+  bool hasfence = g_Windowing.IsExtSupported("GL_ARB_sync");
   for (unsigned int i = 0; i < m_bufferPool.allRenderPics.size(); i++)
   {
     m_bufferPool.allRenderPics[i]->usefence = hasfence;
   }
 #endif
 
-  if (!glewIsSupported("GL_ARB_texture_non_power_of_two") && glewIsSupported("GL_ARB_texture_rectangle"))
+  if (!g_Windowing.IsExtSupported("GL_ARB_texture_non_power_of_two") &&
+       g_Windowing.IsExtSupported("GL_ARB_texture_rectangle"))
   {
     m_textureTarget = GL_TEXTURE_RECTANGLE_ARB;
   }
   else
     m_textureTarget = GL_TEXTURE_2D;
 
-  glXBindTexImageEXT = (PFNGLXBINDTEXIMAGEEXTPROC)glXGetProcAddress((GLubyte *) "glXBindTexImageEXT");
-  glXReleaseTexImageEXT = (PFNGLXRELEASETEXIMAGEEXTPROC)glXGetProcAddress((GLubyte *) "glXReleaseTexImageEXT");
+  eglCreateImageKHR = (PFNEGLCREATEIMAGEKHRPROC)eglGetProcAddress("eglCreateImageKHR");
+  glEGLImageTargetTexture2DOES = (PFNGLEGLIMAGETARGETTEXTURE2DOESPROC)eglGetProcAddress("glEGLImageTargetTexture2DOES");
   return true;
 }
 
@@ -2337,80 +2360,58 @@ bool COutput::CheckSuccess(VAStatus status)
   return true;
 }
 
-bool COutput::CreateGlxContext()
+bool COutput::CreateEGLContext()
 {
-  GLXContext   glContext;
-
   m_Display = g_Windowing.GetDisplay();
-  glContext = g_Windowing.GetGlxContext();
-  m_Window = g_Windowing.GetWindow();
-
-  // Get our window attribs.
-  XWindowAttributes wndattribs;
-  XGetWindowAttributes(m_Display, m_Window, &wndattribs);
-
-  // Get visual Info
-  XVisualInfo visInfo;
-  visInfo.visualid = wndattribs.visual->visualid;
-  int nvisuals = 0;
-  XVisualInfo* visuals = XGetVisualInfo(m_Display, VisualIDMask, &visInfo, &nvisuals);
-  if (nvisuals != 1)
-  {
-    CLog::Log(LOGERROR, "VAAPI::COutput::CreateGlxContext - could not find visual");
+  EGLDisplay eglDisplay = g_Windowing.GetEGLDisplay();
+  EGLContext eglMainContext = g_Windowing.GetEGLContext();
+  EGLConfig eglMainConfig = g_Windowing.GetEGLConfig();
+
+  EGLint pbufferAttribs[] =
+  {
+    EGL_WIDTH, 8,
+    EGL_HEIGHT, 8,
+    EGL_TEXTURE_TARGET, EGL_NO_TEXTURE,
+    EGL_TEXTURE_FORMAT, EGL_NO_TEXTURE,
+    EGL_NONE
+  };
+  EGLint contextAttributes[] =
+  {
+    EGL_CONTEXT_CLIENT_VERSION, 2,
+    EGL_NONE
+  };
+  if (!eglBindAPI(EGL_OPENGL_API))
+  {
+    CLog::Log(LOGERROR, "VAAPI::COutput::CreateEGLContext -failed to bind egl API");
     return false;
   }
-  visInfo = visuals[0];
-  XFree(visuals);
+  m_eglSurface = eglCreatePbufferSurface(eglDisplay, eglMainConfig, pbufferAttribs);
+  m_eglContext = eglCreateContext(eglDisplay, eglMainConfig, eglMainContext, contextAttributes);
+  m_eglDisplay = eglDisplay;
 
-  m_pixmap = XCreatePixmap(m_Display,
-                           m_Window,
-                           192,
-                           108,
-                           visInfo.depth);
-  if (!m_pixmap)
+  if (!eglMakeCurrent(eglDisplay, m_eglSurface, m_eglSurface, m_eglContext))
   {
-    CLog::Log(LOGERROR, "VAAPI::COutput::CreateGlxContext - Unable to create XPixmap");
-    return false;
-  }
-
-  // create gl pixmap
-  m_glPixmap = glXCreateGLXPixmap(m_Display, &visInfo, m_pixmap);
-
-  if (!m_glPixmap)
-  {
-    CLog::Log(LOGERROR, "VAAPI::COutput::CreateGlxContext - Could not create glPixmap");
-    return false;
-  }
-
-  m_glContext = glXCreateContext(m_Display, &visInfo, glContext, True);
-
-  if (!glXMakeCurrent(m_Display, m_glPixmap, m_glContext))
-  {
-    CLog::Log(LOGERROR, "VAAPI::COutput::CreateGlxContext - Could not make Pixmap current");
+    CLog::Log(LOGERROR, "VAAPI::COutput::CreateEGLContext - Could not make surface current");
     return false;
   }
   if (g_advancedSettings.CanLogComponent(LOGVIDEO))
-    CLog::Log(LOGDEBUG, "VAAPI::COutput::CreateGlxContext - created context");
+    CLog::Log(LOGDEBUG, "VAAPI::COutput::CreateEGLContext - created context");
   return true;
 }
 
-bool COutput::DestroyGlxContext()
+bool COutput::DestroyEGLContext()
 {
-  if (m_glContext)
+  if (m_eglContext)
   {
     glFinish();
-    glXMakeCurrent(m_Display, None, NULL);
-    glXDestroyContext(m_Display, m_glContext);
+    eglMakeCurrent(m_eglContext, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
+    eglDestroyContext(m_eglDisplay, m_eglContext);
   }
-  m_glContext = 0;
+  m_eglContext = EGL_NO_CONTEXT;
 
-  if (m_glPixmap)
-    glXDestroyPixmap(m_Display, m_glPixmap);
-  m_glPixmap = 0;
-
-  if (m_pixmap)
-    XFreePixmap(m_Display, m_pixmap);
-  m_pixmap = 0;
+  if (m_eglSurface)
+    eglDestroySurface(m_eglDisplay, m_eglSurface);
+  m_eglSurface = EGL_NO_SURFACE;
 
   return true;
 }
@@ -2507,16 +2508,27 @@ bool CVppPostproc::PreInit(CVaapiConfig &config, SDiMethods *methods)
     return false;
   }
 
+//  VASurfaceAttrib attr[10];
+//  unsigned int num;
+//  vaQuerySurfaceAttributes(m_config.dpy, m_configId, attr, &num);
+
+  VASurfaceAttrib attribs[1], *attrib;
+  attrib = attribs;
+  attrib->flags = VA_SURFACE_ATTRIB_SETTABLE;
+  attrib->type = VASurfaceAttribPixelFormat;
+  attrib->value.type = VAGenericValueTypeInteger;
+  attrib->value.value.i = VA_FOURCC_BGRA;
+
   // create surfaces
   VASurfaceID surfaces[32];
   int nb_surfaces = NUM_RENDER_PICS;
   if (!CheckSuccess(vaCreateSurfaces(m_config.dpy,
-                                     VA_RT_FORMAT_YUV420,
+                                     VA_RT_FORMAT_RGB32,
                                      m_config.surfaceWidth,
                                      m_config.surfaceHeight,
                                      surfaces,
                                      nb_surfaces,
-                                     NULL, 0)))
+                                     attribs, 1)))
   {
     if (g_advancedSettings.CanLogComponent(LOGVIDEO))
       CLog::Log(LOGDEBUG, "CVppPostproc::PreInit  - VPP init failed");
@@ -2618,10 +2630,21 @@ bool CVppPostproc::Init(EINTERLACEMETHOD method)
   case VS_INTERLACEMETHOD_VAAPI_MACI:
     vppMethod = VAProcDeinterlacingMotionCompensated;
     break;
+  case VS_INTERLACEMETHOD_NONE:
+    vppMethod = VAProcDeinterlacingNone;
+    break;
   default:
     return false;
   }
 
+  m_forwardRefs = 0;
+  m_backwardRefs = 0;
+  m_currentIdx = 0;
+  m_frameCount = 0;
+
+  if (method == VS_INTERLACEMETHOD_NONE)
+    return true;
+
   VAProcFilterParameterBufferDeinterlacing filterparams;
   filterparams.type = VAProcFilterDeinterlacing;
   filterparams.algorithm = vppMethod;
@@ -2644,8 +2667,6 @@ bool CVppPostproc::Init(EINTERLACEMETHOD method)
 
   m_forwardRefs = pplCaps.num_forward_references;
   m_backwardRefs = pplCaps.num_backward_references;
-  m_currentIdx = 0;
-  m_frameCount = 0;
 
 #endif
   return true;
@@ -2738,7 +2759,8 @@ bool CVppPostproc::Filter(CVaapiProcessedPicture &outPic)
   outPic.DVDPic = it->DVDPic;
 
   // skip deinterlacing cycle if requested
-  if (m_step == 1 && (outPic.DVDPic.iFlags & DVD_CODEC_CTRL_SKIPDEINT))
+  if ((m_step == 1) &&
+      ((outPic.DVDPic.iFlags & DVD_CODEC_CTRL_SKIPDEINT) || (m_vppMethod == VS_INTERLACEMETHOD_NONE)))
   {
     Advance();
     return false;
@@ -2789,36 +2811,44 @@ bool CVppPostproc::Filter(CVaapiProcessedPicture &outPic)
   int curPic = m_currentIdx;
 
   // deinterlace flag
-  unsigned int flags = 0;
-  if (it->DVDPic.iFlags & DVP_FLAG_TOP_FIELD_FIRST)
-    flags = 0;
-  else
-    flags = VA_DEINTERLACING_BOTTOM_FIELD_FIRST | VA_DEINTERLACING_BOTTOM_FIELD;
-
-  if (m_step)
+  if (m_vppMethod != VS_INTERLACEMETHOD_NONE)
   {
-    if (flags & VA_DEINTERLACING_BOTTOM_FIELD)
-      flags &= ~VA_DEINTERLACING_BOTTOM_FIELD;
+    unsigned int flags = 0;
+    if (it->DVDPic.iFlags & DVP_FLAG_TOP_FIELD_FIRST)
+      flags = 0;
     else
-      flags |= VA_DEINTERLACING_BOTTOM_FIELD;
-  }
-  if (!CheckSuccess(vaMapBuffer(m_config.dpy, m_filter, (void**)&filterParams)))
-  {
-    return false;
+      flags = VA_DEINTERLACING_BOTTOM_FIELD_FIRST | VA_DEINTERLACING_BOTTOM_FIELD;
+
+    if (m_step)
+    {
+      if (flags & VA_DEINTERLACING_BOTTOM_FIELD)
+        flags &= ~VA_DEINTERLACING_BOTTOM_FIELD;
+      else
+        flags |= VA_DEINTERLACING_BOTTOM_FIELD;
+    }
+    if (!CheckSuccess(vaMapBuffer(m_config.dpy, m_filter, (void**)&filterParams)))
+    {
+      return false;
+    }
+    filterParams->flags = flags;
+    if (!CheckSuccess(vaUnmapBuffer(m_config.dpy, m_filter)))
+    {
+      return false;
+    }
+
+    if (m_vppMethod == VS_INTERLACEMETHOD_VAAPI_BOB)
+      pipelineParams->filter_flags = (flags & VA_DEINTERLACING_BOTTOM_FIELD) ? VA_BOTTOM_FIELD : VA_TOP_FIELD;
+    else
+      pipelineParams->filter_flags = 0;
+
+    pipelineParams->filters = &m_filter;
+    pipelineParams->num_filters = 1;
   }
-  filterParams->flags = flags;
-  if (!CheckSuccess(vaUnmapBuffer(m_config.dpy, m_filter)))
+  else
   {
-    return false;
+    pipelineParams->num_filters = 0;
   }
 
-  if (m_vppMethod == VS_INTERLACEMETHOD_VAAPI_BOB)
-    pipelineParams->filter_flags = (flags & VA_DEINTERLACING_BOTTOM_FIELD) ? VA_BOTTOM_FIELD : VA_TOP_FIELD;
-  else
-    pipelineParams->filter_flags = 0;
-  pipelineParams->filters = &m_filter;
-  pipelineParams->num_filters = 1;
-
   // references
   double ptsLast = DVD_NOPTS_VALUE;
   double pts = DVD_NOPTS_VALUE;
@@ -2927,7 +2957,8 @@ bool CVppPostproc::Compatible(EINTERLACEMETHOD method)
 {
   if (method == VS_INTERLACEMETHOD_VAAPI_BOB ||
       method == VS_INTERLACEMETHOD_VAAPI_MADI ||
-      method == VS_INTERLACEMETHOD_VAAPI_MACI)
+      method == VS_INTERLACEMETHOD_VAAPI_MACI ||
+      method == VS_INTERLACEMETHOD_NONE)
     return true;
 
   return false;
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.h
index a1a9a16..a257b11 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.h
@@ -20,8 +20,8 @@
 #pragma once
 
 #include "system_gl.h"
-#define GLX_GLXEXT_PROTOTYPES
-#include <GL/glx.h>
+#include <EGL/egl.h>
+#include <EGL/eglext.h>
 
 #include "DVDVideoCodec.h"
 #include "DVDVideoCodecFFmpeg.h"
@@ -33,6 +33,7 @@
 #include "threads/Event.h"
 #include "threads/Thread.h"
 #include "utils/ActorProtocol.h"
+#include "guilib/Geometry.h"
 #include <list>
 #include <map>
 #include <memory>
@@ -118,7 +119,6 @@ struct CVaapiConfig
   int upscale;
   CVideoSurfaces *videoSurfaces;
   uint32_t maxReferences;
-  bool useInteropYuv;
   CVAAPIContext *context;
   VADisplay dpy;
   VAProfile profile;
@@ -155,17 +155,21 @@ struct CVaapiProcessedPicture
   bool crop;
 };
 
-struct VaapiGlx
+/**
+ *
+ */
+struct CVaapiGLSurface
 {
-  Display *x11dsp;
+  CVaapiProcessedPicture procPic;
   VADisplay vadsp;
-  Pixmap pixmap;
-  GLXPixmap glPixmap;
+  VAImage vaImage;
+  VABufferInfo vBufInfo;
+  EGLImageKHR eglImage;
   GLenum textureTarget;
-  PFNGLXBINDTEXIMAGEEXTPROC glXBindTexImageEXT;
-  PFNGLXRELEASETEXIMAGEEXTPROC glXReleaseTexImageEXT;
-  CVaapiProcessedPicture procPic;
-  bool bound;
+  EGLDisplay eglDisplay;
+  PFNEGLCREATEIMAGEKHRPROC eglCreateImageKHR;
+  PFNGLEGLIMAGETARGETTEXTURE2DOESPROC glEGLImageTargetTexture2DOES;
+  bool mapped;
 };
 
 /**
@@ -183,11 +187,11 @@ public:
     : texWidth(0), texHeight(0), texture(None), valid(false), vaapi(NULL), avFrame(NULL),
       usefence(false), refCount(0), renderPicSection(section) { fence = None; }
   void Sync();
-  bool CopyGlx();
   DVDVideoPicture DVDPic;
   int texWidth, texHeight;
   CRect crop;
   GLuint texture;
+  GLuint textureY, textureVU;
   bool valid;
   CDecoder *vaapi;
   AVFrame *avFrame;
@@ -195,10 +199,12 @@ public:
   long Release();
 private:
   void ReturnUnused();
+  bool GLMapSurface();
+  void GLUnMapSurface();
   bool usefence;
   GLsync fence;
   int refCount;
-  VaapiGlx glx;
+  CVaapiGLSurface glInterop;
   CCriticalSection &renderPicSection;
 };
 
@@ -301,14 +307,14 @@ protected:
   bool Init();
   bool Uninit();
   void Flush();
-  bool CreateGlxContext();
-  bool DestroyGlxContext();
+  bool CreateEGLContext();
+  bool DestroyEGLContext();
   bool EnsureBufferPool();
   void ReleaseBufferPool(bool precleanup = false);
   bool GLInit();
   bool CheckSuccess(VAStatus status);
-  PFNGLXBINDTEXIMAGEEXTPROC glXBindTexImageEXT;
-  PFNGLXRELEASETEXIMAGEEXTPROC glXReleaseTexImageEXT;
+  PFNEGLCREATEIMAGEKHRPROC eglCreateImageKHR;
+  PFNGLEGLIMAGETARGETTEXTURE2DOESPROC glEGLImageTargetTexture2DOES;
   CEvent m_outMsgEvent;
   CEvent *m_inMsgEvent;
   int m_state;
@@ -319,12 +325,10 @@ protected:
   bool m_vaError;
   CVaapiConfig m_config;
   VaapiBufferPool m_bufferPool;
+  EGLDisplay m_eglDisplay;
+  EGLSurface m_eglSurface;
+  EGLContext m_eglContext;
   Display *m_Display;
-  Window m_Window;
-  GLXContext m_glContext;
-  GLXWindow m_glWindow;
-  Pixmap    m_pixmap;
-  GLXPixmap m_glPixmap;
   CVaapiDecodedPicture m_currentPicture;
   GLenum m_textureTarget;
   CPostproc *m_pp;
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
index 0822f0d..1be26f7 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
@@ -20,9 +20,9 @@
 
 #include "system.h"
 #ifdef HAVE_LIBVDPAU
+#include "VDPAU.h"
 #include <dlfcn.h>
 #include "windowing/WindowingFactory.h"
-#include "VDPAU.h"
 #include "guilib/GraphicContext.h"
 #include "guilib/TextureManager.h"
 #include "cores/VideoRenderers/RenderManager.h"
@@ -3413,7 +3413,7 @@ bool COutput::GLInit()
 #endif
 
 #ifdef GL_ARB_sync
-  bool hasfence = glewIsSupported("GL_ARB_sync");
+  bool hasfence = g_Windowing.IsExtSupported("GL_ARB_sync");
   for (unsigned int i = 0; i < m_bufferPool.allRenderPics.size(); i++)
   {
     m_bufferPool.allRenderPics[i]->usefence = hasfence;
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.h
index f1e78ea..8c17dac 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.h
@@ -39,14 +39,14 @@
 #pragma once
 
 #include "system_gl.h"
+#define GLX_GLXEXT_PROTOTYPES
+#include <GL/glx.h>
+#include <GL/glext.h>
 
 #include "DVDVideoCodec.h"
 #include "DVDVideoCodecFFmpeg.h"
 #include <X11/Xlib.h>
 #include <X11/Xutil.h>
-#define GLX_GLXEXT_PROTOTYPES
-#include <GL/glx.h>
-
 #include "DVDVideoCodec.h"
 #include "DVDVideoCodecFFmpeg.h"
 #include "threads/CriticalSection.h"
@@ -56,6 +56,7 @@
 #include "threads/Event.h"
 #include "threads/Thread.h"
 #include "utils/ActorProtocol.h"
+#include "guilib/Geometry.h"
 #include <list>
 #include <map>
 
diff --git a/xbmc/guilib/Shader.cpp b/xbmc/guilib/Shader.cpp
index 94d0e28..3705405 100644
--- a/xbmc/guilib/Shader.cpp
+++ b/xbmc/guilib/Shader.cpp
@@ -67,14 +67,6 @@ bool CGLSLVertexShader::Compile()
 
   Free();
 
-#ifdef HAS_GL
-  if(!GLEW_VERSION_2_0)
-  {
-    CLog::Log(LOGERROR, "GL: GLSL vertex shaders not supported");
-    return false;
-  }
-#endif
-
   m_vertexShader = glCreateShader(GL_VERTEX_SHADER);
   const char *ptr = m_source.c_str();
   glShaderSource(m_vertexShader, 1, &ptr, 0);
@@ -104,11 +96,6 @@ bool CGLSLVertexShader::Compile()
 
 void CGLSLVertexShader::Free()
 {
-#ifdef HAS_GL
-  if(!GLEW_VERSION_2_0)
-    return;
-#endif
-
   if (m_vertexShader)
     glDeleteShader(m_vertexShader);
   m_vertexShader = 0;
@@ -166,14 +153,6 @@ void CARBVertexShader::Free()
 //////////////////////////////////////////////////////////////////////
 bool CGLSLPixelShader::Compile()
 {
-#ifdef HAS_GL
-  if(!GLEW_VERSION_2_0)
-  {
-    CLog::Log(LOGERROR, "GL: GLSL pixel shaders not supported");
-    return false;
-  }
-#endif
-
   GLint params[4];
 
   Free();
@@ -213,10 +192,6 @@ bool CGLSLPixelShader::Compile()
 
 void CGLSLPixelShader::Free()
 {
-#ifdef HAS_GL
-  if(!GLEW_VERSION_2_0)
-    return;
-#endif
   if (m_pixelShader)
     glDeleteShader(m_pixelShader);
   m_pixelShader = 0;
@@ -278,10 +253,6 @@ void CARBPixelShader::Free()
 //////////////////////////////////////////////////////////////////////
 void CGLSLShaderProgram::Free()
 {
-#ifdef HAS_GL
-  if(!GLEW_VERSION_2_0)
-    return;
-#endif
   m_pVP->Free();
   VerifyGLState();
   m_pFP->Free();
@@ -297,15 +268,6 @@ void CGLSLShaderProgram::Free()
 
 bool CGLSLShaderProgram::CompileAndLink()
 {
-#ifdef HAS_GL
-  // check that we support shaders
-  if(!GLEW_VERSION_2_0)
-  {
-    CLog::Log(LOGERROR, "GL: GLSL shaders not supported");
-    return false;
-  }
-#endif
-
   GLint params[4];
 
   // free resources
@@ -374,11 +336,6 @@ bool CGLSLShaderProgram::CompileAndLink()
 
 bool CGLSLShaderProgram::Enable()
 {
-#ifdef HAS_GL
-  if(!GLEW_VERSION_2_0)
-    return false;
-#endif
-
   if (OK())
   {
     glUseProgram(m_shaderProgram);
@@ -414,11 +371,6 @@ bool CGLSLShaderProgram::Enable()
 
 void CGLSLShaderProgram::Disable()
 {
-#ifdef HAS_GL
-  if(!GLEW_VERSION_2_0)
-    return;
-#endif
-
   if (OK())
   {
     glUseProgram(0);
diff --git a/xbmc/rendering/gl/RenderSystemGL.cpp b/xbmc/rendering/gl/RenderSystemGL.cpp
index 81d180e..162f823 100644
--- a/xbmc/rendering/gl/RenderSystemGL.cpp
+++ b/xbmc/rendering/gl/RenderSystemGL.cpp
@@ -112,14 +112,11 @@ bool CRenderSystemGL::InitRenderSystem()
   m_maxTextureSize = 2048;
   m_renderCaps = 0;
 
-  // init glew library
-  GLenum err = glewInit();
-  if (GLEW_OK != err)
-  {
-    // Problem: glewInit failed, something is seriously wrong
-    CLog::Log(LOGERROR, "InitRenderSystem() glewInit returned %i: %s", err, glewGetErrorString(err));
-    return false;
-  }
+  m_RenderExtensions  = " ";
+  m_RenderExtensions += (const char*) glGetString(GL_EXTENSIONS);
+  m_RenderExtensions += " ";
+
+  LogGraphicsInfo();
 
   // Get the GL version number
   m_RenderVersionMajor = 0;
@@ -132,7 +129,7 @@ bool CRenderSystemGL::InitRenderSystem()
     m_RenderVersion = ver;
   }
 
-  if (glewIsSupported("GL_ARB_shading_language_100"))
+  if (IsExtSupported("GL_ARB_shading_language_100"))
   {
     ver = (const char*)glGetString(GL_SHADING_LANGUAGE_VERSION);
     if (ver)
@@ -151,10 +148,10 @@ bool CRenderSystemGL::InitRenderSystem()
   m_RenderRenderer = (const char*) glGetString(GL_RENDERER);
 
   // grab our capabilities
-  if (glewIsSupported("GL_EXT_texture_compression_s3tc"))
+  if (IsExtSupported("GL_EXT_texture_compression_s3tc"))
     m_renderCaps |= RENDER_CAPS_DXT;
 
-  if (glewIsSupported("GL_ARB_texture_non_power_of_two"))
+  if (IsExtSupported("GL_ARB_texture_non_power_of_two"))
   {
     m_renderCaps |= RENDER_CAPS_NPOT;
     if (m_renderCaps & RENDER_CAPS_DXT) 
@@ -163,12 +160,6 @@ bool CRenderSystemGL::InitRenderSystem()
   //Check OpenGL quirks and revert m_renderCaps as needed
   CheckOpenGLQuirks();
 	
-  m_RenderExtensions  = " ";
-  m_RenderExtensions += (const char*) glGetString(GL_EXTENSIONS);
-  m_RenderExtensions += " ";
-
-  LogGraphicsInfo();
-
   m_bRenderCreated = true;
 
   return true;
@@ -202,7 +193,7 @@ bool CRenderSystemGL::ResetRenderSystem(int width, int height, bool fullScreen,
   glMatrixTexture->LoadIdentity();
   glMatrixTexture.Load();
 
-  if (glewIsSupported("GL_ARB_multitexture"))
+  if (IsExtSupported("GL_ARB_multitexture"))
   {
     //clear error flags
     ResetGLErrors();
diff --git a/xbmc/system_gl.h b/xbmc/system_gl.h
index efc709a..deb88db 100644
--- a/xbmc/system_gl.h
+++ b/xbmc/system_gl.h
@@ -28,18 +28,14 @@
     #define GL_GLEXT_PROTOTYPES
   #endif
   #if defined(TARGET_WINDOWS)
-    #include <GL/glew.h>
     #include <GL/gl.h>
     #include <GL/glu.h>
   #elif defined(TARGET_LINUX)
-    #include <GL/glew.h>
     #include <GL/gl.h>
     #include <GL/glext.h>
   #elif defined(TARGET_FREEBSD)
-    #include <GL/glew.h>
     #include <GL/gl.h>
   #elif defined(TARGET_DARWIN)
-    #include <GL/glew.h>
     #include <OpenGL/gl.h>
     #include <OpenGL/glext.h>
   #endif
diff --git a/xbmc/windowing/WinEventsX11.cpp b/xbmc/windowing/WinEventsX11.cpp
index 38a52df..9aaacb8 100644
--- a/xbmc/windowing/WinEventsX11.cpp
+++ b/xbmc/windowing/WinEventsX11.cpp
@@ -29,8 +29,7 @@
 #include "ApplicationMessenger.h"
 #include <X11/Xlib.h>
 #include <X11/extensions/Xrandr.h>
-#include "X11/WinSystemX11GL.h"
-#include "X11/WinSystemX11GLES.h"
+#include "WindowingFactory.h"
 #include "X11/keysymdef.h"
 #include "X11/XF86keysym.h"
 #include "utils/log.h"
diff --git a/xbmc/windowing/WindowingFactory.h b/xbmc/windowing/WindowingFactory.h
index 78ffe32..888eef2 100644
--- a/xbmc/windowing/WindowingFactory.h
+++ b/xbmc/windowing/WindowingFactory.h
@@ -29,11 +29,8 @@
 #elif defined(TARGET_WINDOWS) && defined(HAS_DX)
 #include "windows/WinSystemWin32DX.h"
 
-#elif defined(TARGET_LINUX)   && defined(HAS_EGL)   && defined(HAVE_X11)
-#include "X11/WinSystemX11GLES.h"
-
-#elif defined(TARGET_LINUX)   && defined(HAS_GL)   && defined(HAVE_X11)
-#include "X11/WinSystemX11GL.h"
+#elif defined(TARGET_LINUX)   && defined(HAVE_X11)
+#include "X11/WinSystemX11GLContext.h"
 
 #elif defined(TARGET_LINUX)   && defined(HAS_GLES) && defined(HAS_EGL) && !defined(HAVE_X11)
 #include "egl/WinSystemEGL.h"
diff --git a/xbmc/windowing/X11/GLContext.h b/xbmc/windowing/X11/GLContext.h
new file mode 100644
index 0000000..0f285ca
--- /dev/null
+++ b/xbmc/windowing/X11/GLContext.h
@@ -0,0 +1,66 @@
+/*
+ *      Copyright (C) 2005-2014 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#pragma once
+
+#if defined(HAVE_X11)
+#include "GL/glx.h"
+#include "EGL/egl.h"
+#include "X11/Xlib.h"
+#include "guilib/DirtyRegion.h"
+
+#define EGL_NO_CONFIG (EGLConfig)0
+
+class CGLContext
+{
+public:
+  CGLContext(Display *dpy)
+  {
+    m_dpy = dpy;
+    m_extensions = "";
+    m_glxWindow = 0;
+    m_glxContext = 0;
+    m_eglDisplay = EGL_NO_DISPLAY;
+    m_eglSurface = EGL_NO_SURFACE;
+    m_eglContext = EGL_NO_CONTEXT;
+    m_eglConfig = EGL_NO_CONFIG;
+  }
+  virtual bool Refresh(bool force, int screen, Window glWindow, bool &newContext) = 0;
+  virtual void Destroy() = 0;
+  virtual void Detach() = 0;
+  virtual void SetVSync(bool enable, int &mode) = 0;
+  virtual bool SwapBuffers(const CDirtyRegionList& dirty, int &mode) = 0;
+  virtual void QueryExtensions() = 0;
+  virtual bool IsExtSupported(const char* extension) = 0;
+
+  std::string ExtPrefix(){ return m_extPrefix; };
+  std::string m_extPrefix;
+  std::string m_extensions;
+
+  Display *m_dpy;
+  GLXWindow m_glxWindow;
+  GLXContext m_glxContext;
+  EGLDisplay m_eglDisplay;
+  EGLSurface m_eglSurface;
+  EGLContext m_eglContext;
+  EGLConfig m_eglConfig;
+};
+
+#endif
diff --git a/xbmc/windowing/X11/GLContextEGL.cpp b/xbmc/windowing/X11/GLContextEGL.cpp
new file mode 100644
index 0000000..fb005048
--- /dev/null
+++ b/xbmc/windowing/X11/GLContextEGL.cpp
@@ -0,0 +1,367 @@
+/*
+ *      Copyright (C) 2005-2014 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "system.h"
+
+#if defined(HAVE_X11)
+
+#include "GLContextEGL.h"
+#include "utils/log.h"
+
+CGLContextEGL::CGLContextEGL(Display *dpy) : CGLContext(dpy)
+{
+  m_extPrefix = "EGL_";
+}
+
+CGLContextEGL::~CGLContextEGL()
+{
+  Destroy();
+}
+
+bool CGLContextEGL::Refresh(bool force, int screen, Window glWindow, bool &newContext)
+{
+  // refresh context
+  if (m_eglContext && !force)
+  {
+    if (m_eglSurface == EGL_NO_SURFACE)
+    {
+      m_eglSurface = eglCreateWindowSurface(m_eglDisplay, m_eglConfig, glWindow, NULL);
+      if (m_eglSurface == EGL_NO_SURFACE)
+      {
+        CLog::Log(LOGERROR, "failed to create EGL window surface %d\n", eglGetError());
+        return false;
+      }
+    }
+
+    CLog::Log(LOGDEBUG, "CWinSystemX11::RefreshEGLContext: refreshing context");
+    eglMakeCurrent(m_eglDisplay, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
+    eglMakeCurrent(m_eglDisplay, m_eglSurface, m_eglSurface, m_eglContext);
+    return true;
+  }
+
+  // create context
+  bool retVal = false;
+
+  if (m_eglDisplay == EGL_NO_DISPLAY)
+  {
+    m_eglDisplay = eglGetDisplay((EGLNativeDisplayType)m_dpy);
+    if (m_eglDisplay == EGL_NO_DISPLAY)
+    {
+      CLog::Log(LOGERROR, "failed to get egl display\n");
+      return false;
+    }
+    if (!eglInitialize(m_eglDisplay, NULL, NULL))
+    {
+      CLog::Log(LOGERROR, "failed to initialize egl display\n");
+      return false;
+    }
+  }
+
+  XVisualInfo vMask;
+  XVisualInfo *visuals;
+  XVisualInfo *vInfo      = NULL;
+  int availableVisuals    = 0;
+  vMask.screen = screen;
+  XWindowAttributes winAttr;
+
+  /* Assume a depth of 24 in case the below calls to XGetWindowAttributes()
+     or XGetVisualInfo() fail. That shouldn't happen unless something is
+     fatally wrong, but lets prepare for everything. */
+  vMask.depth = 24;
+
+  if (XGetWindowAttributes(m_dpy, glWindow, &winAttr))
+  {
+    vMask.visualid = XVisualIDFromVisual(winAttr.visual);
+    vInfo = XGetVisualInfo(m_dpy, VisualScreenMask | VisualIDMask, &vMask, &availableVisuals);
+    if (!vInfo)
+      CLog::Log(LOGWARNING, "Failed to get VisualInfo of visual 0x%x", (unsigned) vMask.visualid);
+    else if(!IsSuitableVisual(vInfo))
+    {
+      CLog::Log(LOGWARNING, "Visual 0x%x of the window is not suitable, looking for another one...",
+                (unsigned) vInfo->visualid);
+      vMask.depth = vInfo->depth;
+      XFree(vInfo);
+      vInfo = NULL;
+    }
+  }
+  else
+    CLog::Log(LOGWARNING, "Failed to get window attributes");
+
+  /* As per glXMakeCurrent documentation, we have to use the same visual as
+     m_glWindow. Since that was not suitable for use, we try to use another
+     one with the same depth and hope that the used implementation is less
+     strict than the documentation. */
+  if (!vInfo)
+  {
+    visuals = XGetVisualInfo(m_dpy, VisualScreenMask | VisualDepthMask, &vMask, &availableVisuals);
+    for (int i = 0; i < availableVisuals; i++)
+    {
+      if (IsSuitableVisual(&visuals[i]))
+      {
+        vMask.visualid = visuals[i].visualid;
+        vInfo = XGetVisualInfo(m_dpy, VisualScreenMask | VisualIDMask, &vMask, &availableVisuals);
+        break;
+      }
+    }
+    XFree(visuals);
+  }
+
+  if (vInfo)
+  {
+    CLog::Log(LOGNOTICE, "Using visual 0x%x", (unsigned) vInfo->visualid);
+
+    if (m_eglContext)
+    {
+      eglMakeCurrent(m_eglContext, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
+      eglDestroyContext(m_eglDisplay, m_eglContext);
+      m_eglContext = EGL_NO_CONTEXT;
+
+      if (m_eglSurface)
+      {
+        eglDestroySurface(m_eglDisplay, m_eglSurface);
+        m_eglSurface = EGL_NO_SURFACE;
+      }
+      eglTerminate(m_eglDisplay);
+      m_eglDisplay = EGL_NO_DISPLAY;
+      XSync(m_dpy, FALSE);
+      newContext = true;
+    }
+
+    m_eglDisplay = eglGetDisplay((EGLNativeDisplayType)m_dpy);
+    if (m_eglDisplay == EGL_NO_DISPLAY)
+    {
+      CLog::Log(LOGERROR, "failed to get egl display");
+      return false;
+    }
+    if (!eglInitialize(m_eglDisplay, NULL, NULL))
+    {
+      CLog::Log(LOGERROR, "failed to initialize egl\n");
+      return false;
+    }
+
+#if defined (HAS_GL)
+    if (!eglBindAPI(EGL_OPENGL_API))
+    {
+      CLog::Log(LOGERROR, "failed to initialize egl");
+      XFree(vInfo);
+      return false;
+    }
+#endif
+
+    m_eglConfig = getEGLConfig(m_eglDisplay, vInfo);
+
+    if (m_eglConfig == EGL_NO_CONFIG)
+    {
+      CLog::Log(LOGERROR, "failed to get eglconfig for visual id");
+      XFree(vInfo);
+      return false;
+    }
+
+    if (m_eglSurface == EGL_NO_SURFACE)
+    {
+      m_eglSurface = eglCreateWindowSurface(m_eglDisplay, m_eglConfig, glWindow, NULL);
+      if (m_eglSurface == EGL_NO_SURFACE)
+      {
+        CLog::Log(LOGERROR, "failed to create EGL window surface %d", eglGetError());
+        XFree(vInfo);
+        return false;
+      }
+    }
+
+    EGLint contextAttributes[] =
+    {
+      EGL_CONTEXT_CLIENT_VERSION, 2,
+      EGL_NONE
+    };
+    m_eglContext = eglCreateContext(m_eglDisplay, m_eglConfig, EGL_NO_CONTEXT, contextAttributes);
+    if (m_eglContext == EGL_NO_CONTEXT)
+    {
+      CLog::Log(LOGERROR, "failed to create EGL context\n");
+      return false;
+    }
+
+    if (!eglMakeCurrent(m_eglDisplay, m_eglSurface, m_eglSurface, m_eglContext))
+    {
+      CLog::Log(LOGERROR, "Failed to make context current %p %p %p\n", m_eglDisplay, m_eglSurface, m_eglContext);
+      return false;
+    }
+    XFree(vInfo);
+    retVal = true;
+  }
+  else
+  {
+    CLog::Log(LOGERROR, "EGL Error: vInfo is NULL!");
+  }
+
+  return retVal;
+}
+
+void CGLContextEGL::Destroy()
+{
+  if (m_eglContext)
+  {
+    glFinish();
+    eglMakeCurrent(m_eglDisplay, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
+    eglDestroyContext(m_eglDisplay, m_eglContext);
+    m_eglContext = EGL_NO_CONTEXT;
+  }
+
+  if (m_eglSurface)
+  {
+    eglDestroySurface(m_eglDisplay, m_eglSurface);
+    m_eglSurface = EGL_NO_SURFACE;
+  }
+
+  if (m_eglDisplay)
+  {
+    eglTerminate(m_eglDisplay);
+    m_eglDisplay = EGL_NO_DISPLAY;
+  }
+}
+
+void CGLContextEGL::Detach()
+{
+  if (m_eglContext)
+  {
+    glFinish();
+    eglMakeCurrent(m_eglDisplay, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
+  }
+  if (m_eglSurface)
+  {
+    eglDestroySurface(m_eglDisplay, m_eglSurface);
+    m_eglSurface = EGL_NO_SURFACE;
+  }
+}
+
+bool CGLContextEGL::IsSuitableVisual(XVisualInfo *vInfo)
+{
+  EGLConfig config = getEGLConfig(m_eglDisplay, vInfo);
+  if (config == EGL_NO_CONFIG)
+  {
+    CLog::Log(LOGERROR, "Failed to determine egl config for visual info");
+    return false;
+  }
+  EGLint value;
+
+  if (!eglGetConfigAttrib(m_eglDisplay, config, EGL_RED_SIZE, &value) || value < 8)
+    return false;
+  if (!eglGetConfigAttrib(m_eglDisplay, config, EGL_GREEN_SIZE, &value) || value < 8)
+    return false;
+  if (!eglGetConfigAttrib(m_eglDisplay, config, EGL_BLUE_SIZE, &value) || value < 8)
+    return false;
+  if (!eglGetConfigAttrib(m_eglDisplay, config, EGL_ALPHA_SIZE, &value) || value < 8)
+    return false;
+  if (!eglGetConfigAttrib(m_eglDisplay, config, EGL_DEPTH_SIZE, &value) || value < 24)
+    return false;
+
+  return true;
+}
+
+EGLConfig CGLContextEGL::getEGLConfig(EGLDisplay eglDisplay, XVisualInfo *vInfo)
+{
+  EGLint attributes[] =
+  {
+    EGL_DEPTH_SIZE, 24,
+    EGL_ALPHA_SIZE, 8,
+    EGL_RED_SIZE, 8,
+    EGL_BLUE_SIZE, 8,
+    EGL_GREEN_SIZE, 8,
+    EGL_NONE
+  };
+  EGLint numConfigs;
+
+  if (!eglChooseConfig(eglDisplay, attributes, NULL, 0, &numConfigs))
+  {
+    CLog::Log(LOGERROR, "Failed to query number of egl configs");
+    return EGL_NO_CONFIG;
+  }
+  if (numConfigs == 0)
+  {
+    CLog::Log(LOGERROR, "No suitable egl configs found");
+    return EGL_NO_CONFIG;
+  }
+
+  EGLConfig *eglConfigs;
+  eglConfigs = (EGLConfig*)malloc(numConfigs * sizeof(EGLConfig));
+  if (!eglConfigs)
+  {
+    CLog::Log(LOGERROR, "eglConfigs malloc failed");
+    return EGL_NO_CONFIG;
+  }
+  EGLConfig eglConfig = EGL_NO_CONFIG;
+  if (!eglChooseConfig(eglDisplay, attributes, eglConfigs, numConfigs, &numConfigs))
+  {
+    CLog::Log(LOGERROR, "Failed to query egl configs");
+    goto Exit;
+  }
+  for (EGLint i = 0;i < numConfigs;++i)
+  {
+    EGLint value;
+    if (!eglGetConfigAttrib(eglDisplay, eglConfigs[i], EGL_NATIVE_VISUAL_ID, &value))
+    {
+      CLog::Log(LOGERROR, "Failed to query EGL_NATIVE_VISUAL_ID for egl config.");
+      break;
+    }
+    if (value == (EGLint)vInfo->visualid) {
+      eglConfig = eglConfigs[i];
+      break;
+    }
+  }
+
+Exit:
+  free(eglConfigs);
+  return eglConfig;
+}
+
+void CGLContextEGL::SetVSync(bool enable, int &mode)
+{
+  eglSwapInterval(m_eglDisplay, enable ? 1 : 0);
+}
+
+bool CGLContextEGL::SwapBuffers(const CDirtyRegionList& dirty, int &mode)
+{
+  if ((m_eglDisplay == EGL_NO_DISPLAY) || (m_eglSurface == EGL_NO_SURFACE))
+    return false;
+
+  eglSwapBuffers(m_eglDisplay, m_eglSurface);
+
+  return true;
+}
+
+void CGLContextEGL::QueryExtensions()
+{
+  std::string extensions = eglQueryString(m_eglDisplay, EGL_EXTENSIONS);
+  m_extensions = std::string(" ") + extensions + " ";
+
+  CLog::Log(LOGDEBUG, "EGL_EXTENSIONS:%s", m_extensions.c_str());
+}
+
+bool CGLContextEGL::IsExtSupported(const char* extension)
+{
+  std::string name;
+
+  name  = " ";
+  name += extension;
+  name += " ";
+
+  return m_extensions.find(name) != std::string::npos;
+}
+
+#endif
diff --git a/xbmc/windowing/X11/GLContextEGL.h b/xbmc/windowing/X11/GLContextEGL.h
new file mode 100644
index 0000000..dac7075
--- /dev/null
+++ b/xbmc/windowing/X11/GLContextEGL.h
@@ -0,0 +1,44 @@
+/*
+ *      Copyright (C) 2005-2014 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#pragma once
+
+#if defined(HAVE_X11)
+#include "GLContext.h"
+#include "EGL/egl.h"
+
+class CGLContextEGL : public CGLContext
+{
+public:
+  CGLContextEGL(Display *dpy);
+  virtual ~CGLContextEGL();
+  virtual bool Refresh(bool force, int screen, Window glWindow, bool &newContext);
+  virtual void Destroy();
+  virtual void Detach();
+  virtual void SetVSync(bool enable, int &mode);
+  virtual bool SwapBuffers(const CDirtyRegionList& dirty, int &mode);
+  virtual void QueryExtensions();
+  virtual bool IsExtSupported(const char* extension);
+protected:
+  bool IsSuitableVisual(XVisualInfo *vInfo);
+  EGLConfig getEGLConfig(EGLDisplay eglDisplay, XVisualInfo *vInfo);
+};
+
+#endif
diff --git a/xbmc/windowing/X11/GLContextGLX.cpp b/xbmc/windowing/X11/GLContextGLX.cpp
new file mode 100644
index 0000000..6dc3d84
--- /dev/null
+++ b/xbmc/windowing/X11/GLContextGLX.cpp
@@ -0,0 +1,309 @@
+/*
+ *      Copyright (C) 2005-2014 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "system_gl.h"
+
+#if defined(HAVE_X11)
+
+#include <GL/glx.h>
+#include "GLContextGLX.h"
+#include "utils/log.h"
+
+CGLContextGLX::CGLContextGLX(Display *dpy) : CGLContext(dpy)
+{
+  m_extPrefix = "GLX_";
+}
+
+bool CGLContextGLX::Refresh(bool force, int screen, Window glWindow, bool &newContext)
+{
+  bool retVal = false;
+  m_glxWindow = glWindow;
+  m_nScreen = screen;
+
+  // refresh context
+  if (m_glxContext && !force)
+  {
+    CLog::Log(LOGDEBUG, "CWinSystemX11::RefreshGlxContext: refreshing context");
+    glXMakeCurrent(m_dpy, None, NULL);
+    glXMakeCurrent(m_dpy, glWindow, m_glxContext);
+    return true;
+  }
+
+  // create context
+
+  XVisualInfo vMask;
+  XVisualInfo *visuals;
+  XVisualInfo *vInfo = NULL;
+  int availableVisuals = 0;
+  vMask.screen = screen;
+  XWindowAttributes winAttr;
+
+  /* Assume a depth of 24 in case the below calls to XGetWindowAttributes()
+     or XGetVisualInfo() fail. That shouldn't happen unless something is
+     fatally wrong, but lets prepare for everything. */
+  vMask.depth = 24;
+
+  if (XGetWindowAttributes(m_dpy, glWindow, &winAttr))
+  {
+    vMask.visualid = XVisualIDFromVisual(winAttr.visual);
+    vInfo = XGetVisualInfo(m_dpy, VisualScreenMask | VisualIDMask, &vMask, &availableVisuals);
+    if (!vInfo)
+      CLog::Log(LOGWARNING, "Failed to get VisualInfo of visual 0x%x", (unsigned) vMask.visualid);
+    else if(!IsSuitableVisual(vInfo))
+    {
+      CLog::Log(LOGWARNING, "Visual 0x%x of the window is not suitable, looking for another one...",
+                (unsigned) vInfo->visualid);
+      vMask.depth = vInfo->depth;
+      XFree(vInfo);
+      vInfo = NULL;
+    }
+  }
+  else
+    CLog::Log(LOGWARNING, "Failed to get window attributes");
+
+  /* As per glXMakeCurrent documentation, we have to use the same visual as
+     m_glWindow. Since that was not suitable for use, we try to use another
+     one with the same depth and hope that the used implementation is less
+     strict than the documentation. */
+  if (!vInfo)
+  {
+    visuals = XGetVisualInfo(m_dpy, VisualScreenMask | VisualDepthMask, &vMask, &availableVisuals);
+    for (int i = 0; i < availableVisuals; i++)
+    {
+      if (IsSuitableVisual(&visuals[i]))
+      {
+        vMask.visualid = visuals[i].visualid;
+        vInfo = XGetVisualInfo(m_dpy, VisualScreenMask | VisualIDMask, &vMask, &availableVisuals);
+        break;
+      }
+    }
+    XFree(visuals);
+  }
+
+  if (vInfo)
+  {
+    CLog::Log(LOGNOTICE, "Using visual 0x%x", (unsigned) vInfo->visualid);
+    if (m_glxContext)
+    {
+      glXMakeCurrent(m_dpy, None, NULL);
+      glXDestroyContext(m_dpy, m_glxContext);
+      XSync(m_dpy, FALSE);
+    }
+
+    if ((m_glxContext = glXCreateContext(m_dpy, vInfo, NULL, True)))
+    {
+      // make this context current
+      glXMakeCurrent(m_dpy, glWindow, m_glxContext);
+      retVal = true;
+    }
+    else
+      CLog::Log(LOGERROR, "GLX Error: Could not create context");
+
+    XFree(vInfo);
+  }
+  else
+  {
+    CLog::Log(LOGERROR, "GLX Error: vInfo is NULL!");
+  }
+
+  return retVal;
+}
+
+void CGLContextGLX::Destroy()
+{
+  glXMakeCurrent(m_dpy, None, NULL);
+  glXDestroyContext(m_dpy, m_glxContext);
+  m_glxContext = 0;
+}
+
+void CGLContextGLX::Detach()
+{
+  glXMakeCurrent(m_dpy, None, NULL);
+}
+
+bool CGLContextGLX::IsSuitableVisual(XVisualInfo *vInfo)
+{
+  int value;
+
+  if (glXGetConfig(m_dpy, vInfo, GLX_RGBA, &value) || !value)
+    return false;
+  if (glXGetConfig(m_dpy, vInfo, GLX_DOUBLEBUFFER, &value) || !value)
+    return false;
+  if (glXGetConfig(m_dpy, vInfo, GLX_RED_SIZE, &value) || value < 8)
+    return false;
+  if (glXGetConfig(m_dpy, vInfo, GLX_GREEN_SIZE, &value) || value < 8)
+    return false;
+  if (glXGetConfig(m_dpy, vInfo, GLX_BLUE_SIZE, &value) || value < 8)
+    return false;
+  if (glXGetConfig(m_dpy, vInfo, GLX_ALPHA_SIZE, &value) || value < 8)
+    return false;
+  if (glXGetConfig(m_dpy, vInfo, GLX_DEPTH_SIZE, &value) || value < 8)
+    return false;
+
+  return true;
+}
+
+void CGLContextGLX::SetVSync(bool enable, int &mode)
+{
+  // turn of current setting first
+  if(m_glXSwapIntervalEXT)
+    m_glXSwapIntervalEXT(m_dpy, m_glxWindow, 0);
+  else if(m_glXSwapIntervalMESA)
+    m_glXSwapIntervalMESA(0);
+
+  m_iVSyncErrors = 0;
+
+  if(!enable)
+    return;
+
+  if (m_glXSwapIntervalEXT && !mode)
+  {
+    m_glXSwapIntervalEXT(m_dpy, m_glxWindow, 1);
+    mode = 6;
+  }
+  if (m_glXSwapIntervalMESA && !mode)
+  {
+    if(m_glXSwapIntervalMESA(1) == 0)
+      mode = 2;
+    else
+      CLog::Log(LOGWARNING, "%s - glXSwapIntervalMESA failed", __FUNCTION__);
+  }
+  if (m_glXWaitVideoSyncSGI && m_glXGetVideoSyncSGI && !mode)
+  {
+    unsigned int count;
+    if(m_glXGetVideoSyncSGI(&count) == 0)
+      mode = 3;
+    else
+      CLog::Log(LOGWARNING, "%s - glXGetVideoSyncSGI failed, glcontext probably not direct", __FUNCTION__);
+  }
+}
+
+bool CGLContextGLX::SwapBuffers(const CDirtyRegionList& dirty, int &mode)
+{
+  if(mode == 3)
+  {
+    glFinish();
+    unsigned int before = 0, after = 0;
+    if (m_glXGetVideoSyncSGI(&before) != 0)
+      CLog::Log(LOGERROR, "%s - glXGetVideoSyncSGI - Failed to get current retrace count", __FUNCTION__);
+
+    glXSwapBuffers(m_dpy, m_glxWindow);
+    glFinish();
+
+    if(m_glXGetVideoSyncSGI(&after) != 0)
+      CLog::Log(LOGERROR, "%s - glXGetVideoSyncSGI - Failed to get current retrace count", __FUNCTION__);
+
+    if (after == before)
+      m_iVSyncErrors = 1;
+    else
+      m_iVSyncErrors--;
+
+    if (m_iVSyncErrors > 0)
+    {
+      CLog::Log(LOGINFO, "GL: retrace count didn't change after buffer swap, switching to vsync mode 4");
+      m_iVSyncErrors = 0;
+      mode = 4;
+    }
+
+    if (m_iVSyncErrors < -200)
+    {
+      CLog::Log(LOGINFO, "GL: retrace count change for %d consecutive buffer swap, switching to vsync mode 2", -m_iVSyncErrors);
+      m_iVSyncErrors = 0;
+      mode = 2;
+    }
+  }
+  else if (mode == 4)
+  {
+    glFinish();
+    unsigned int before = 0, swap = 0, after = 0;
+    if (m_glXGetVideoSyncSGI(&before) != 0)
+      CLog::Log(LOGERROR, "%s - glXGetVideoSyncSGI - Failed to get current retrace count", __FUNCTION__);
+
+    if(m_glXWaitVideoSyncSGI(2, (before+1)%2, &swap) != 0)
+      CLog::Log(LOGERROR, "%s - glXWaitVideoSyncSGI - Returned error", __FUNCTION__);
+
+    glXSwapBuffers(m_dpy, m_glxWindow);
+    glFinish();
+
+    if (m_glXGetVideoSyncSGI(&after) != 0)
+      CLog::Log(LOGERROR, "%s - glXGetVideoSyncSGI - Failed to get current retrace count", __FUNCTION__);
+
+    if (after == before)
+      CLog::Log(LOGERROR, "%s - glXWaitVideoSyncSGI - Woke up early", __FUNCTION__);
+
+    if (after > before + 1)
+      m_iVSyncErrors++;
+    else
+      m_iVSyncErrors = 0;
+
+    if (m_iVSyncErrors > 30)
+    {
+      CLog::Log(LOGINFO, "GL: retrace count seems to be changing due to the swapbuffers call, switching to vsync mode 3");
+      mode = 3;
+      m_iVSyncErrors = 0;
+    }
+  }
+  else
+    glXSwapBuffers(m_dpy, m_glxWindow);
+
+  return true;
+}
+
+void CGLContextGLX::QueryExtensions()
+{
+  m_extensions  = " ";
+  m_extensions += (const char*)glXQueryExtensionsString(m_dpy, m_nScreen);
+  m_extensions += " ";
+
+  CLog::Log(LOGDEBUG, "GLX_EXTENSIONS:%s", m_extensions.c_str());
+
+  if (IsExtSupported("GLX_SGI_video_sync"))
+    m_glXWaitVideoSyncSGI = (int (*)(int, int, unsigned int*))glXGetProcAddress((const GLubyte*)"glXWaitVideoSyncSGI");
+  else
+    m_glXWaitVideoSyncSGI = NULL;
+
+  if (IsExtSupported("GLX_SGI_video_sync"))
+    m_glXGetVideoSyncSGI = (int (*)(unsigned int*))glXGetProcAddress((const GLubyte*)"glXGetVideoSyncSGI");
+  else
+    m_glXGetVideoSyncSGI = NULL;
+
+  if (IsExtSupported("GLX_MESA_swap_control"))
+    m_glXSwapIntervalMESA = (int (*)(int))glXGetProcAddress((const GLubyte*)"glXSwapIntervalMESA");
+  else
+    m_glXSwapIntervalMESA = NULL;
+
+  if (IsExtSupported("GLX_EXT_swap_control"))
+    m_glXSwapIntervalEXT = (PFNGLXSWAPINTERVALEXTPROC)glXGetProcAddress((const GLubyte*)"glXSwapIntervalEXT");
+  else
+    m_glXSwapIntervalEXT = NULL;
+}
+
+bool CGLContextGLX::IsExtSupported(const char* extension)
+{
+  std::string name;
+
+  name  = " ";
+  name += extension;
+  name += " ";
+
+  return m_extensions.find(name) != std::string::npos;
+}
+
+#endif
diff --git a/xbmc/windowing/X11/GLContextGLX.h b/xbmc/windowing/X11/GLContextGLX.h
new file mode 100644
index 0000000..c19a257
--- /dev/null
+++ b/xbmc/windowing/X11/GLContextGLX.h
@@ -0,0 +1,49 @@
+/*
+ *      Copyright (C) 2005-2014 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#pragma once
+
+#if defined(HAVE_X11)
+#include "GLContext.h"
+#include "GL/glx.h"
+
+class CGLContextGLX : public CGLContext
+{
+public:
+  CGLContextGLX(Display *dpy);
+  virtual bool Refresh(bool force, int screen, Window glWindow, bool &newContext);
+  virtual void Destroy();
+  virtual void Detach();
+  virtual void SetVSync(bool enable, int &mode);
+  virtual bool SwapBuffers(const CDirtyRegionList& dirty, int &mode);
+  virtual void QueryExtensions();
+  virtual bool IsExtSupported(const char* extension);
+protected:
+  bool IsSuitableVisual(XVisualInfo *vInfo);
+
+  int (*m_glXGetVideoSyncSGI)(unsigned int*);
+  int (*m_glXWaitVideoSyncSGI)(int, int, unsigned int*);
+  int (*m_glXSwapIntervalMESA)(int);
+  PFNGLXSWAPINTERVALEXTPROC m_glXSwapIntervalEXT;
+  int m_nScreen;
+  int m_iVSyncErrors;
+};
+
+#endif
diff --git a/xbmc/windowing/X11/Makefile b/xbmc/windowing/X11/Makefile
index 0dfbd42..3f00276 100644
--- a/xbmc/windowing/X11/Makefile
+++ b/xbmc/windowing/X11/Makefile
@@ -1,6 +1,7 @@
 SRCS=WinSystemX11.cpp \
-     WinSystemX11GL.cpp \
-     WinSystemX11GLES.cpp \
+     WinSystemX11GLContext.cpp \
+     GLContextEGL.cpp \
+     GLContextGLX.cpp \
      XRandR.cpp \
      
 LIB=windowing_X11.a
diff --git a/xbmc/windowing/X11/WinSystemX11.cpp b/xbmc/windowing/X11/WinSystemX11.cpp
index 63bd0a7..16753ab 100644
--- a/xbmc/windowing/X11/WinSystemX11.cpp
+++ b/xbmc/windowing/X11/WinSystemX11.cpp
@@ -20,7 +20,7 @@
 
 #include "system.h"
 
-#if defined(HAS_GLX) || (defined(HAS_EGL) && defined(HAVE_X11))
+#if defined(HAVE_X11)
 
 #include "WinSystemX11.h"
 #include "settings/DisplaySettings.h"
@@ -52,13 +52,6 @@ using namespace std;
 CWinSystemX11::CWinSystemX11() : CWinSystemBase()
 {
   m_eWindowSystem = WINDOW_SYSTEM_X11;
-#if defined(HAS_GLX)
-  m_glContext = NULL;
-#endif
-#if defined(HAS_EGL)
-  m_eglContext = EGL_NO_CONTEXT;
-  m_eglDisplay = EGL_NO_DISPLAY;
-#endif
   m_dpy = NULL;
   m_glWindow = 0;
   m_mainWindow = 0;
@@ -83,7 +76,7 @@ bool CWinSystemX11::InitWindowSystem()
     return ret;
   }
   else
-    CLog::Log(LOGERROR, "GLX Error: No Display found");
+    CLog::Log(LOGERROR, "X11 Error: No Display found");
 
   return false;
 }
@@ -103,37 +96,6 @@ bool CWinSystemX11::DestroyWindowSystem()
     g_xrandr.SetMode(out, mode);
   }
 
-#if defined(HAS_GLX)
-  if (m_dpy)
-  {
-    if (m_glContext)
-    {
-      glXMakeCurrent(m_dpy, None, NULL);
-      glXDestroyContext(m_dpy, m_glContext);
-    }
-
-    m_glContext = 0;
-
-    //we don't call XCloseDisplay() here, since ati keeps a pointer to our m_dpy
-    //so instead we just let m_dpy die on exit
-    // i have seen core dumps on ATI if the display is not closed here
-    // crashes when shutting down via cec
-//    XCloseDisplay(m_dpy);
-  }
-#endif
-
-#if defined(HAS_EGL)
-  if (m_eglDisplay)
-  {
-    if (m_eglContext != EGL_NO_CONTEXT)
-    {
-      eglMakeCurrent(m_eglDisplay, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
-      m_eglContext = EGL_NO_CONTEXT;
-    }
-  }
-#endif
-  // m_SDLSurface is free()'d by SDL_Quit().
-
   return true;
 }
 
@@ -151,21 +113,6 @@ bool CWinSystemX11::DestroyWindow()
   if (!m_mainWindow)
     return true;
 
-#if defined(HAS_GLX)
-  if (m_glContext)
-  {
-    glFinish();
-    glXMakeCurrent(m_dpy, None, NULL);
-  }
-#endif
-#if defined(HAS_EGL)
-  if (m_eglContext)
-  {
-    glFinish();
-    eglMakeCurrent(m_eglDisplay, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
-  }
-#endif
-
   if (m_invisibleCursor)
   {
     XUndefineCursor(m_dpy, m_mainWindow);
@@ -491,272 +438,6 @@ bool CWinSystemX11::IsCurrentOutput(std::string output)
   return (StringUtils::EqualsNoCase(output, "Default")) || (m_currentOutput.compare(output.c_str()) == 0);
 }
 
-#if defined(HAS_EGL)
-EGLConfig getEGLConfig(EGLDisplay eglDisplay, XVisualInfo *vInfo)
-{
-  EGLint attributes[] =
-  {
-    EGL_DEPTH_SIZE, 24,
-    EGL_NONE
-  };
-  EGLint numConfigs;
-
-  if (!eglChooseConfig(eglDisplay, attributes, NULL, 0, &numConfigs))
-  {
-    CLog::Log(LOGERROR, "Failed to query number of egl configs");
-    return EGL_NO_CONFIG;
-  }
-  if (numConfigs == 0)
-  {
-    CLog::Log(LOGERROR, "No suitable egl configs found");
-    return EGL_NO_CONFIG;
-  }
-
-  EGLConfig *eglConfigs;
-  eglConfigs = (EGLConfig*)malloc(numConfigs * sizeof(EGLConfig));
-  if (!eglConfigs)
-  {
-    CLog::Log(LOGERROR, "eglConfigs malloc failed");
-    return EGL_NO_CONFIG;
-  }
-  EGLConfig eglConfig = EGL_NO_CONFIG;
-  if (!eglChooseConfig(eglDisplay, attributes, eglConfigs, numConfigs, &numConfigs))
-  {
-    CLog::Log(LOGERROR, "Failed to query egl configs");
-    goto Exit;
-  }
-  for (EGLint i = 0;i < numConfigs;++i)
-  {
-    EGLint value;
-    if (!eglGetConfigAttrib(eglDisplay, eglConfigs[i], EGL_NATIVE_VISUAL_ID, &value))
-    {
-      CLog::Log(LOGERROR, "Failed to query EGL_NATIVE_VISUAL_ID for egl config.");
-      break;
-    }
-    if (value == (EGLint)vInfo->visualid) {
-      eglConfig = eglConfigs[i];
-      break;
-    }
-  }
-
-Exit:
-  free(eglConfigs);
-  return eglConfig;
-}
-
-#endif
-
-bool CWinSystemX11::IsSuitableVisual(XVisualInfo *vInfo)
-{
-#if defined(HAS_GLX)
-  int value;
-  if (glXGetConfig(m_dpy, vInfo, GLX_RGBA, &value) || !value)
-    return false;
-  if (glXGetConfig(m_dpy, vInfo, GLX_DOUBLEBUFFER, &value) || !value)
-    return false;
-  if (glXGetConfig(m_dpy, vInfo, GLX_RED_SIZE, &value) || value < 8)
-    return false;
-  if (glXGetConfig(m_dpy, vInfo, GLX_GREEN_SIZE, &value) || value < 8)
-    return false;
-  if (glXGetConfig(m_dpy, vInfo, GLX_BLUE_SIZE, &value) || value < 8)
-    return false;
-  if (glXGetConfig(m_dpy, vInfo, GLX_ALPHA_SIZE, &value) || value < 8)
-    return false;
-  if (glXGetConfig(m_dpy, vInfo, GLX_DEPTH_SIZE, &value) || value < 8)
-    return false;
-#endif
-
-#if defined(HAS_EGL)
-  EGLConfig config = getEGLConfig(m_eglDisplay, vInfo);
-  if (config == EGL_NO_CONFIG)
-  {
-    CLog::Log(LOGERROR, "Failed to determine egl config for visual info");
-    return false;
-  }
-  EGLint value;
-
-  if (!eglGetConfigAttrib(m_eglDisplay, config, EGL_RED_SIZE, &value) || value < 8)
-    return false;
-  if (!eglGetConfigAttrib(m_eglDisplay, config, EGL_GREEN_SIZE, &value) || value < 8)
-    return false;
-  if (!eglGetConfigAttrib(m_eglDisplay, config, EGL_BLUE_SIZE, &value) || value < 8)
-    return false;
-  if (!eglGetConfigAttrib(m_eglDisplay, config, EGL_ALPHA_SIZE, &value) || value < 8)
-    return false;
-  if (!eglGetConfigAttrib(m_eglDisplay, config, EGL_DEPTH_SIZE, &value) || value < 24)
-    return false;
- 
-#endif
-  return true;
-}
-
-bool CWinSystemX11::RefreshGlxContext(bool force)
-{
-  bool retVal = false;
-
-#if defined(HAS_GLX)
-  if (m_glContext && !force)
-  {
-    CLog::Log(LOGDEBUG, "CWinSystemX11::RefreshGlxContext: refreshing context");
-    glXMakeCurrent(m_dpy, None, NULL);
-    glXMakeCurrent(m_dpy, m_glWindow, m_glContext);
-    return true;
-  }
-#endif
-
-#if defined(HAS_EGL)
-  if (m_eglContext && !force)
-  {
-    CLog::Log(LOGDEBUG, "CWinSystemX11::RefreshGlxContext: refreshing context");
-    eglMakeCurrent(m_eglDisplay, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
-    eglMakeCurrent(m_eglDisplay, m_eglSurface, m_eglSurface, m_eglContext);
-    return true;
-  }
-#endif
-
-
-  XVisualInfo vMask;
-  XVisualInfo *visuals;
-  XVisualInfo *vInfo      = NULL;
-  int availableVisuals    = 0;
-  vMask.screen = m_nScreen;
-  XWindowAttributes winAttr;
-
-  /* Assume a depth of 24 in case the below calls to XGetWindowAttributes()
-     or XGetVisualInfo() fail. That shouldn't happen unless something is
-     fatally wrong, but lets prepare for everything. */
-  vMask.depth = 24;
-
-  if (XGetWindowAttributes(m_dpy, m_glWindow, &winAttr))
-  {
-    vMask.visualid = XVisualIDFromVisual(winAttr.visual);
-    vInfo = XGetVisualInfo(m_dpy, VisualScreenMask | VisualIDMask, &vMask, &availableVisuals);
-    if (!vInfo)
-      CLog::Log(LOGWARNING, "Failed to get VisualInfo of SDL visual 0x%x", (unsigned) vMask.visualid);
-    else if(!IsSuitableVisual(vInfo))
-    {
-      CLog::Log(LOGWARNING, "Visual 0x%x of the SDL window is not suitable, looking for another one...",
-                (unsigned) vInfo->visualid);
-      vMask.depth = vInfo->depth;
-      XFree(vInfo);
-      vInfo = NULL;
-    }
-  }
-  else
-    CLog::Log(LOGWARNING, "Failed to get SDL window attributes");
-
-  /* As per glXMakeCurrent documentation, we have to use the same visual as
-     m_glWindow. Since that was not suitable for use, we try to use another
-     one with the same depth and hope that the used implementation is less
-     strict than the documentation. */
-  if (!vInfo)
-  {
-    visuals = XGetVisualInfo(m_dpy, VisualScreenMask | VisualDepthMask, &vMask, &availableVisuals);
-    for (int i = 0; i < availableVisuals; i++)
-    {
-      if (IsSuitableVisual(&visuals[i]))
-      {
-        vMask.visualid = visuals[i].visualid;
-        vInfo = XGetVisualInfo(m_dpy, VisualScreenMask | VisualIDMask, &vMask, &availableVisuals);
-        break;
-      }
-    }
-    XFree(visuals);
-  }
-
-  if (vInfo)
-  {
-    CLog::Log(LOGNOTICE, "Using visual 0x%x", (unsigned) vInfo->visualid);
-#if defined(HAS_GLX)
-    if (m_glContext)
-    {
-      glXMakeCurrent(m_dpy, None, NULL);
-      glXDestroyContext(m_dpy, m_glContext);
-      XSync(m_dpy, FALSE);
-      m_newGlContext = true;
-    }
-
-    if ((m_glContext = glXCreateContext(m_dpy, vInfo, NULL, True)))
-    {
-      // make this context current
-      glXMakeCurrent(m_dpy, m_glWindow, m_glContext);
-      retVal = true;
-    }
-    else
-      CLog::Log(LOGERROR, "GLX Error: Could not create context");
-#endif
-#if defined(HAS_EGL)
-    if (m_eglContext)
-    {
-      eglMakeCurrent(m_eglContext, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
-      eglDestroyContext(m_eglDisplay, m_eglContext);
-      m_eglContext = EGL_NO_CONTEXT;
-      eglDestroySurface(m_eglDisplay, m_eglSurface);
-      m_eglSurface = EGL_NO_SURFACE;
-      eglTerminate(m_eglDisplay);
-      m_eglDisplay = EGL_NO_DISPLAY;
-      XSync(m_dpy, FALSE);
-      m_newGlContext = true;
-    }
-
-    m_eglDisplay = eglGetDisplay((EGLNativeDisplayType)m_dpy);
-    if (m_eglDisplay == EGL_NO_DISPLAY)
-    {
-      CLog::Log(LOGERROR, "failed to get egl display\n");
-      return false;
-    }
-    if (!eglInitialize(m_eglDisplay, NULL, NULL))
-    {
-      CLog::Log(LOGERROR, "failed to initialize egl\n");
-      return false;
-    }
-
-    EGLConfig eglConfig = getEGLConfig(m_eglDisplay, vInfo);
-
-    if (eglConfig == EGL_NO_CONFIG)
-    {
-      CLog::Log(LOGERROR, "failed to get eglconfig for visual id\n");
-      return false;
-    }
-
-    if (m_eglSurface == EGL_NO_SURFACE)
-    {
-      m_eglSurface = eglCreateWindowSurface(m_eglDisplay, eglConfig, m_glWindow, NULL);
-      if (m_eglSurface == EGL_NO_SURFACE)
-      {
-        CLog::Log(LOGERROR, "failed to create EGL window surface %d\n", eglGetError());
-        return false;
-      }
-    }
-
-    EGLint contextAttributes[] =
-    {
-      EGL_CONTEXT_CLIENT_VERSION, 2,
-      EGL_NONE
-    };
-    m_eglContext = eglCreateContext(m_eglDisplay, eglConfig, EGL_NO_CONTEXT, contextAttributes);
-    if (m_eglContext == EGL_NO_CONTEXT)
-    {
-      CLog::Log(LOGERROR, "failed to create EGL context\n");
-      return false;
-    }
-
-    if (!eglMakeCurrent(m_eglDisplay, m_eglSurface, m_eglSurface, m_eglContext))
-    {
-      CLog::Log(LOGERROR, "Failed to make context current %p %p %p\n", m_eglDisplay, m_eglSurface, m_eglContext);
-      return false;
-    }
-#endif
-    XFree(vInfo);
-  }
-  else
-  {
-    CLog::Log(LOGERROR, "EGL/GLX Error: vInfo is NULL!");
-  }
-
-  return retVal;
-}
-
 void CWinSystemX11::ShowOSMouse(bool show)
 {
   if (show)
@@ -972,7 +653,7 @@ bool CWinSystemX11::EnableFrameLimiter()
   return m_minimized;
 }
 
-bool CWinSystemX11::SetWindow(int width, int height, bool fullscreen, const std::string &output)
+bool CWinSystemX11::SetWindow(int width, int height, bool fullscreen, const std::string &output, int *winstate)
 {
   bool changeWindow = false;
   bool changeSize = false;
@@ -1022,33 +703,6 @@ bool CWinSystemX11::SetWindow(int width, int height, bool fullscreen, const std:
   {
     EnableSystemScreenSaver(false);
 
-#if defined(HAS_GLX)
-    GLint att[] =
-    {
-      GLX_RGBA,
-      GLX_RED_SIZE, 8,
-      GLX_GREEN_SIZE, 8,
-      GLX_BLUE_SIZE, 8,
-      GLX_ALPHA_SIZE, 8,
-      GLX_DEPTH_SIZE, 24,
-      GLX_DOUBLEBUFFER,
-      None
-    };
-#endif
-#if defined(HAS_EGL)
-    EGLint att[] =
-    {
-      EGL_RED_SIZE, 8,
-      EGL_GREEN_SIZE, 8,
-      EGL_BLUE_SIZE, 8,
-      EGL_ALPHA_SIZE, 8,
-      EGL_BUFFER_SIZE, 32,
-      EGL_DEPTH_SIZE, 24,
-      EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
-      EGL_NONE
-    };
-#endif
-
     Colormap cmap;
     XSetWindowAttributes swa;
     XVisualInfo *vi;
@@ -1065,47 +719,8 @@ bool CWinSystemX11::SetWindow(int width, int height, bool fullscreen, const std:
       y0 = out->y;
     }
 
-#if defined(HAS_GLX)
-    vi = glXChooseVisual(m_dpy, m_nScreen, att);
-#endif
-#if defined(HAS_EGL)
-    if (m_eglDisplay == EGL_NO_DISPLAY)
-    {
-      m_eglDisplay = eglGetDisplay((EGLNativeDisplayType)m_dpy);
-      if (m_eglDisplay == EGL_NO_DISPLAY)
-      {
-        CLog::Log(LOGERROR, "failed to get egl display\n");
-	return false;
-      }
-      if (!eglInitialize(m_eglDisplay, NULL, NULL))
-      {
-	CLog::Log(LOGERROR, "failed to initialize egl display\n");
-	return false;
-      }
-    }
-
-    EGLint numConfigs;
-    EGLConfig eglConfig = 0;
-    if (!eglChooseConfig(m_eglDisplay, att, &eglConfig, 1, &numConfigs) || numConfigs == 0) {
-      CLog::Log(LOGERROR, "Failed to choose a config %d\n", eglGetError());
-    }
-
-    EGLint eglVisualid;
-    if (!eglGetConfigAttrib(m_eglDisplay, eglConfig, EGL_NATIVE_VISUAL_ID, &eglVisualid))
-    {
-      CLog::Log(LOGERROR, "Failed to query native visual id\n");
-    }
-    XVisualInfo x11_visual_info_template;
-    x11_visual_info_template.visualid = eglVisualid;
-    int num_visuals;
-    vi = XGetVisualInfo(m_dpy,
-                        VisualIDMask,
-                        &x11_visual_info_template,
-                        &num_visuals);
-
-#endif
-
-    if(!vi)
+    vi = GetVisual();
+    if (!vi)
     {
       CLog::Log(LOGERROR, "Failed to find matching visual");
       return false;
@@ -1162,21 +777,13 @@ bool CWinSystemX11::SetWindow(int width, int height, bool fullscreen, const std:
                                             &black, &black, 0, 0);
     XFreePixmap(m_dpy, bitmapNoData);
     XDefineCursor(m_dpy,m_mainWindow, m_invisibleCursor);
+    XFree(vi);
 
     //init X11 events
     CWinEventsX11Imp::Init(m_dpy, m_mainWindow);
 
     changeWindow = true;
     changeSize = true;
-
-#if defined(HAS_EGL)
-    m_eglSurface = eglCreateWindowSurface(m_eglDisplay, eglConfig, m_glWindow, NULL);
-    if (m_eglSurface == EGL_NO_SURFACE)
-    {
-      CLog::Log(LOGERROR, "failed to create egl window surface\n");
-      return false;
-    }
-#endif
   }
 
   if (!CWinEventsX11Imp::HasStructureChanged() && ((width != m_nWidth) || (height != m_nHeight)))
@@ -1239,24 +846,8 @@ bool CWinSystemX11::SetWindow(int width, int height, bool fullscreen, const std:
     // discard events generated by creating the window, i.e. xrr events
     XSync(m_dpy, TRUE);
 
-    CDirtyRegionList dr;
-    RefreshGlxContext(m_currentOutput.compare(output) != 0);
-    XSync(m_dpy, FALSE);
-    g_graphicsContext.Clear(0);
-    g_graphicsContext.Flip(dr);
-#if defined(HAS_GLX)
-    g_Windowing.ResetVSync();
-#endif
-    m_windowDirty = false;
-    m_bIsInternalXrr = false;
-
-// what's this???
-#if defined(HAS_GLX)
-    CSingleLock lock(m_resourceSection);
-    // tell any shared resources
-    for (vector<IDispResource *>::iterator i = m_resources.begin(); i != m_resources.end(); ++i)
-      (*i)->OnResetDevice();
-#endif
+    if (winstate)
+      *winstate = 1;
   }
 
   UpdateCrtc();
diff --git a/xbmc/windowing/X11/WinSystemX11.h b/xbmc/windowing/X11/WinSystemX11.h
index 5ac2482..77f31e0 100644
--- a/xbmc/windowing/X11/WinSystemX11.h
+++ b/xbmc/windowing/X11/WinSystemX11.h
@@ -1,8 +1,3 @@
-#ifndef WINDOW_SYSTEM_X11_H
-#define WINDOW_SYSTEM_X11_H
-
-#pragma once
-
 /*
  *      Copyright (C) 2005-2013 Team XBMC
  *      http://xbmc.org
@@ -23,20 +18,14 @@
  *
  */
 
-#include "system_gl.h"
-
-#if defined(HAS_GLX)
-#include <GL/glx.h>
-#endif
-
-#if defined(HAS_EGL)
-#include <EGL/egl.h>
-#endif
+#pragma once
 
 #include "windowing/WinSystem.h"
 #include "utils/Stopwatch.h"
 #include "threads/CriticalSection.h"
 #include "settings/lib/ISettingCallback.h"
+#include "X11/Xlib.h"
+#include "X11/Xutil.h"
 
 class IDispResource;
 
@@ -74,15 +63,6 @@ public:
 
   // Local to WinSystemX11 only
   Display*  GetDisplay() { return m_dpy; }
-#if defined(HAS_GLX)
-  GLXWindow GetWindow() { return m_glWindow; }
-  GLXContext GetGlxContext() { return m_glContext; }
-#endif
-#if defined(HAS_EGL)
-  EGLDisplay GetEGLDisplay() const { return m_eglDisplay;}
-  EGLSurface GetEGLSurface() const { return m_eglSurface;}
-  EGLContext GetEGLContext() const { return m_eglContext;}
-#endif
   void NotifyXRREvent();
   void GetConnectedOutputs(std::vector<std::string> *outputs);
   bool IsCurrentOutput(std::string output);
@@ -90,34 +70,25 @@ public:
   int GetCrtc() { return m_crtc; }
 
 protected:
-  bool RefreshGlxContext(bool force);
+  virtual bool SetWindow(int width, int height, bool fullscreen, const std::string &output, int *winstate = NULL) = 0;
+  virtual XVisualInfo* GetVisual() = 0;
+
   void OnLostDevice();
-  bool SetWindow(int width, int height, bool fullscreen, const std::string &output);
 
-  Window       m_glWindow, m_mainWindow;
-#if defined(HAS_GLX)
-  GLXContext   m_glContext;
-#endif
-#if defined(HAS_EGL)
-  EGLDisplay            m_eglDisplay;
-  EGLSurface            m_eglSurface;
-  EGLContext            m_eglContext;
-  EGLConfig             m_eglConfig;
-#endif
-  Display*     m_dpy;
-  Cursor       m_invisibleCursor;
-  Pixmap       m_icon;
-  bool         m_bIsRotated;
-  bool         m_bWasFullScreenBeforeMinimize;
-  bool         m_minimized;
-  bool         m_bIgnoreNextFocusMessage;
-  CCriticalSection             m_resourceSection;
+  Window m_glWindow, m_mainWindow;
+  Display *m_dpy;
+  Cursor m_invisibleCursor;
+  Pixmap m_icon;
+  bool m_bIsRotated;
+  bool m_bWasFullScreenBeforeMinimize;
+  bool m_minimized;
+  bool m_bIgnoreNextFocusMessage;
+  CCriticalSection m_resourceSection;
   std::vector<IDispResource*>  m_resources;
-  std::string                  m_currentOutput;
-  std::string                  m_userOutput;
-  bool                         m_windowDirty;
-  bool                         m_bIsInternalXrr;
-  bool                         m_newGlContext;
+  std::string m_currentOutput;
+  std::string m_userOutput;
+  bool m_windowDirty;
+  bool m_bIsInternalXrr;
   int m_MouseX, m_MouseY;
   int m_crtc;
 
@@ -130,6 +101,3 @@ private:
 
   CStopWatch m_screensaverReset;
 };
-
-#endif // WINDOW_SYSTEM_H
-
diff --git a/xbmc/windowing/X11/WinSystemX11GL.cpp b/xbmc/windowing/X11/WinSystemX11GL.cpp
deleted file mode 100644
index 4c3537f..0000000
--- a/xbmc/windowing/X11/WinSystemX11GL.cpp
+++ /dev/null
@@ -1,221 +0,0 @@
-/*
- *      Copyright (C) 2005-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-#include "system.h"
-
-#if defined(HAS_GLX) && !defined(HAS_EGL)
-
-#include "WinSystemX11GL.h"
-#include "utils/log.h"
-#include "utils/StringUtils.h"
-#include "Application.h"
-
-CWinSystemX11GL::CWinSystemX11GL()
-{
-  m_glXGetVideoSyncSGI   = NULL;
-  m_glXWaitVideoSyncSGI  = NULL;
-  m_glXSwapIntervalMESA  = NULL;
-  m_glXSwapIntervalEXT   = NULL;
-
-  m_iVSyncErrors = 0;
-}
-
-CWinSystemX11GL::~CWinSystemX11GL()
-{
-}
-
-bool CWinSystemX11GL::PresentRenderImpl(const CDirtyRegionList& dirty)
-{
-  if(m_iVSyncMode == 3)
-  {
-    glFinish();
-    unsigned int before = 0, after = 0;
-    if(m_glXGetVideoSyncSGI(&before) != 0)
-      CLog::Log(LOGERROR, "%s - glXGetVideoSyncSGI - Failed to get current retrace count", __FUNCTION__);
-
-    glXSwapBuffers(m_dpy, m_glWindow);
-    glFinish();
-
-    if(m_glXGetVideoSyncSGI(&after) != 0)
-      CLog::Log(LOGERROR, "%s - glXGetVideoSyncSGI - Failed to get current retrace count", __FUNCTION__);
-
-    if(after == before)
-      m_iVSyncErrors = 1;
-    else
-      m_iVSyncErrors--;
-
-    if(m_iVSyncErrors > 0)
-    {
-      CLog::Log(LOGINFO, "GL: retrace count didn't change after buffer swap, switching to vsync mode 4");
-      m_iVSyncErrors = 0;
-      m_iVSyncMode   = 4;
-    }
-
-    if(m_iVSyncErrors < -200)
-    {
-      CLog::Log(LOGINFO, "GL: retrace count change for %d consecutive buffer swap, switching to vsync mode 2", -m_iVSyncErrors);
-      m_iVSyncErrors = 0;
-      m_iVSyncMode   = 2;
-    }
-  }
-  else if (m_iVSyncMode == 4)
-  {
-    glFinish();
-    unsigned int before = 0, swap = 0, after = 0;
-    if(m_glXGetVideoSyncSGI(&before) != 0)
-      CLog::Log(LOGERROR, "%s - glXGetVideoSyncSGI - Failed to get current retrace count", __FUNCTION__);
-
-    if(m_glXWaitVideoSyncSGI(2, (before+1)%2, &swap) != 0)
-      CLog::Log(LOGERROR, "%s - glXWaitVideoSyncSGI - Returned error", __FUNCTION__);
-
-    glXSwapBuffers(m_dpy, m_glWindow);
-    glFinish();
-
-    if(m_glXGetVideoSyncSGI(&after) != 0)
-      CLog::Log(LOGERROR, "%s - glXGetVideoSyncSGI - Failed to get current retrace count", __FUNCTION__);
-
-    if(after == before)
-      CLog::Log(LOGERROR, "%s - glXWaitVideoSyncSGI - Woke up early", __FUNCTION__);
-
-    if(after > before + 1)
-      m_iVSyncErrors++;
-    else
-      m_iVSyncErrors = 0;
-
-    if(m_iVSyncErrors > 30)
-    {
-      CLog::Log(LOGINFO, "GL: retrace count seems to be changing due to the swapbuffers call, switching to vsync mode 3");
-      m_iVSyncMode   = 3;
-      m_iVSyncErrors = 0;
-    }
-  }
-  else
-    glXSwapBuffers(m_dpy, m_glWindow);
-
-  return true;
-}
-
-void CWinSystemX11GL::SetVSyncImpl(bool enable)
-{
-  /* turn of current setting first */
-  if(m_glXSwapIntervalEXT)
-    m_glXSwapIntervalEXT(m_dpy, m_glWindow, 0);
-  else if(m_glXSwapIntervalMESA)
-    m_glXSwapIntervalMESA(0);
-
-  m_iVSyncErrors = 0;
-
-  if(!enable)
-    return;
-
-  if (m_glXSwapIntervalEXT && !m_iVSyncMode)
-  {
-    m_glXSwapIntervalEXT(m_dpy, m_glWindow, 1);
-    m_iVSyncMode = 6;
-  }
-  if (m_glXSwapIntervalMESA && !m_iVSyncMode)
-  {
-    if(m_glXSwapIntervalMESA(1) == 0)
-      m_iVSyncMode = 2;
-    else
-      CLog::Log(LOGWARNING, "%s - glXSwapIntervalMESA failed", __FUNCTION__);
-  }
-  if (m_glXWaitVideoSyncSGI && m_glXGetVideoSyncSGI && !m_iVSyncMode)
-  {
-    unsigned int count;
-    if(m_glXGetVideoSyncSGI(&count) == 0)
-        m_iVSyncMode = 3;
-    else
-      CLog::Log(LOGWARNING, "%s - glXGetVideoSyncSGI failed, glcontext probably not direct", __FUNCTION__);
-  }
-}
-
-bool CWinSystemX11GL::IsExtSupported(const char* extension)
-{
-  if(strncmp(extension, "GLX_", 4) != 0)
-    return CRenderSystemGL::IsExtSupported(extension);
-
-  std::string name;
-
-  name  = " ";
-  name += extension;
-  name += " ";
-
-  return m_glxext.find(name) != std::string::npos;
-}
-
-bool CWinSystemX11GL::CreateNewWindow(const std::string& name, bool fullScreen, RESOLUTION_INFO& res, PHANDLE_EVENT_FUNC userFunction)
-{
-  if(!CWinSystemX11::CreateNewWindow(name, fullScreen, res, userFunction))
-    return false;
-
-  m_glxext  = " ";
-  m_glxext += (const char*)glXQueryExtensionsString(m_dpy, m_nScreen);
-  m_glxext += " ";
-
-  CLog::Log(LOGDEBUG, "GLX_EXTENSIONS:%s", m_glxext.c_str());
-
-  if (IsExtSupported("GLX_SGI_video_sync"))
-    m_glXWaitVideoSyncSGI = (int (*)(int, int, unsigned int*))glXGetProcAddress((const GLubyte*)"glXWaitVideoSyncSGI");
-  else
-    m_glXWaitVideoSyncSGI = NULL;
-
-  if (IsExtSupported("GLX_SGI_video_sync"))
-    m_glXGetVideoSyncSGI = (int (*)(unsigned int*))glXGetProcAddress((const GLubyte*)"glXGetVideoSyncSGI");
-  else
-    m_glXGetVideoSyncSGI = NULL;
-
-  if (IsExtSupported("GLX_MESA_swap_control"))
-    m_glXSwapIntervalMESA = (int (*)(int))glXGetProcAddress((const GLubyte*)"glXSwapIntervalMESA");
-  else
-    m_glXSwapIntervalMESA = NULL;
-
-  if (IsExtSupported("GLX_EXT_swap_control"))
-    m_glXSwapIntervalEXT = (PFNGLXSWAPINTERVALEXTPROC)glXGetProcAddress((const GLubyte*)"glXSwapIntervalEXT");
-  else
-    m_glXSwapIntervalEXT = NULL;
-
-  return true;
-}
-
-bool CWinSystemX11GL::ResizeWindow(int newWidth, int newHeight, int newLeft, int newTop)
-{
-  m_newGlContext = false;
-  CWinSystemX11::ResizeWindow(newWidth, newHeight, newLeft, newTop);
-  CRenderSystemGL::ResetRenderSystem(newWidth, newHeight, false, 0);
-
-  if (m_newGlContext)
-    g_application.ReloadSkin();
-
-  return true;
-}
-
-bool CWinSystemX11GL::SetFullScreen(bool fullScreen, RESOLUTION_INFO& res, bool blankOtherDisplays)
-{
-  m_newGlContext = false;
-  CWinSystemX11::SetFullScreen(fullScreen, res, blankOtherDisplays);
-  CRenderSystemGL::ResetRenderSystem(res.iWidth, res.iHeight, fullScreen, res.fRefreshRate);
-
-  if (m_newGlContext)
-    g_application.ReloadSkin();
-
-  return true;
-}
-
-#endif
diff --git a/xbmc/windowing/X11/WinSystemX11GL.h b/xbmc/windowing/X11/WinSystemX11GL.h
deleted file mode 100644
index dc3ad22..0000000
--- a/xbmc/windowing/X11/WinSystemX11GL.h
+++ /dev/null
@@ -1,60 +0,0 @@
-#ifndef WINDOW_SYSTEM_X11_GL_H
-#define WINDOW_SYSTEM_X11_GL_H
-
-#pragma once
-
-#if defined(HAVE_LIBGL)
-/*
- *      Copyright (C) 2005-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-#include "WinSystemX11.h"
-#include "rendering/gl/RenderSystemGL.h"
-#include "utils/GlobalsHandling.h"
-
-class CWinSystemX11GL : public CWinSystemX11, public CRenderSystemGL
-{
-public:
-  CWinSystemX11GL();
-  virtual ~CWinSystemX11GL();
-  virtual bool CreateNewWindow(const std::string& name, bool fullScreen, RESOLUTION_INFO& res, PHANDLE_EVENT_FUNC userFunction);
-  virtual bool ResizeWindow(int newWidth, int newHeight, int newLeft, int newTop);
-  virtual bool SetFullScreen(bool fullScreen, RESOLUTION_INFO& res, bool blankOtherDisplays);
-
-  virtual bool IsExtSupported(const char* extension);
-
-protected:
-  virtual bool PresentRenderImpl(const CDirtyRegionList& dirty);
-  virtual void SetVSyncImpl(bool enable);
-
-  std::string m_glxext;
-
-  int (*m_glXGetVideoSyncSGI)(unsigned int*);
-  int (*m_glXWaitVideoSyncSGI)(int, int, unsigned int*);
-  int (*m_glXSwapIntervalMESA)(int);
-  PFNGLXSWAPINTERVALEXTPROC m_glXSwapIntervalEXT;
-
-  int m_iVSyncErrors;
-};
-
-XBMC_GLOBAL_REF(CWinSystemX11GL,g_Windowing);
-#define g_Windowing XBMC_GLOBAL_USE(CWinSystemX11GL)
-
-#endif // HAVE_LIBGL
-
-#endif // WINDOW_SYSTEM_H
diff --git a/xbmc/windowing/X11/WinSystemX11GLContext.cpp b/xbmc/windowing/X11/WinSystemX11GLContext.cpp
new file mode 100644
index 0000000..ec5a89f
--- /dev/null
+++ b/xbmc/windowing/X11/WinSystemX11GLContext.cpp
@@ -0,0 +1,188 @@
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#include "system.h"
+
+#if defined(HAVE_X11)
+
+#include <X11/Xlib.h>
+#include <X11/Xutil.h>
+
+#include "WinSystemX11GLContext.h"
+#include "utils/log.h"
+#include "utils/StringUtils.h"
+#include "guilib/GraphicContext.h"
+#include "guilib/DispResource.h"
+#include "threads/SingleLock.h"
+#include <vector>
+#include "Application.h"
+#include "GLContextEGL.h"
+#include "GLContextGLX.h"
+
+CWinSystemX11GLContext::CWinSystemX11GLContext()
+{
+  m_pGLContext = NULL;
+}
+
+CWinSystemX11GLContext::~CWinSystemX11GLContext()
+{
+  delete m_pGLContext;
+}
+
+bool CWinSystemX11GLContext::PresentRenderImpl(const CDirtyRegionList& dirty)
+{
+  m_pGLContext->SwapBuffers(dirty, m_iVSyncMode);
+}
+
+void CWinSystemX11GLContext::SetVSyncImpl(bool enable)
+{
+  m_pGLContext->SetVSync(enable, m_iVSyncMode);
+}
+
+bool CWinSystemX11GLContext::IsExtSupported(const char* extension)
+{
+  if(strncmp(extension, m_pGLContext->ExtPrefix().c_str(), 4) != 0)
+    return CRenderSystemGL::IsExtSupported(extension);
+
+  return m_pGLContext->IsExtSupported(extension);
+}
+
+bool CWinSystemX11GLContext::SetWindow(int width, int height, bool fullscreen, const std::string &output, int *winstate)
+{
+  int newwin = 0;
+  CWinSystemX11::SetWindow(width, height, fullscreen, output, &newwin);
+  if (newwin)
+  {
+    CDirtyRegionList dr;
+    RefreshGLContext(m_currentOutput.compare(output) != 0);
+    XSync(m_dpy, FALSE);
+    g_graphicsContext.Clear(0);
+    g_graphicsContext.Flip(dr);
+    ResetVSync();
+
+    m_windowDirty = false;
+    m_bIsInternalXrr = false;
+
+    CSingleLock lock(m_resourceSection);
+    // tell any shared resources
+    for (std::vector<IDispResource *>::iterator i = m_resources.begin(); i != m_resources.end(); ++i)
+      (*i)->OnResetDevice();
+  }
+  return true;
+}
+
+bool CWinSystemX11GLContext::CreateNewWindow(const std::string& name, bool fullScreen, RESOLUTION_INFO& res, PHANDLE_EVENT_FUNC userFunction)
+{
+  if(!CWinSystemX11::CreateNewWindow(name, fullScreen, res, userFunction))
+    return false;
+
+  m_pGLContext->QueryExtensions();
+  return true;
+}
+
+bool CWinSystemX11GLContext::ResizeWindow(int newWidth, int newHeight, int newLeft, int newTop)
+{
+  m_newGlContext = false;
+  CWinSystemX11::ResizeWindow(newWidth, newHeight, newLeft, newTop);
+  CRenderSystemGL::ResetRenderSystem(newWidth, newHeight, false, 0);
+
+  if (m_newGlContext)
+    g_application.ReloadSkin();
+
+  return true;
+}
+
+bool CWinSystemX11GLContext::SetFullScreen(bool fullScreen, RESOLUTION_INFO& res, bool blankOtherDisplays)
+{
+  m_newGlContext = false;
+  CWinSystemX11::SetFullScreen(fullScreen, res, blankOtherDisplays);
+  CRenderSystemGL::ResetRenderSystem(res.iWidth, res.iHeight, fullScreen, res.fRefreshRate);
+
+  if (m_newGlContext)
+    g_application.ReloadSkin();
+
+  return true;
+}
+
+bool CWinSystemX11GLContext::DestroyWindowSystem()
+{
+  bool ret;
+  m_pGLContext->Destroy();
+  ret = CWinSystemX11::DestroyWindowSystem();
+  return ret;
+}
+
+bool CWinSystemX11GLContext::DestroyWindow()
+{
+  bool ret;
+  m_pGLContext->Detach();
+  ret = CWinSystemX11::DestroyWindow();
+  return ret;
+}
+
+XVisualInfo* CWinSystemX11GLContext::GetVisual()
+{
+  GLint att[] =
+  {
+    GLX_RGBA,
+    GLX_RED_SIZE, 8,
+    GLX_GREEN_SIZE, 8,
+    GLX_BLUE_SIZE, 8,
+    GLX_ALPHA_SIZE, 8,
+    GLX_DEPTH_SIZE, 24,
+    GLX_DOUBLEBUFFER,
+    None
+  };
+  return glXChooseVisual(m_dpy, m_nScreen, att);
+}
+
+bool CWinSystemX11GLContext::RefreshGLContext(bool force)
+{
+  bool firstrun = false;
+  if (!m_pGLContext)
+  {
+    m_pGLContext = new CGLContextEGL(m_dpy);
+    firstrun = true;
+  }
+  bool ret = m_pGLContext->Refresh(force, m_nScreen, m_glWindow, m_newGlContext);
+
+  if (ret && !firstrun)
+    return ret;
+
+  std::string gpuvendor = "";
+  if (ret)
+  {
+    gpuvendor = (const char*) glGetString(GL_VENDOR);
+  }
+  std::transform(gpuvendor.begin(), gpuvendor.end(), gpuvendor.begin(), ::tolower);
+  if (firstrun && (!ret || gpuvendor.compare(0, 5, "intel") != 0))
+  {
+    delete m_pGLContext;
+    m_pGLContext = new CGLContextGLX(m_dpy);
+    ret = m_pGLContext->Refresh(force, m_nScreen, m_glWindow, m_newGlContext);
+  }
+  return ret;
+}
+
+bool CWinSystemX11GLContext::DestroyGLContext()
+{
+  m_pGLContext->Destroy();
+}
+
+#endif
diff --git a/xbmc/windowing/X11/WinSystemX11GLContext.h b/xbmc/windowing/X11/WinSystemX11GLContext.h
new file mode 100644
index 0000000..c73234e
--- /dev/null
+++ b/xbmc/windowing/X11/WinSystemX11GLContext.h
@@ -0,0 +1,67 @@
+/*
+ *      Copyright (C) 2005-2014 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#pragma once
+
+#if defined(HAVE_X11)
+
+#include "WinSystemX11.h"
+#include "GLContext.h"
+#include "rendering/gl/RenderSystemGL.h"
+#include "utils/GlobalsHandling.h"
+#include "GL/glx.h"
+#include "EGL/egl.h"
+
+class CWinSystemX11GLContext : public CWinSystemX11, public CRenderSystemGL
+{
+public:
+  CWinSystemX11GLContext();
+  virtual ~CWinSystemX11GLContext();
+  virtual bool CreateNewWindow(const std::string& name, bool fullScreen, RESOLUTION_INFO& res, PHANDLE_EVENT_FUNC userFunction);
+  virtual bool ResizeWindow(int newWidth, int newHeight, int newLeft, int newTop);
+  virtual bool SetFullScreen(bool fullScreen, RESOLUTION_INFO& res, bool blankOtherDisplays);
+  virtual bool DestroyWindowSystem();
+  virtual bool DestroyWindow();
+
+  virtual bool IsExtSupported(const char* extension);
+
+  GLXWindow GetWindow() { return m_pGLContext->m_glxWindow; }
+  GLXContext GetGlxContext() { return m_pGLContext->m_glxContext; }
+  EGLDisplay GetEGLDisplay() const { return m_pGLContext->m_eglDisplay; }
+  EGLSurface GetEGLSurface() const { return m_pGLContext->m_eglSurface; }
+  EGLContext GetEGLContext() const { return m_pGLContext->m_eglContext; }
+  EGLConfig GetEGLConfig() const { return m_pGLContext->m_eglConfig; }
+
+protected:
+  virtual bool SetWindow(int width, int height, bool fullscreen, const std::string &output, int *winstate = NULL);
+  virtual bool PresentRenderImpl(const CDirtyRegionList& dirty);
+  virtual void SetVSyncImpl(bool enable);
+  virtual bool RefreshGLContext(bool force);
+  virtual bool DestroyGLContext();
+  virtual XVisualInfo* GetVisual();
+
+  CGLContext *m_pGLContext;
+  bool m_newGlContext;
+};
+
+XBMC_GLOBAL_REF(CWinSystemX11GLContext,g_Windowing);
+#define g_Windowing XBMC_GLOBAL_USE(CWinSystemX11GLContext)
+
+#endif //HAVE_X11
diff --git a/xbmc/windowing/X11/WinSystemX11GLES.cpp b/xbmc/windowing/X11/WinSystemX11GLES.cpp
deleted file mode 100644
index 4dc3907..0000000
--- a/xbmc/windowing/X11/WinSystemX11GLES.cpp
+++ /dev/null
@@ -1,107 +0,0 @@
-/*
- *      Copyright (C) 2005-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-#include "system.h"
-
-#if defined(HAS_EGL) && defined(HAVE_X11)
-
-#include <X11/Xlib.h>
-#include <X11/Xutil.h>
-
-#include "WinSystemX11GLES.h"
-#include "utils/log.h"
-#include "utils/StringUtils.h"
-#include "Application.h"
-#include "windowing/egl/EGLWrapper.h"
-
-CWinSystemX11GLES::CWinSystemX11GLES()
-{
-}
-
-CWinSystemX11GLES::~CWinSystemX11GLES()
-{
-}
-
-bool CWinSystemX11GLES::PresentRenderImpl(const CDirtyRegionList& dirty)
-{
-  if ((m_eglDisplay == EGL_NO_DISPLAY) || (m_eglSurface == EGL_NO_SURFACE))
-    return false;
-
-  eglSwapBuffers(m_eglDisplay, m_eglSurface);
-
-  return true;
-}
-
-void CWinSystemX11GLES::SetVSyncImpl(bool enable)
-{
-  eglSwapInterval(m_eglDisplay, enable ? 1 : 0);
-}
-
-bool CWinSystemX11GLES::IsExtSupported(const char* extension)
-{
-  if(strncmp(extension, "EGL_", 4) != 0)
-    return CRenderSystemGLES::IsExtSupported(extension);
-
-  std::string name;
-
-  name  = " ";
-  name += extension;
-  name += " ";
-
-  return m_eglext.find(name) != std::string::npos;
-}
-
-bool CWinSystemX11GLES::CreateNewWindow(const std::string& name, bool fullScreen, RESOLUTION_INFO& res, PHANDLE_EVENT_FUNC userFunction)
-{
-  if(!CWinSystemX11::CreateNewWindow(name, fullScreen, res, userFunction))
-    return false;
-
-  std::string extensions = eglQueryString(m_eglDisplay, EGL_EXTENSIONS);
-  m_eglext = std::string(" ") + extensions + " ";
-
-  CLog::Log(LOGDEBUG, "EGL_EXTENSIONS:%s", m_eglext.c_str());
-
-  return true;
-}
-
-bool CWinSystemX11GLES::ResizeWindow(int newWidth, int newHeight, int newLeft, int newTop)
-{
-  m_newGlContext = false;
-  CWinSystemX11::ResizeWindow(newWidth, newHeight, newLeft, newTop);
-  CRenderSystemGLES::ResetRenderSystem(newWidth, newHeight, false, 0);
-
-  if (m_newGlContext)
-    g_application.ReloadSkin();
-
-  return true;
-}
-
-bool CWinSystemX11GLES::SetFullScreen(bool fullScreen, RESOLUTION_INFO& res, bool blankOtherDisplays)
-{
-  m_newGlContext = false;
-  CWinSystemX11::SetFullScreen(fullScreen, res, blankOtherDisplays);
-  CRenderSystemGLES::ResetRenderSystem(res.iWidth, res.iHeight, fullScreen, res.fRefreshRate);
-
-  if (m_newGlContext)
-    g_application.ReloadSkin();
-
-  return true;
-}
-
-#endif
diff --git a/xbmc/windowing/X11/WinSystemX11GLES.h b/xbmc/windowing/X11/WinSystemX11GLES.h
deleted file mode 100644
index 1df3e6a..0000000
--- a/xbmc/windowing/X11/WinSystemX11GLES.h
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
- *      Copyright (C) 2005-2014 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-
-#pragma once
-
-#if defined(HAS_GLES) && defined(HAVE_X11)
-
-#include "WinSystemX11.h"
-#include "rendering/gles/RenderSystemGLES.h"
-#include "utils/GlobalsHandling.h"
-
-class CWinSystemX11GLES : public CWinSystemX11, public CRenderSystemGLES
-{
-public:
-  CWinSystemX11GLES();
-  virtual ~CWinSystemX11GLES();
-  virtual bool CreateNewWindow(const std::string& name, bool fullScreen, RESOLUTION_INFO& res, PHANDLE_EVENT_FUNC userFunction);
-  virtual bool ResizeWindow(int newWidth, int newHeight, int newLeft, int newTop);
-  virtual bool SetFullScreen(bool fullScreen, RESOLUTION_INFO& res, bool blankOtherDisplays);
-
-  virtual bool IsExtSupported(const char* extension);
-
-protected:
-  virtual bool PresentRenderImpl(const CDirtyRegionList& dirty);
-  virtual void SetVSyncImpl(bool enable);
-
-  std::string m_eglext;
-};
-
-XBMC_GLOBAL_REF(CWinSystemX11GLES,g_Windowing);
-#define g_Windowing XBMC_GLOBAL_USE(CWinSystemX11GLES)
-
-#endif // HAS_GLES && HAVE_X11
diff --git a/xbmc/windowing/windows/WinSystemWin32GL.cpp b/xbmc/windowing/windows/WinSystemWin32GL.cpp
index 5dbc38a..fa5b502 100644
--- a/xbmc/windowing/windows/WinSystemWin32GL.cpp
+++ b/xbmc/windowing/windows/WinSystemWin32GL.cpp
@@ -30,7 +30,6 @@
 #include "guilib/gui3d.h"
 
 #ifdef HAS_GL
-#include <GL/glew.h>
 
 #pragma comment (lib,"opengl32.lib")
 #pragma comment (lib,"glu32.lib")
-- 
1.9.1


From 500aac8de4cadb9450f69fb1b0dfccdaf8eac764 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Fri, 26 Jun 2015 19:46:25 +0200
Subject: [PATCH 04/21] vaapi egl-yuv

---
 system/shaders/yuv2rgb_basic.glsl                  |   2 +-
 .../VideoRenderers/HwDecRender/RendererVAAPI.cpp   | 138 ++++++++-------------
 .../VideoRenderers/VideoShaders/YUV2RGBShader.cpp  |   4 +-
 xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp     | 133 ++++++++++++--------
 xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.h       |   3 +
 5 files changed, 138 insertions(+), 142 deletions(-)

diff --git a/system/shaders/yuv2rgb_basic.glsl b/system/shaders/yuv2rgb_basic.glsl
index 92b9be7..13fe0ec 100644
--- a/system/shaders/yuv2rgb_basic.glsl
+++ b/system/shaders/yuv2rgb_basic.glsl
@@ -69,7 +69,7 @@ void main()
   rgb.a = gl_Color.a;
   gl_FragColor = rgb;
 
-#elif defined(XBMC_VDPAU_NV12)
+#elif defined(XBMC_NV12_RRG)
 
   vec4 yuv, rgb;
   yuv.rgba = vec4( texture2D(m_sampY, stretch(m_cordY)).r
diff --git a/xbmc/cores/VideoRenderers/HwDecRender/RendererVAAPI.cpp b/xbmc/cores/VideoRenderers/HwDecRender/RendererVAAPI.cpp
index a7df758..4c30f24 100644
--- a/xbmc/cores/VideoRenderers/HwDecRender/RendererVAAPI.cpp
+++ b/xbmc/cores/VideoRenderers/HwDecRender/RendererVAAPI.cpp
@@ -27,6 +27,7 @@
 #include "settings/Settings.h"
 #include "settings/AdvancedSettings.h"
 #include "utils/log.h"
+#include "utils/GLUtils.h"
 
 CRendererVAAPI::CRendererVAAPI()
 {
@@ -79,19 +80,7 @@ CRenderInfo CRendererVAAPI::GetRenderInfo()
 
 bool CRendererVAAPI::Supports(ERENDERFEATURE feature)
 {
-  if (m_format == RENDER_FMT_VAAPINV12)
-    return CLinuxRendererGL::Supports(feature);
-
-  if (feature == RENDERFEATURE_STRETCH         ||
-      feature == RENDERFEATURE_ZOOM            ||
-      feature == RENDERFEATURE_VERTICAL_SHIFT  ||
-      feature == RENDERFEATURE_PIXEL_RATIO     ||
-      feature == RENDERFEATURE_POSTPROCESS     ||
-      feature == RENDERFEATURE_ROTATION        ||
-      feature == RENDERFEATURE_NONLINSTRETCH)
-    return true;
-
-  return false;
+  return CLinuxRendererGL::Supports(feature);
 }
 
 bool CRendererVAAPI::Supports(EINTERLACEMETHOD method)
@@ -104,67 +93,17 @@ bool CRendererVAAPI::Supports(EINTERLACEMETHOD method)
 
 bool CRendererVAAPI::Supports(ESCALINGMETHOD method)
 {
-  if (m_format == RENDER_FMT_VAAPINV12)
-    return CLinuxRendererGL::Supports(method);
-
-  //nearest neighbor doesn't work on YUY2 and UYVY
-  if (method == VS_SCALINGMETHOD_NEAREST &&
-      m_format != RENDER_FMT_YUYV422 &&
-      m_format != RENDER_FMT_UYVY422)
-    return true;
-
-  if(method == VS_SCALINGMETHOD_LINEAR
-  || method == VS_SCALINGMETHOD_AUTO)
-    return true;
-
-  if(method == VS_SCALINGMETHOD_CUBIC
-  || method == VS_SCALINGMETHOD_LANCZOS2
-  || method == VS_SCALINGMETHOD_SPLINE36_FAST
-  || method == VS_SCALINGMETHOD_LANCZOS3_FAST
-  || method == VS_SCALINGMETHOD_SPLINE36
-  || method == VS_SCALINGMETHOD_LANCZOS3)
-  {
-    // if scaling is below level, avoid hq scaling
-    float scaleX = fabs(((float)m_sourceWidth - m_destRect.Width())/m_sourceWidth)*100;
-    float scaleY = fabs(((float)m_sourceHeight - m_destRect.Height())/m_sourceHeight)*100;
-    int minScale = CSettings::Get().GetInt("videoplayer.hqscalers");
-    if (scaleX < minScale && scaleY < minScale)
-      return false;
-
-    // spline36 and lanczos3 are only allowed through advancedsettings.xml
-    if(method != VS_SCALINGMETHOD_SPLINE36
-        && method != VS_SCALINGMETHOD_LANCZOS3)
-      return true;
-    else
-      return g_advancedSettings.m_videoEnableHighQualityHwScalers;
-  }
-
-  return false;
+  return CLinuxRendererGL::Supports(method);
 }
 
 bool CRendererVAAPI::LoadShadersHook()
 {
-  if (m_format == RENDER_FMT_VAAPINV12)
-    return false;
-
-  CLog::Log(LOGNOTICE, "GL: Using VAAPI render method");
-  m_renderMethod = RENDER_VAAPI;
-  return true;
+  return false;
 }
 
 bool CRendererVAAPI::RenderHook(int idx)
 {
-  if (m_format == RENDER_FMT_VAAPINV12)
-    return false;
-
-  UpdateVideoFilter();
-  RenderRGB(idx, m_currentField);
-  YUVBUFFER &buf = m_buffers[idx];
-  if (buf.hwDec)
-  {
-    ((VAAPI::CVaapiRenderPicture*)buf.hwDec)->Sync();
-  }
-  return true;
+  return false;
 }
 
 bool CRendererVAAPI::CreateTexture(int index)
@@ -184,6 +123,8 @@ bool CRendererVAAPI::CreateTexture(int index)
   memset(&fields, 0, sizeof(fields));
   im.height = m_sourceHeight;
   im.width  = m_sourceWidth;
+  im.cshift_x = 1;
+  im.cshift_y = 1;
 
   plane.texwidth  = im.width;
   plane.texheight = im.height;
@@ -204,11 +145,14 @@ void CRendererVAAPI::DeleteTexture(int index)
     return;
   }
 
-  YUVPLANE &plane = m_buffers[index].fields[FIELD_FULL][0];
   if (m_buffers[index].hwDec)
     ((VAAPI::CVaapiRenderPicture*)m_buffers[index].hwDec)->Release();
   m_buffers[index].hwDec = NULL;
-  plane.id = 0;
+
+  YUVFIELDS &fields = m_buffers[index].fields;
+  fields[FIELD_FULL][0].id = None;
+  fields[FIELD_FULL][1].id = None;
+  fields[FIELD_FULL][2].id = None;
 }
 
 bool CRendererVAAPI::UploadTexture(int index)
@@ -220,40 +164,56 @@ bool CRendererVAAPI::UploadTexture(int index)
 
   VAAPI::CVaapiRenderPicture *vaapi = (VAAPI::CVaapiRenderPicture*)m_buffers[index].hwDec;
 
+  YV12Image &im = m_buffers[index].image;
+
   YUVFIELDS &fields = m_buffers[index].fields;
-  YUVPLANE &plane = fields[FIELD_FULL][0];
 
   if (!vaapi || !vaapi->valid)
   {
     return false;
   }
 
-  plane.id = vaapi->texture;
+  im.height = vaapi->texHeight;
+  im.width  = vaapi->texWidth;
+
+
+  YUVPLANES &planes = fields[0];
+
+  planes[0].texwidth  = im.width;
+  planes[0].texheight = im.height;
 
-  // in stereoscopic mode sourceRect may only
-  // be a part of the source video surface
-  plane.rect = m_sourceRect;
+  planes[1].texwidth  = planes[0].texwidth  >> im.cshift_x;
+  planes[1].texheight = planes[0].texheight >> im.cshift_y;
+  planes[2].texwidth  = planes[1].texwidth;
+  planes[2].texheight = planes[1].texheight;
 
-  // clip rect
-  if (vaapi->crop.x1 > plane.rect.x1)
-    plane.rect.x1 = vaapi->crop.x1;
-  if (vaapi->crop.x2 < plane.rect.x2)
-    plane.rect.x2 = vaapi->crop.x2;
-  if (vaapi->crop.y1 > plane.rect.y1)
-    plane.rect.y1 = vaapi->crop.y1;
-  if (vaapi->crop.y2 < plane.rect.y2)
-    plane.rect.y2 = vaapi->crop.y2;
+  for (int p = 0; p < 3; p++)
+  {
+    planes[p].pixpertex_x = 1;
+    planes[p].pixpertex_y = 1;
+  }
 
-  plane.texheight = vaapi->texHeight;
-  plane.texwidth  = vaapi->texWidth;
+  // set textures
+  fields[0][0].id = vaapi->textureY;
+  fields[0][1].id = vaapi->textureVU;
+  fields[0][2].id = vaapi->textureVU;
 
-  if (m_textureTarget == GL_TEXTURE_2D)
+  glEnable(m_textureTarget);
+
+  for (int p=0; p<2; p++)
   {
-    plane.rect.y1 /= plane.texheight;
-    plane.rect.y2 /= plane.texheight;
-    plane.rect.x1 /= plane.texwidth;
-    plane.rect.x2 /= plane.texwidth;
+    glBindTexture(m_textureTarget,fields[0][p].id);
+    glTexParameteri(m_textureTarget, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+    glTexParameteri(m_textureTarget, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+    glTexParameteri(m_textureTarget, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+    glTexParameteri(m_textureTarget, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+
+    glBindTexture(m_textureTarget, 0);
+    VerifyGLState();
   }
+
+  CalculateTextureSourceRects(index, 3);
+  glDisable(m_textureTarget);
   return true;
 }
 
diff --git a/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.cpp b/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.cpp
index 8c95825..46a192c 100644
--- a/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.cpp
+++ b/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.cpp
@@ -216,7 +216,9 @@ BaseYUV2RGBGLSLShader::BaseYUV2RGBGLSLShader(bool rect, unsigned flags, ERenderF
   else if (m_format == RENDER_FMT_UYVY422 || m_format == RENDER_FMT_CVBREF)
     m_defines += "#define XBMC_UYVY\n";
   else if (m_format == RENDER_FMT_VDPAU_420)
-    m_defines += "#define XBMC_VDPAU_NV12\n";
+    m_defines += "#define XBMC_NV12_RRG\n";
+  else if (m_format == RENDER_FMT_VAAPI)
+    m_defines += "#define XBMC_NV12_RRG\n";
   else
     CLog::Log(LOGERROR, "GL: BaseYUV2RGBGLSLShader - unsupported format %d", m_format);
 
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp
index 2df8889..835229b 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp
@@ -1208,7 +1208,7 @@ bool CVaapiRenderPicture::GLMapSurface()
     return false;
   }
   memset(&glInterop.vBufInfo, 0, sizeof(glInterop.vBufInfo));
-  glInterop.vBufInfo.mem_type = VA_SURFACE_ATTRIB_MEM_TYPE_KERNEL_DRM; //VA_SURFACE_ATTRIB_MEM_TYPE_DRM_PRIME;
+  glInterop.vBufInfo.mem_type = VA_SURFACE_ATTRIB_MEM_TYPE_DRM_PRIME;
   status = vaAcquireBufferHandle(glInterop.vadsp, glInterop.vaImage.buf,
                                  &glInterop.vBufInfo);
   if (status != VA_STATUS_SUCCESS)
@@ -1226,9 +1226,9 @@ bool CVaapiRenderPicture::GLMapSurface()
     {
       attrib = attribs;
       *attrib++ = EGL_LINUX_DRM_FOURCC_EXT;
-      *attrib++ = fourcc_code('R','8',' ',' ');
+      *attrib++ = fourcc_code('R', '8', ' ', ' ');
       *attrib++ = EGL_WIDTH;
-      *attrib++ = glInterop.vaImage.width / 4;
+      *attrib++ = glInterop.vaImage.width;
       *attrib++ = EGL_HEIGHT;
       *attrib++ = glInterop.vaImage.height;
       *attrib++ = EGL_DMA_BUF_PLANE0_FD_EXT;
@@ -1238,38 +1238,69 @@ bool CVaapiRenderPicture::GLMapSurface()
       *attrib++ = EGL_DMA_BUF_PLANE0_PITCH_EXT;
       *attrib++ = glInterop.vaImage.pitches[0];
       *attrib++ = EGL_NONE;
-      glInterop.eglImage = glInterop.eglCreateImageKHR(glInterop.eglDisplay,
+      glInterop.eglImageY = glInterop.eglCreateImageKHR(glInterop.eglDisplay,
                                           EGL_NO_CONTEXT, EGL_LINUX_DMA_BUF_EXT, (EGLClientBuffer)NULL,
                                           attribs);
-      if (!glInterop.eglImage)
+      if (!glInterop.eglImageY)
+      {
+        EGLint err = eglGetError();
+        CLog::Log(LOGERROR, "failed to import VA buffer NV12 into EGL image");
+        return false;
+      }
+
+      attrib = attribs;
+      *attrib++ = EGL_LINUX_DRM_FOURCC_EXT;
+      *attrib++ = fourcc_code('G', 'R', '1', '6');
+      *attrib++ = EGL_WIDTH;
+      *attrib++ = glInterop.vaImage.width +1 >> 1;
+      *attrib++ = EGL_HEIGHT;
+      *attrib++ = glInterop.vaImage.height + 1 >> 1;
+      *attrib++ = EGL_DMA_BUF_PLANE0_FD_EXT;
+      *attrib++ = (intptr_t)glInterop.vBufInfo.handle;
+      *attrib++ = EGL_DMA_BUF_PLANE0_OFFSET_EXT;
+      *attrib++ = glInterop.vaImage.offsets[1];
+      *attrib++ = EGL_DMA_BUF_PLANE0_PITCH_EXT;
+      *attrib++ = glInterop.vaImage.pitches[1];
+      *attrib++ = EGL_NONE;
+      glInterop.eglImageVU = glInterop.eglCreateImageKHR(glInterop.eglDisplay,
+                                          EGL_NO_CONTEXT, EGL_LINUX_DMA_BUF_EXT, (EGLClientBuffer)NULL,
+                                          attribs);
+      if (!glInterop.eglImageVU)
       {
         EGLint err = eglGetError();
         CLog::Log(LOGERROR, "failed to import VA buffer NV12 into EGL image");
         return false;
       }
+
+      GLint format;
+
+      glGenTextures(1, &textureY);
+      glEnable(glInterop.textureTarget);
+      glBindTexture(glInterop.textureTarget, textureY);
+      glTexParameteri(glInterop.textureTarget, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+      glTexParameteri(glInterop.textureTarget, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+      glTexParameteri(glInterop.textureTarget, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+      glTexParameteri(glInterop.textureTarget, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+      glInterop.glEGLImageTargetTexture2DOES(glInterop.textureTarget, glInterop.eglImageY);
+      glGetIntegerv(GL_IMPLEMENTATION_COLOR_READ_FORMAT, &format);
+
+      glGenTextures(1, &textureVU);
+      glEnable(glInterop.textureTarget);
+      glBindTexture(glInterop.textureTarget, textureVU);
+      glTexParameteri(glInterop.textureTarget, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+      glTexParameteri(glInterop.textureTarget, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+      glTexParameteri(glInterop.textureTarget, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+      glTexParameteri(glInterop.textureTarget, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+      glInterop.glEGLImageTargetTexture2DOES(glInterop.textureTarget, glInterop.eglImageVU);
+      glGetIntegerv(GL_IMPLEMENTATION_COLOR_READ_FORMAT, &format);
+
+      glBindTexture(glInterop.textureTarget, 0);
+      glDisable(glInterop.textureTarget);
+
       break;
     }
-    case VA_FOURCC('R','G','B','A'):
     case VA_FOURCC('B','G','R','A'):
     {
-//      attrib = attribs;
-//      *attrib++ = EGL_LINUX_DRM_FOURCC_EXT;
-//      *attrib++ = DRM_FORMAT_ABGR8888;
-//      *attrib++ = EGL_WIDTH;
-//      *attrib++ = glInterop.vaImage.width;
-//      *attrib++ = EGL_HEIGHT;
-//      *attrib++ = glInterop.vaImage.height;
-//      *attrib++ = EGL_DMA_BUF_PLANE0_FD_EXT;
-//      *attrib++ = (intptr_t)glInterop.vBufInfo.handle;
-//      *attrib++ = EGL_DMA_BUF_PLANE0_OFFSET_EXT;
-//      *attrib++ = glInterop.vaImage.offsets[0];
-//      *attrib++ = EGL_DMA_BUF_PLANE0_PITCH_EXT;
-//      *attrib++ = glInterop.vaImage.pitches[0];
-//      *attrib++ = EGL_NONE;
-//      glInterop.eglImage = glInterop.eglCreateImageKHR(eglDisplay,
-//                                          EGL_NO_CONTEXT, EGL_LINUX_DMA_BUF_EXT, (EGLClientBuffer)NULL,
-//                                          attribs);
-
       attrib = attribs;
       *attrib++ = EGL_DRM_BUFFER_FORMAT_MESA;
       *attrib++ = EGL_DRM_BUFFER_FORMAT_ARGB32_MESA;
@@ -1290,28 +1321,26 @@ bool CVaapiRenderPicture::GLMapSurface()
         CLog::Log(LOGERROR, "failed to import VA buffer NV12 into EGL image");
         return false;
       }
+
+      glGenTextures(1, &texture);
+      glEnable(glInterop.textureTarget);
+      glBindTexture(glInterop.textureTarget, texture);
+      glTexParameteri(glInterop.textureTarget, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+      glTexParameteri(glInterop.textureTarget, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+      glTexParameteri(glInterop.textureTarget, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+      glTexParameteri(glInterop.textureTarget, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+
+      glInterop.glEGLImageTargetTexture2DOES(glInterop.textureTarget, glInterop.eglImage);
+
+      glBindTexture(glInterop.textureTarget, 0);
+      glDisable(glInterop.textureTarget);
+
       break;
     }
     default:
       return false;
   }
 
-  GLint format;
-
-  glGenTextures(1, &texture);
-  glEnable(glInterop.textureTarget);
-  glBindTexture(glInterop.textureTarget, texture);
-  glTexParameteri(glInterop.textureTarget, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
-  glTexParameteri(glInterop.textureTarget, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
-  glTexParameteri(glInterop.textureTarget, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
-  glTexParameteri(glInterop.textureTarget, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
-
-  glInterop.glEGLImageTargetTexture2DOES(glInterop.textureTarget, glInterop.eglImage);
-
-  glGetIntegerv(GL_IMPLEMENTATION_COLOR_READ_FORMAT, &format);
-  glBindTexture(glInterop.textureTarget, 0);
-  glDisable(glInterop.textureTarget);
-
   return true;
 }
 
@@ -1320,6 +1349,9 @@ void CVaapiRenderPicture::GLUnMapSurface()
   if (glInterop.vaImage.image_id == VA_INVALID_ID)
     return;
 
+  glInterop.eglDestroyImageKHR(glInterop.eglDisplay, glInterop.eglImageY);
+  glInterop.eglDestroyImageKHR(glInterop.eglDisplay, glInterop.eglImageVU);
+
   VAStatus status;
   status = vaReleaseBufferHandle(glInterop.vadsp, glInterop.vaImage.buf);
   if (status != VA_STATUS_SUCCESS)
@@ -1335,7 +1367,8 @@ void CVaapiRenderPicture::GLUnMapSurface()
   glInterop.mapped = false;
   glInterop.vaImage.image_id = VA_INVALID_ID;
 
-  glDeleteTextures(1, &texture);
+  glDeleteTextures(1, &textureY);
+  glDeleteTextures(1, &textureVU);
 }
 
 //-----------------------------------------------------------------------------
@@ -1994,7 +2027,7 @@ void COutput::InitCycle()
         m_pp = new CFFmpegPostproc();
       else
       {
-        m_pp = new CVppPostproc();
+        m_pp = new CSkipPostproc();
         m_config.stats->SetVpp(true);
       }
       if (m_pp->PreInit(m_config))
@@ -2239,6 +2272,7 @@ bool COutput::EnsureBufferPool()
     pic->glInterop.eglDisplay = m_eglDisplay;
     pic->glInterop.textureTarget = m_textureTarget;
     pic->glInterop.eglCreateImageKHR = eglCreateImageKHR;
+    pic->glInterop.eglDestroyImageKHR = eglDestroyImageKHR;
     pic->glInterop.glEGLImageTargetTexture2DOES = glEGLImageTargetTexture2DOES;
     pic->glInterop.vaImage.image_id = VA_INVALID_ID;
     pic->glInterop.mapped = false;
@@ -2345,6 +2379,7 @@ bool COutput::GLInit()
     m_textureTarget = GL_TEXTURE_2D;
 
   eglCreateImageKHR = (PFNEGLCREATEIMAGEKHRPROC)eglGetProcAddress("eglCreateImageKHR");
+  eglDestroyImageKHR = (PFNEGLDESTROYIMAGEKHRPROC)eglGetProcAddress("eglDestroyImageKHR");
   glEGLImageTargetTexture2DOES = (PFNGLEGLIMAGETARGETTEXTURE2DOESPROC)eglGetProcAddress("glEGLImageTargetTexture2DOES");
   return true;
 }
@@ -2508,22 +2543,18 @@ bool CVppPostproc::PreInit(CVaapiConfig &config, SDiMethods *methods)
     return false;
   }
 
-//  VASurfaceAttrib attr[10];
-//  unsigned int num;
-//  vaQuerySurfaceAttributes(m_config.dpy, m_configId, attr, &num);
-
   VASurfaceAttrib attribs[1], *attrib;
   attrib = attribs;
   attrib->flags = VA_SURFACE_ATTRIB_SETTABLE;
   attrib->type = VASurfaceAttribPixelFormat;
   attrib->value.type = VAGenericValueTypeInteger;
-  attrib->value.value.i = VA_FOURCC_BGRA;
+  attrib->value.value.i = VA_FOURCC_NV12;
 
   // create surfaces
   VASurfaceID surfaces[32];
   int nb_surfaces = NUM_RENDER_PICS;
   if (!CheckSuccess(vaCreateSurfaces(m_config.dpy,
-                                     VA_RT_FORMAT_RGB32,
+                                     VA_RT_FORMAT_YUV420,
                                      m_config.surfaceWidth,
                                      m_config.surfaceHeight,
                                      surfaces,
@@ -2631,7 +2662,7 @@ bool CVppPostproc::Init(EINTERLACEMETHOD method)
     vppMethod = VAProcDeinterlacingMotionCompensated;
     break;
   case VS_INTERLACEMETHOD_NONE:
-    vppMethod = VAProcDeinterlacingNone;
+    // vppMethod = VAProcDeinterlacingNone;
     break;
   default:
     return false;
@@ -2642,8 +2673,8 @@ bool CVppPostproc::Init(EINTERLACEMETHOD method)
   m_currentIdx = 0;
   m_frameCount = 0;
 
-  if (method == VS_INTERLACEMETHOD_NONE)
-    return true;
+//  if (method == VS_INTERLACEMETHOD_NONE)
+//    return true;
 
   VAProcFilterParameterBufferDeinterlacing filterparams;
   filterparams.type = VAProcFilterDeinterlacing;
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.h
index a257b11..65427f8 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.h
@@ -165,9 +165,11 @@ struct CVaapiGLSurface
   VAImage vaImage;
   VABufferInfo vBufInfo;
   EGLImageKHR eglImage;
+  EGLImageKHR eglImageY, eglImageVU;
   GLenum textureTarget;
   EGLDisplay eglDisplay;
   PFNEGLCREATEIMAGEKHRPROC eglCreateImageKHR;
+  PFNEGLDESTROYIMAGEKHRPROC eglDestroyImageKHR;
   PFNGLEGLIMAGETARGETTEXTURE2DOESPROC glEGLImageTargetTexture2DOES;
   bool mapped;
 };
@@ -314,6 +316,7 @@ protected:
   bool GLInit();
   bool CheckSuccess(VAStatus status);
   PFNEGLCREATEIMAGEKHRPROC eglCreateImageKHR;
+  PFNEGLDESTROYIMAGEKHRPROC eglDestroyImageKHR;
   PFNGLEGLIMAGETARGETTEXTURE2DOESPROC glEGLImageTargetTexture2DOES;
   CEvent m_outMsgEvent;
   CEvent *m_inMsgEvent;
-- 
1.9.1


From 29e34751b8df5a49887df509eec084446b45b488 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Sat, 27 Jun 2015 19:36:05 +0200
Subject: [PATCH 05/21] vaapi: fix cropping

---
 xbmc/cores/VideoRenderers/HwDecRender/RendererVAAPI.cpp | 11 ++---------
 xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp          |  5 +++--
 xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.h            |  2 +-
 3 files changed, 6 insertions(+), 12 deletions(-)

diff --git a/xbmc/cores/VideoRenderers/HwDecRender/RendererVAAPI.cpp b/xbmc/cores/VideoRenderers/HwDecRender/RendererVAAPI.cpp
index 4c30f24..d0b4250 100644
--- a/xbmc/cores/VideoRenderers/HwDecRender/RendererVAAPI.cpp
+++ b/xbmc/cores/VideoRenderers/HwDecRender/RendererVAAPI.cpp
@@ -126,9 +126,6 @@ bool CRendererVAAPI::CreateTexture(int index)
   im.cshift_x = 1;
   im.cshift_y = 1;
 
-  plane.texwidth  = im.width;
-  plane.texheight = im.height;
-
   plane.pixpertex_x = 1;
   plane.pixpertex_y = 1;
 
@@ -173,14 +170,10 @@ bool CRendererVAAPI::UploadTexture(int index)
     return false;
   }
 
-  im.height = vaapi->texHeight;
-  im.width  = vaapi->texWidth;
-
-
   YUVPLANES &planes = fields[0];
 
-  planes[0].texwidth  = im.width;
-  planes[0].texheight = im.height;
+  planes[0].texwidth  = vaapi->texWidth;
+  planes[0].texheight = vaapi->texHeight;
 
   planes[1].texwidth  = planes[0].texwidth  >> im.cshift_x;
   planes[1].texheight = planes[0].texheight >> im.cshift_y;
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp
index 835229b..d521f8a 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp
@@ -1217,6 +1217,9 @@ bool CVaapiRenderPicture::GLMapSurface()
     return false;
   }
 
+  texWidth = glInterop.vaImage.width;
+  texHeight = glInterop.vaImage.height;
+
   EGLImageKHR image;
   GLint attribs[23], *attrib;
 
@@ -2084,8 +2087,6 @@ CVaapiRenderPicture* COutput::ProcessPicture(CVaapiProcessedPicture &pic)
   retPic->DVDPic.iHeight = m_config.vidHeight;
 
   retPic->valid = true;
-  retPic->texWidth = m_config.outWidth;
-  retPic->texHeight = m_config.outHeight;
   retPic->crop.x1 = 0;
   retPic->crop.y1 = 0;
   retPic->crop.x2 = m_config.outWidth;
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.h
index 65427f8..c122717 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.h
@@ -186,7 +186,7 @@ class CVaapiRenderPicture
   friend class COutput;
 public:
   CVaapiRenderPicture(CCriticalSection &section)
-    : texWidth(0), texHeight(0), texture(None), valid(false), vaapi(NULL), avFrame(NULL),
+    : texWidth(0), texHeight(0), texture(None), textureY(None), textureVU(None), valid(false), vaapi(NULL), avFrame(NULL),
       usefence(false), refCount(0), renderPicSection(section) { fence = None; }
   void Sync();
   DVDVideoPicture DVDPic;
-- 
1.9.1


From 1f8ed88567d76a7c3aaee244db1a9ef8453ca55f Mon Sep 17 00:00:00 2001
From: fritsch <Peter.Fruehberger@gmail.com>
Date: Sun, 5 Jul 2015 09:05:27 +0200
Subject: [PATCH 06/21] VAAPI: Fix compiler warnings (squash me)

---
 xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp | 14 +++++---------
 1 file changed, 5 insertions(+), 9 deletions(-)

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp
index d521f8a..bde6ad3 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp
@@ -1220,7 +1220,6 @@ bool CVaapiRenderPicture::GLMapSurface()
   texWidth = glInterop.vaImage.width;
   texHeight = glInterop.vaImage.height;
 
-  EGLImageKHR image;
   GLint attribs[23], *attrib;
 
   switch (glInterop.vaImage.format.fourcc)
@@ -1247,7 +1246,7 @@ bool CVaapiRenderPicture::GLMapSurface()
       if (!glInterop.eglImageY)
       {
         EGLint err = eglGetError();
-        CLog::Log(LOGERROR, "failed to import VA buffer NV12 into EGL image");
+        CLog::Log(LOGERROR, "failed to import VA buffer NV12 into EGL image: %d", err);
         return false;
       }
 
@@ -1255,9 +1254,9 @@ bool CVaapiRenderPicture::GLMapSurface()
       *attrib++ = EGL_LINUX_DRM_FOURCC_EXT;
       *attrib++ = fourcc_code('G', 'R', '1', '6');
       *attrib++ = EGL_WIDTH;
-      *attrib++ = glInterop.vaImage.width +1 >> 1;
+      *attrib++ = (glInterop.vaImage.width + 1) >> 1;
       *attrib++ = EGL_HEIGHT;
-      *attrib++ = glInterop.vaImage.height + 1 >> 1;
+      *attrib++ = (glInterop.vaImage.height + 1) >> 1;
       *attrib++ = EGL_DMA_BUF_PLANE0_FD_EXT;
       *attrib++ = (intptr_t)glInterop.vBufInfo.handle;
       *attrib++ = EGL_DMA_BUF_PLANE0_OFFSET_EXT;
@@ -1271,7 +1270,7 @@ bool CVaapiRenderPicture::GLMapSurface()
       if (!glInterop.eglImageVU)
       {
         EGLint err = eglGetError();
-        CLog::Log(LOGERROR, "failed to import VA buffer NV12 into EGL image");
+        CLog::Log(LOGERROR, "failed to import VA buffer NV12 into EGL image: %d", err);
         return false;
       }
 
@@ -1321,7 +1320,7 @@ bool CVaapiRenderPicture::GLMapSurface()
       if (!glInterop.eglImage)
       {
         EGLint err = eglGetError();
-        CLog::Log(LOGERROR, "failed to import VA buffer NV12 into EGL image");
+        CLog::Log(LOGERROR, "failed to import VA buffer BGRA into EGL image: %d", err);
         return false;
       }
 
@@ -2260,9 +2259,6 @@ void COutput::ProcessReturnProcPicture(int id)
 
 bool COutput::EnsureBufferPool()
 {
-  int fbConfigIndex = 0;
-  int num;
-
   // create avFrames and init interop
   CVaapiRenderPicture *pic;
   for (unsigned int i = 0; i < m_bufferPool.allRenderPics.size(); i++)
-- 
1.9.1


From f7d09b0af4026104509c01b55666a70a6909a2a2 Mon Sep 17 00:00:00 2001
From: Lauri Myllari <lauri.myllari@gmail.com>
Date: Mon, 22 Jun 2015 22:29:34 -0700
Subject: [PATCH 07/21] gl: fix build

---
 xbmc/system_gl.h | 1 +
 1 file changed, 1 insertion(+)

diff --git a/xbmc/system_gl.h b/xbmc/system_gl.h
index deb88db..f80b70d 100644
--- a/xbmc/system_gl.h
+++ b/xbmc/system_gl.h
@@ -32,6 +32,7 @@
     #include <GL/glu.h>
   #elif defined(TARGET_LINUX)
     #include <GL/gl.h>
+    #include <GL/glu.h>
     #include <GL/glext.h>
   #elif defined(TARGET_FREEBSD)
     #include <GL/gl.h>
-- 
1.9.1


From bc6a80e90224f1a9411239659f4673e38d894b30 Mon Sep 17 00:00:00 2001
From: Lauri Myllari <lauri.myllari@gmail.com>
Date: Mon, 4 May 2015 22:30:47 -0700
Subject: [PATCH 08/21] gl: split output stage from yuv2rgb shader

In preparation for new features, create a separate output stage that can
be attached either to yuv2rgb or convolution filter shader. This stage
will include things like color management, RGB range conversion and
dithering.
---
 system/shaders/output.glsl                             |  6 ++++++
 system/shaders/yuv2rgb_basic.glsl                      | 18 +++++++++---------
 xbmc/cores/VideoRenderers/LinuxRendererGL.cpp          |  4 +++-
 .../VideoRenderers/VideoShaders/YUV2RGBShader.cpp      | 14 +++++++++++---
 xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.h |  4 ++--
 xbmc/guilib/Shader.cpp                                 | 18 ++++++++++++++++++
 xbmc/guilib/Shader.h                                   |  1 +
 7 files changed, 50 insertions(+), 15 deletions(-)
 create mode 100644 system/shaders/output.glsl

diff --git a/system/shaders/output.glsl b/system/shaders/output.glsl
new file mode 100644
index 0000000..53c8993
--- /dev/null
+++ b/system/shaders/output.glsl
@@ -0,0 +1,6 @@
+void main()
+{
+  vec4 rgb = process();
+
+  gl_FragColor = rgb;
+}
diff --git a/system/shaders/yuv2rgb_basic.glsl b/system/shaders/yuv2rgb_basic.glsl
index 13fe0ec..59cac3e 100644
--- a/system/shaders/yuv2rgb_basic.glsl
+++ b/system/shaders/yuv2rgb_basic.glsl
@@ -55,11 +55,12 @@ vec2 stretch(vec2 pos)
 #endif
 }
 
-void main()
+vec4 process()
 {
+  vec4 rgb;
 #if defined(XBMC_YV12) || defined(XBMC_NV12)
 
-  vec4 yuv, rgb;
+  vec4 yuv;
   yuv.rgba = vec4( texture2D(m_sampY, stretch(m_cordY)).r
                  , texture2D(m_sampU, stretch(m_cordU)).g
                  , texture2D(m_sampV, stretch(m_cordV)).a
@@ -67,11 +68,10 @@ void main()
 
   rgb   = m_yuvmat * yuv;
   rgb.a = gl_Color.a;
-  gl_FragColor = rgb;
 
 #elif defined(XBMC_NV12_RRG)
 
-  vec4 yuv, rgb;
+  vec4 yuv;
   yuv.rgba = vec4( texture2D(m_sampY, stretch(m_cordY)).r
                  , texture2D(m_sampU, stretch(m_cordU)).r
                  , texture2D(m_sampV, stretch(m_cordV)).g
@@ -79,7 +79,6 @@ void main()
 
   rgb   = m_yuvmat * yuv;
   rgb.a = gl_Color.a;
-  gl_FragColor = rgb;
 
 #elif defined(XBMC_YUY2) || defined(XBMC_UYVY)
 
@@ -116,10 +115,11 @@ void main()
   float outY    = mix(leftY, rightY, step(0.5, f.x));
 
   vec4  yuv     = vec4(outY, outUV, 1.0);
-  vec4  rgb     = m_yuvmat * yuv;
-
-  gl_FragColor   = rgb;
-  gl_FragColor.a = gl_Color.a;
+  rgb           = m_yuvmat * yuv;
 
+  rgb.a = gl_Color.a;
 #endif
+
+  return rgb;
 }
+
diff --git a/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp b/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
index 31f3a13..bfab837 100644
--- a/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
+++ b/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
@@ -825,6 +825,7 @@ void CLinuxRendererGL::UpdateVideoFilter()
         break;
       }
 
+      // TODO: switch to GL_RGBA16 or GL_RGBA16F
       if (!m_fbo.fbo.CreateAndBindToTexture(GL_TEXTURE_2D, m_sourceWidth, m_sourceHeight, GL_RGBA))
       {
         CLog::Log(LOGERROR, "GL: Error creating texture and binding to FBO");
@@ -898,7 +899,8 @@ void CLinuxRendererGL::LoadShaders(int field)
       {
         // create regular progressive scan shader
         m_pYUVShader = new YUV2RGBProgressiveShader(m_textureTarget==GL_TEXTURE_RECTANGLE_ARB, m_iFlags, m_format,
-                                                    m_nonLinStretch && m_renderQuality == RQ_SINGLEPASS);
+                                                    m_nonLinStretch && m_renderQuality == RQ_SINGLEPASS,
+                                                    m_renderQuality == RQ_SINGLEPASS);
 
         CLog::Log(LOGNOTICE, "GL: Selecting Single Pass YUV 2 RGB shader");
 
diff --git a/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.cpp b/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.cpp
index 46a192c..17e622c 100644
--- a/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.cpp
+++ b/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.cpp
@@ -167,7 +167,8 @@ static void CalculateYUVMatrixGL(GLfloat      res[4][4]
 // BaseYUV2RGBGLSLShader - base class for GLSL YUV2RGB shaders
 //////////////////////////////////////////////////////////////////////
 
-BaseYUV2RGBGLSLShader::BaseYUV2RGBGLSLShader(bool rect, unsigned flags, ERenderFormat format, bool stretch)
+BaseYUV2RGBGLSLShader::BaseYUV2RGBGLSLShader(bool rect, unsigned flags, ERenderFormat format, bool stretch,
+                                             bool output)
 {
   m_width      = 1;
   m_height     = 1;
@@ -204,6 +205,11 @@ BaseYUV2RGBGLSLShader::BaseYUV2RGBGLSLShader(bool rect, unsigned flags, ERenderF
   else
     m_defines += "#define XBMC_STRETCH 0\n";
 
+  if (output)
+    m_defines += "#define XBMC_OUTPUT 1\n";
+  else
+    m_defines += "#define XBMC_OUTPUT 0\n";
+
   if (m_format == RENDER_FMT_YUV420P ||
       m_format == RENDER_FMT_YUV420P10 ||
       m_format == RENDER_FMT_YUV420P16)
@@ -310,11 +316,13 @@ BaseYUV2RGBARBShader::BaseYUV2RGBARBShader(unsigned flags, ERenderFormat format)
 // Use for weave deinterlacing / progressive
 //////////////////////////////////////////////////////////////////////
 
-YUV2RGBProgressiveShader::YUV2RGBProgressiveShader(bool rect, unsigned flags, ERenderFormat format, bool stretch)
-  : BaseYUV2RGBGLSLShader(rect, flags, format, stretch)
+YUV2RGBProgressiveShader::YUV2RGBProgressiveShader(bool rect, unsigned flags, ERenderFormat format, bool stretch,
+                                                   bool output)
+  : BaseYUV2RGBGLSLShader(rect, flags, format, stretch, output)
 {
 #ifdef HAS_GL
   PixelShader()->LoadSource("yuv2rgb_basic.glsl", m_defines);
+  PixelShader()->AppendSource("output.glsl");
 #elif HAS_GLES == 2
   PixelShader()->LoadSource("yuv2rgb_basic_gles.glsl", m_defines);
 #endif
diff --git a/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.h b/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.h
index cccac6f..efa8d87 100644
--- a/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.h
+++ b/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.h
@@ -70,7 +70,7 @@ namespace Shaders {
     , public CGLSLShaderProgram
   {
   public:
-    BaseYUV2RGBGLSLShader(bool rect, unsigned flags, ERenderFormat format, bool stretch);
+    BaseYUV2RGBGLSLShader(bool rect, unsigned flags, ERenderFormat format, bool stretch, bool output=true);
    ~BaseYUV2RGBGLSLShader() {}
     virtual void SetField(int field) { m_field  = field; }
     virtual void SetWidth(int w)     { m_width  = w; }
@@ -170,7 +170,7 @@ namespace Shaders {
   class YUV2RGBProgressiveShader : public BaseYUV2RGBGLSLShader
   {
   public:
-    YUV2RGBProgressiveShader(bool rect=false, unsigned flags=0, ERenderFormat format=RENDER_FMT_NONE, bool stretch = false);
+    YUV2RGBProgressiveShader(bool rect=false, unsigned flags=0, ERenderFormat format=RENDER_FMT_NONE, bool stretch = false, bool output=true);
   };
 
   class YUV2RGBBobShader : public BaseYUV2RGBGLSLShader
diff --git a/xbmc/guilib/Shader.cpp b/xbmc/guilib/Shader.cpp
index 3705405..9415d6d 100644
--- a/xbmc/guilib/Shader.cpp
+++ b/xbmc/guilib/Shader.cpp
@@ -57,6 +57,24 @@ bool CShader::LoadSource(const string& filename, const string& prefix)
   return true;
 }
 
+bool CShader::AppendSource(const string& filename)
+{
+  if(filename.empty())
+    return true;
+
+  CFileStream file;
+  string temp;
+
+  if(!file.Open("special://xbmc/system/shaders/" + filename))
+  {
+    CLog::Log(LOGERROR, "CShader::AppendSource - failed to open file %s", filename.c_str());
+    return false;
+  }
+  getline(file, temp, '\0');
+  m_source.append(temp);
+  return true;
+}
+
 //////////////////////////////////////////////////////////////////////
 // CGLSLVertexShader
 //////////////////////////////////////////////////////////////////////
diff --git a/xbmc/guilib/Shader.h b/xbmc/guilib/Shader.h
index 3283164..c977fba 100644
--- a/xbmc/guilib/Shader.h
+++ b/xbmc/guilib/Shader.h
@@ -46,6 +46,7 @@ namespace Shaders {
     virtual GLuint Handle() = 0;
     virtual void SetSource(const string& src) { m_source = src; }
     virtual bool LoadSource(const string& filename, const string& prefix = "");
+    virtual bool AppendSource(const string& filename);
     bool OK() const { return m_compiled; }
 
   protected:
-- 
1.9.1


From 2e8b097a709af2333a1d918bdbcb947ee3264256 Mon Sep 17 00:00:00 2001
From: Lauri Myllari <lauri.myllari@gmail.com>
Date: Mon, 4 May 2015 22:46:56 -0700
Subject: [PATCH 09/21] gl: split output stage from convolution shaders

---
 system/shaders/convolution-4x4.glsl                          | 8 +++++---
 system/shaders/convolution-6x6.glsl                          | 8 +++++---
 xbmc/cores/VideoRenderers/VideoShaders/VideoFilterShader.cpp | 8 +++++++-
 xbmc/cores/VideoRenderers/VideoShaders/VideoFilterShader.h   | 2 +-
 4 files changed, 18 insertions(+), 8 deletions(-)

diff --git a/system/shaders/convolution-4x4.glsl b/system/shaders/convolution-4x4.glsl
index 8c035ba..d41b127 100644
--- a/system/shaders/convolution-4x4.glsl
+++ b/system/shaders/convolution-4x4.glsl
@@ -81,8 +81,9 @@ half3 line (float ypos, vec4 xpos, half4 linetaps)
     pixel(xpos.a, ypos) * linetaps.a;
 }
 
-void main()
+vec4 process()
 {
+  vec4 rgb;
   vec2 pos = stretch(cord) + stepxy * 0.5;
   vec2 f = fract(pos / stepxy);
 
@@ -96,12 +97,13 @@ void main()
   vec2 xystart = (-1.5 - f) * stepxy + pos;
   vec4 xpos = vec4(xystart.x, xystart.x + stepxy.x, xystart.x + stepxy.x * 2.0, xystart.x + stepxy.x * 3.0);
 
-  gl_FragColor.rgb =
+  rgb.rgb =
     line(xystart.y                 , xpos, linetaps) * columntaps.r +
     line(xystart.y + stepxy.y      , xpos, linetaps) * columntaps.g +
     line(xystart.y + stepxy.y * 2.0, xpos, linetaps) * columntaps.b +
     line(xystart.y + stepxy.y * 3.0, xpos, linetaps) * columntaps.a;
 
-  gl_FragColor.a = gl_Color.a;
+  rgb.a = gl_Color.a;
+  return rgb;
 }
 
diff --git a/system/shaders/convolution-6x6.glsl b/system/shaders/convolution-6x6.glsl
index 5da4822..68c5366 100644
--- a/system/shaders/convolution-6x6.glsl
+++ b/system/shaders/convolution-6x6.glsl
@@ -83,8 +83,9 @@ half3 line (float ypos, vec3 xpos1, vec3 xpos2, half3 linetaps1, half3 linetaps2
     pixel(xpos2.b, ypos) * linetaps2.b; 
 }
 
-void main()
+vec4 process()
 {
+  vec4 rgb;
   vec2 pos = stretch(cord) + stepxy * 0.5;
   vec2 f = fract(pos / stepxy);
 
@@ -105,7 +106,7 @@ void main()
   vec3 xpos1 = vec3(xystart.x, xystart.x + stepxy.x, xystart.x + stepxy.x * 2.0);
   vec3 xpos2 = vec3(xystart.x + stepxy.x * 3.0, xystart.x + stepxy.x * 4.0, xystart.x + stepxy.x * 5.0);
 
-  gl_FragColor.rgb =
+  rgb =
    line(xystart.y                 , xpos1, xpos2, linetaps1, linetaps2) * columntaps1.r +
    line(xystart.y + stepxy.y      , xpos1, xpos2, linetaps1, linetaps2) * columntaps2.r +
    line(xystart.y + stepxy.y * 2.0, xpos1, xpos2, linetaps1, linetaps2) * columntaps1.g +
@@ -113,6 +114,7 @@ void main()
    line(xystart.y + stepxy.y * 4.0, xpos1, xpos2, linetaps1, linetaps2) * columntaps1.b +
    line(xystart.y + stepxy.y * 5.0, xpos1, xpos2, linetaps1, linetaps2) * columntaps2.b;
 
-  gl_FragColor.a = gl_Color.a;
+  rgb.a = gl_Color.a;
+  return rgb;
 }
 
diff --git a/xbmc/cores/VideoRenderers/VideoShaders/VideoFilterShader.cpp b/xbmc/cores/VideoRenderers/VideoShaders/VideoFilterShader.cpp
index deb5173..6bcc6bf 100644
--- a/xbmc/cores/VideoRenderers/VideoShaders/VideoFilterShader.cpp
+++ b/xbmc/cores/VideoRenderers/VideoShaders/VideoFilterShader.cpp
@@ -78,7 +78,7 @@ BaseVideoFilterShader::BaseVideoFilterShader()
   PixelShader()->SetSource(shaderp);
 }
 
-ConvolutionFilterShader::ConvolutionFilterShader(ESCALINGMETHOD method, bool stretch)
+ConvolutionFilterShader::ConvolutionFilterShader(ESCALINGMETHOD method, bool stretch, bool output)
 {
   m_method = method;
   m_kernelTex1 = 0;
@@ -128,6 +128,11 @@ ConvolutionFilterShader::ConvolutionFilterShader(ESCALINGMETHOD method, bool str
   else
     defines += "#define XBMC_STRETCH 0\n";
 
+  if (output)
+    defines += "#define XBMC_OUTPUT 1\n";
+  else
+    defines += "#define XBMC_OUTPUT 0\n";
+
   //tell shader if we're using a 1D texture
 #ifdef USE1DTEXTURE
   defines += "#define USE1DTEXTURE 1\n";
@@ -137,6 +142,7 @@ ConvolutionFilterShader::ConvolutionFilterShader(ESCALINGMETHOD method, bool str
 
   CLog::Log(LOGDEBUG, "GL: ConvolutionFilterShader: using %s defines:\n%s", shadername.c_str(), defines.c_str());
   PixelShader()->LoadSource(shadername, defines);
+  PixelShader()->AppendSource("output.glsl");
 }
 
 void ConvolutionFilterShader::OnCompiledAndLinked()
diff --git a/xbmc/cores/VideoRenderers/VideoShaders/VideoFilterShader.h b/xbmc/cores/VideoRenderers/VideoShaders/VideoFilterShader.h
index a489865..25717c1 100644
--- a/xbmc/cores/VideoRenderers/VideoShaders/VideoFilterShader.h
+++ b/xbmc/cores/VideoRenderers/VideoShaders/VideoFilterShader.h
@@ -60,7 +60,7 @@ namespace Shaders {
   class ConvolutionFilterShader : public BaseVideoFilterShader
   {
   public:
-    ConvolutionFilterShader(ESCALINGMETHOD method, bool stretch);
+    ConvolutionFilterShader(ESCALINGMETHOD method, bool stretch, bool output=true);
     void OnCompiledAndLinked();
     bool OnEnabled();
     void Free();
-- 
1.9.1


From 1e74eb5229da3606b40a9c2c2494cbf67c12e3e6 Mon Sep 17 00:00:00 2001
From: Lauri Myllari <lauri.myllari@gmail.com>
Date: Sun, 10 May 2015 21:29:28 -0700
Subject: [PATCH 10/21] gl: GLSLOutput helper with dithering

Implement a GLSLOutput class that can be passed to shaders to implement
an output stage with RGB range conversion and dithering. Add support for
GLSLOutput in YUV2RGBShader and ConvolutionFilterShader.

Single pass rendering to full range is not optimal as the range
conversion could be done in colorspace conversion matrix. Keeping video
levels avoids banding in multipass rendering though.
---
 system/shaders/output.glsl                         |  22 +++-
 xbmc/cores/VideoRenderers/LinuxRendererGL.cpp      |   8 +-
 .../VideoRenderers/VideoShaders/GLSLOutput.cpp     | 145 +++++++++++++++++++++
 .../cores/VideoRenderers/VideoShaders/GLSLOutput.h |  63 +++++++++
 xbmc/cores/VideoRenderers/VideoShaders/Makefile    |   2 +-
 .../VideoShaders/VideoFilterShader.cpp             |  25 +++-
 .../VideoShaders/VideoFilterShader.h               |   7 +-
 .../VideoRenderers/VideoShaders/YUV2RGBShader.cpp  |  46 +++++--
 .../VideoRenderers/VideoShaders/YUV2RGBShader.h    |  16 ++-
 xbmc/cores/VideoRenderers/VideoShaders/dither.h    |  72 ++++++++++
 10 files changed, 378 insertions(+), 28 deletions(-)
 create mode 100644 xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.cpp
 create mode 100644 xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.h
 create mode 100644 xbmc/cores/VideoRenderers/VideoShaders/dither.h

diff --git a/system/shaders/output.glsl b/system/shaders/output.glsl
index 53c8993..83f77b0 100644
--- a/system/shaders/output.glsl
+++ b/system/shaders/output.glsl
@@ -1,6 +1,24 @@
+#if (XBMC_DITHER)
+uniform sampler2D m_dither;
+uniform float     m_ditherquant;
+uniform vec2      m_dithersize;
+#endif
+
 void main()
 {
-  vec4 rgb = process();
+  vec4 rgb        = process();
+
+#if (XBMC_FULLRANGE)
+  rgb             = clamp((rgb-(16.0/255.0)) * 255.0/219.0, 0, 1);
+#endif
+
+#if (XBMC_DITHER)
+  vec2 ditherpos  = gl_FragCoord.xy / m_dithersize;
+  // ditherval is multiplied by 65536/(dither_size^2) to make it [0,1[
+  // FIXME: scale dither values before uploading?
+  float ditherval = texture2D(m_dither, ditherpos).r * 16.0;
+  rgb             = floor(rgb * m_ditherquant + ditherval) / m_ditherquant;
+#endif
 
-  gl_FragColor = rgb;
+  gl_FragColor    = rgb;
 }
diff --git a/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp b/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
index bfab837..2511b29 100644
--- a/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
+++ b/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
@@ -748,6 +748,8 @@ void CLinuxRendererGL::UpdateVideoFilter()
 
   if (m_scalingMethodGui == CMediaSettings::Get().GetCurrentVideoSettings().m_ScalingMethod && !nonLinStretchChanged)
     return;
+  else
+    m_reloadShaders = 1;
 
   //recompile YUV shader when non-linear stretch is turned on/off
   //or when it's on and the scaling method changed
@@ -825,7 +827,6 @@ void CLinuxRendererGL::UpdateVideoFilter()
         break;
       }
 
-      // TODO: switch to GL_RGBA16 or GL_RGBA16F
       if (!m_fbo.fbo.CreateAndBindToTexture(GL_TEXTURE_2D, m_sourceWidth, m_sourceHeight, GL_RGBA))
       {
         CLog::Log(LOGERROR, "GL: Error creating texture and binding to FBO");
@@ -833,7 +834,7 @@ void CLinuxRendererGL::UpdateVideoFilter()
       }
     }
 
-    m_pVideoFilterShader = new ConvolutionFilterShader(m_scalingMethod, m_nonLinStretch);
+    m_pVideoFilterShader = new ConvolutionFilterShader(m_scalingMethod, m_nonLinStretch, new GLSLOutput(3));
     if (!m_pVideoFilterShader->CompileAndLink())
     {
       CLog::Log(LOGERROR, "GL: Error compiling and linking video filter shader");
@@ -898,9 +899,10 @@ void CLinuxRendererGL::LoadShaders(int field)
       if (glCreateProgram && tryGlsl)
       {
         // create regular progressive scan shader
+        // if single pass, create GLSLOutput helper and pass it to YUV2RGB shader
         m_pYUVShader = new YUV2RGBProgressiveShader(m_textureTarget==GL_TEXTURE_RECTANGLE_ARB, m_iFlags, m_format,
                                                     m_nonLinStretch && m_renderQuality == RQ_SINGLEPASS,
-                                                    m_renderQuality == RQ_SINGLEPASS);
+                                                    (m_renderQuality == RQ_SINGLEPASS) ? new GLSLOutput(3) : NULL);
 
         CLog::Log(LOGNOTICE, "GL: Selecting Single Pass YUV 2 RGB shader");
 
diff --git a/xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.cpp b/xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.cpp
new file mode 100644
index 0000000..5f9b075
--- /dev/null
+++ b/xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.cpp
@@ -0,0 +1,145 @@
+/*
+ *      Copyright (c) 2007 d4rk
+ *      Copyright (C) 2007-2013 Team XBMC
+ *      Copyright (C) 2015 Lauri Myllri
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "windowing/WindowingFactory.h"
+#include "utils/log.h"
+
+#include "GLSLOutput.h"
+#include "dither.h"
+
+using namespace Shaders;
+
+GLSLOutput::GLSLOutput(int texunit)
+{
+  // set member variable initial values
+  m_1stTexUnit = texunit;
+  m_uDither = m_1stTexUnit+0;
+
+  //   textures
+  m_tDitherTex  = 0;
+
+  //   shader attribute handles
+  m_hDither      = -1;
+  m_hDitherQuant = -1;
+  m_hDitherSize  = -1;
+
+  m_dither = true; // hardcode dithering for now
+  m_fullRange = !g_Windowing.UseLimitedColor();
+}
+
+std::string GLSLOutput::GetDefines()
+{
+  std::string defines = "#define XBMC_OUTPUT 1\n";
+  if (m_dither) defines += "#define XBMC_DITHER 1\n";
+  if (m_fullRange) defines += "#define XBMC_FULLRANGE 1\n";
+  return defines;
+}
+
+void GLSLOutput::OnCompiledAndLinked(GLuint programHandle)
+{
+  FreeTextures();
+
+  // get uniform locations
+  //   dithering
+  if (m_dither) {
+    m_hDither      = glGetUniformLocation(programHandle, "m_dither");
+    m_hDitherQuant = glGetUniformLocation(programHandle, "m_ditherquant");
+    m_hDitherSize  = glGetUniformLocation(programHandle, "m_dithersize");
+  }
+
+  if (m_dither) {
+    // TODO: create a dither pattern
+
+    // create a dither texture
+    glGenTextures(1, &m_tDitherTex);
+    if ( m_tDitherTex <= 0 )
+    {
+      CLog::Log(LOGERROR, "Error creating dither texture");
+      return;
+    }
+    // bind and set texture parameters
+    glActiveTexture(GL_TEXTURE0 + m_uDither);
+    glBindTexture(GL_TEXTURE_2D, m_tDitherTex);
+    glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
+    glPixelStorei(GL_UNPACK_ROW_LENGTH, 0);
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
+
+    // load dither texture data
+    glTexImage2D(GL_TEXTURE_2D, 0, GL_R16, dither_size, dither_size, 0, GL_RED, GL_UNSIGNED_SHORT, dither_matrix);
+  }
+
+  glActiveTexture(GL_TEXTURE0);
+
+  VerifyGLState();
+}
+
+bool GLSLOutput::OnEnabled()
+{
+
+  if (m_dither) {
+    // set texture units
+    glUniform1i(m_hDither, m_uDither);
+    VerifyGLState();
+
+    // bind textures
+    glActiveTexture(GL_TEXTURE0 + m_uDither);
+    glBindTexture(GL_TEXTURE_2D, m_tDitherTex);
+    glActiveTexture(GL_TEXTURE0);
+    VerifyGLState();
+
+    // dither settings
+    glUniform1f(m_hDitherQuant, 255.0); // (1<<depth)-1
+    VerifyGLState();
+    glUniform2f(m_hDitherSize, dither_size, dither_size);
+    VerifyGLState();
+  }
+
+  VerifyGLState();
+  return true;
+}
+
+void GLSLOutput::OnDisabled()
+{
+  // disable textures
+  glActiveTexture(GL_TEXTURE0 + m_uDither);
+  glDisable(GL_TEXTURE_2D);
+  glActiveTexture(GL_TEXTURE0);
+  VerifyGLState();
+}
+
+void GLSLOutput::Free()
+{
+  FreeTextures();
+}
+
+void GLSLOutput::FreeTextures()
+{
+  if (m_tDitherTex)
+  {
+    glDeleteTextures(1, &m_tDitherTex);
+    m_tDitherTex = 0;
+  }
+}
+
diff --git a/xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.h b/xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.h
new file mode 100644
index 0000000..a4dba4f
--- /dev/null
+++ b/xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.h
@@ -0,0 +1,63 @@
+#ifndef __GLSLOUTPUT_H__
+#define __GLSLOUTPUT_H__
+
+/*
+ *      Copyright (C) 2007-2013 Team XBMC
+ *      Copyright (C) 2015 Lauri Myllri
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "system.h"
+#include "utils/GLUtils.h"
+
+namespace Shaders {
+
+  class GLSLOutput
+  {
+  public:
+    // take the 1st available texture unit as a parameter
+    GLSLOutput(int texunit);
+    std::string GetDefines();
+    void OnCompiledAndLinked(GLuint programHandle);
+    bool OnEnabled();
+    void OnDisabled();
+    void Free();
+
+  private:
+    void FreeTextures();
+
+    bool m_dither;
+    bool m_fullRange;
+    // first texture unit available to us
+    int m_1stTexUnit;
+    int m_uDither;
+
+    // defines
+
+    // attribute locations
+    GLint m_hDither;
+    GLint m_hDitherQuant;
+    GLint m_hDitherSize;
+
+    // textures
+    GLuint m_tDitherTex;
+
+
+  };
+}
+#endif // __GLSLOUTPUT_H__
diff --git a/xbmc/cores/VideoRenderers/VideoShaders/Makefile b/xbmc/cores/VideoRenderers/VideoShaders/Makefile
index 402963f..6897a40 100644
--- a/xbmc/cores/VideoRenderers/VideoShaders/Makefile
+++ b/xbmc/cores/VideoRenderers/VideoShaders/Makefile
@@ -1,4 +1,4 @@
-SRCS=YUV2RGBShader.cpp VideoFilterShader.cpp ConvolutionKernels.cpp
+SRCS=YUV2RGBShader.cpp VideoFilterShader.cpp ConvolutionKernels.cpp GLSLOutput.cpp
 
 LIB=VideoShaders.a
 
diff --git a/xbmc/cores/VideoRenderers/VideoShaders/VideoFilterShader.cpp b/xbmc/cores/VideoRenderers/VideoShaders/VideoFilterShader.cpp
index 6bcc6bf..d376aea 100644
--- a/xbmc/cores/VideoRenderers/VideoShaders/VideoFilterShader.cpp
+++ b/xbmc/cores/VideoRenderers/VideoShaders/VideoFilterShader.cpp
@@ -78,7 +78,7 @@ BaseVideoFilterShader::BaseVideoFilterShader()
   PixelShader()->SetSource(shaderp);
 }
 
-ConvolutionFilterShader::ConvolutionFilterShader(ESCALINGMETHOD method, bool stretch, bool output)
+ConvolutionFilterShader::ConvolutionFilterShader(ESCALINGMETHOD method, bool stretch, GLSLOutput *output)
 {
   m_method = method;
   m_kernelTex1 = 0;
@@ -128,10 +128,11 @@ ConvolutionFilterShader::ConvolutionFilterShader(ESCALINGMETHOD method, bool str
   else
     defines += "#define XBMC_STRETCH 0\n";
 
-  if (output)
-    defines += "#define XBMC_OUTPUT 1\n";
-  else
-    defines += "#define XBMC_OUTPUT 0\n";
+  // get defines from the output stage if used
+  m_glslOutput = output;
+  if (m_glslOutput) {
+    defines += m_glslOutput->GetDefines();
+  }
 
   //tell shader if we're using a 1D texture
 #ifdef USE1DTEXTURE
@@ -145,6 +146,11 @@ ConvolutionFilterShader::ConvolutionFilterShader(ESCALINGMETHOD method, bool str
   PixelShader()->AppendSource("output.glsl");
 }
 
+ConvolutionFilterShader::~ConvolutionFilterShader()
+{
+  delete m_glslOutput;
+}
+
 void ConvolutionFilterShader::OnCompiledAndLinked()
 {
   // obtain shader attribute handles on successfull compilation
@@ -203,6 +209,8 @@ void ConvolutionFilterShader::OnCompiledAndLinked()
   glActiveTexture(GL_TEXTURE0);
 
   VerifyGLState();
+
+  if (m_glslOutput) m_glslOutput->OnCompiledAndLinked(ProgramHandle());
 }
 
 bool ConvolutionFilterShader::OnEnabled()
@@ -217,14 +225,21 @@ bool ConvolutionFilterShader::OnEnabled()
   glUniform2f(m_hStepXY, m_stepX, m_stepY);
   glUniform1f(m_hStretch, m_stretch);
   VerifyGLState();
+  if (m_glslOutput) m_glslOutput->OnEnabled();
   return true;
 }
 
+void ConvolutionFilterShader::OnDisabled()
+{
+  if (m_glslOutput) m_glslOutput->OnDisabled();
+}
+
 void ConvolutionFilterShader::Free()
 {
   if (m_kernelTex1)
     glDeleteTextures(1, &m_kernelTex1);
   m_kernelTex1 = 0;
+  if (m_glslOutput) m_glslOutput->Free();
   BaseVideoFilterShader::Free();
 }
 
diff --git a/xbmc/cores/VideoRenderers/VideoShaders/VideoFilterShader.h b/xbmc/cores/VideoRenderers/VideoShaders/VideoFilterShader.h
index 25717c1..4d21c21 100644
--- a/xbmc/cores/VideoRenderers/VideoShaders/VideoFilterShader.h
+++ b/xbmc/cores/VideoRenderers/VideoShaders/VideoFilterShader.h
@@ -29,6 +29,7 @@
 
 #include "guilib/Shader.h"
 #include "settings/VideoSettings.h"
+#include "GLSLOutput.h"
 
 namespace Shaders {
 
@@ -60,9 +61,11 @@ namespace Shaders {
   class ConvolutionFilterShader : public BaseVideoFilterShader
   {
   public:
-    ConvolutionFilterShader(ESCALINGMETHOD method, bool stretch, bool output=true);
+    ConvolutionFilterShader(ESCALINGMETHOD method, bool stretch, GLSLOutput *output=NULL);
+    ~ConvolutionFilterShader();
     void OnCompiledAndLinked();
     bool OnEnabled();
+    void OnDisabled();
     void Free();
 
     virtual bool GetTextureFilter(GLint& filter) { filter = GL_NEAREST; return true; }
@@ -77,6 +80,8 @@ namespace Shaders {
     ESCALINGMETHOD m_method;
     bool           m_floattex; //if float textures are supported
     GLint          m_internalformat;
+
+    Shaders::GLSLOutput *m_glslOutput;
   };
 
   class StretchFilterShader : public BaseVideoFilterShader
diff --git a/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.cpp b/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.cpp
index 17e622c..c243daa 100644
--- a/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.cpp
+++ b/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.cpp
@@ -94,7 +94,8 @@ void CalculateYUVMatrix(TransformMatrix &matrix
                         , unsigned int  flags
                         , ERenderFormat format
                         , float         black
-                        , float         contrast)
+                        , float         contrast
+                        , bool          limited)
 {
   TransformMatrix coef;
 
@@ -107,8 +108,7 @@ void CalculateYUVMatrix(TransformMatrix &matrix
       coef.m[row][col] = conv[col][row];
   coef.identity = false;
 
-
-  if(g_Windowing.UseLimitedColor())
+  if(g_Windowing.UseLimitedColor() || limited)
   {
     matrix *= TransformMatrix::CreateTranslation(+ 16.0f / 255
                                                , + 16.0f / 255
@@ -148,10 +148,11 @@ static void CalculateYUVMatrixGL(GLfloat      res[4][4]
                                , unsigned int flags
                                , ERenderFormat format
                                , float        black
-                               , float        contrast)
+                               , float        contrast
+                               , bool         limited)
 {
   TransformMatrix matrix;
-  CalculateYUVMatrix(matrix, flags, format, black, contrast);
+  CalculateYUVMatrix(matrix, flags, format, black, contrast, limited);
 
   for(int row = 0; row < 3; row++)
     for(int col = 0; col < 4; col++)
@@ -168,7 +169,7 @@ static void CalculateYUVMatrixGL(GLfloat      res[4][4]
 //////////////////////////////////////////////////////////////////////
 
 BaseYUV2RGBGLSLShader::BaseYUV2RGBGLSLShader(bool rect, unsigned flags, ERenderFormat format, bool stretch,
-                                             bool output)
+                                             GLSLOutput *output)
 {
   m_width      = 1;
   m_height     = 1;
@@ -205,10 +206,11 @@ BaseYUV2RGBGLSLShader::BaseYUV2RGBGLSLShader(bool rect, unsigned flags, ERenderF
   else
     m_defines += "#define XBMC_STRETCH 0\n";
 
-  if (output)
-    m_defines += "#define XBMC_OUTPUT 1\n";
-  else
-    m_defines += "#define XBMC_OUTPUT 0\n";
+  // get defines from the output stage if used
+  m_glslOutput = output;
+  if (m_glslOutput) {
+    m_defines += m_glslOutput->GetDefines();
+  }
 
   if (m_format == RENDER_FMT_YUV420P ||
       m_format == RENDER_FMT_YUV420P10 ||
@@ -250,6 +252,11 @@ BaseYUV2RGBGLSLShader::BaseYUV2RGBGLSLShader(bool rect, unsigned flags, ERenderF
   CLog::Log(LOGDEBUG, "GL: BaseYUV2RGBGLSLShader: defines:\n%s", m_defines.c_str());
 }
 
+BaseYUV2RGBGLSLShader::~BaseYUV2RGBGLSLShader()
+{
+  delete m_glslOutput;
+}
+
 void BaseYUV2RGBGLSLShader::OnCompiledAndLinked()
 {
 #if HAS_GLES == 2
@@ -268,6 +275,8 @@ void BaseYUV2RGBGLSLShader::OnCompiledAndLinked()
   m_hStretch = glGetUniformLocation(ProgramHandle(), "m_stretch");
   m_hStep    = glGetUniformLocation(ProgramHandle(), "m_step");
   VerifyGLState();
+
+  if (m_glslOutput) m_glslOutput->OnCompiledAndLinked(ProgramHandle());
 }
 
 bool BaseYUV2RGBGLSLShader::OnEnabled()
@@ -280,7 +289,8 @@ bool BaseYUV2RGBGLSLShader::OnEnabled()
   glUniform2f(m_hStep, 1.0 / m_width, 1.0 / m_height);
 
   GLfloat matrix[4][4];
-  CalculateYUVMatrixGL(matrix, m_flags, m_format, m_black, m_contrast);
+  // keep video levels
+  CalculateYUVMatrixGL(matrix, m_flags, m_format, m_black, m_contrast, true);
 
   glUniformMatrix4fv(m_hMatrix, 1, GL_FALSE, (GLfloat*)matrix);
 #if HAS_GLES == 2
@@ -289,9 +299,19 @@ bool BaseYUV2RGBGLSLShader::OnEnabled()
   glUniform1f(m_hAlpha, m_alpha);
 #endif
   VerifyGLState();
+  if (m_glslOutput) m_glslOutput->OnEnabled();
   return true;
 }
 
+void BaseYUV2RGBGLSLShader::OnDisabled()
+{
+  if (m_glslOutput) m_glslOutput->OnDisabled();
+}
+
+void BaseYUV2RGBGLSLShader::Free()
+{
+  if (m_glslOutput) m_glslOutput->Free();
+}
 //////////////////////////////////////////////////////////////////////
 // BaseYUV2RGBGLSLShader - base class for GLSL YUV2RGB shaders
 //////////////////////////////////////////////////////////////////////
@@ -317,7 +337,7 @@ BaseYUV2RGBARBShader::BaseYUV2RGBARBShader(unsigned flags, ERenderFormat format)
 //////////////////////////////////////////////////////////////////////
 
 YUV2RGBProgressiveShader::YUV2RGBProgressiveShader(bool rect, unsigned flags, ERenderFormat format, bool stretch,
-                                                   bool output)
+                                                   GLSLOutput *output)
   : BaseYUV2RGBGLSLShader(rect, flags, format, stretch, output)
 {
 #ifdef HAS_GL
@@ -413,7 +433,7 @@ void YUV2RGBProgressiveShaderARB::OnCompiledAndLinked()
 bool YUV2RGBProgressiveShaderARB::OnEnabled()
 {
   GLfloat matrix[4][4];
-  CalculateYUVMatrixGL(matrix, m_flags, m_format, m_black, m_contrast);
+  CalculateYUVMatrixGL(matrix, m_flags, m_format, m_black, m_contrast, false);
 
   for(int i=0;i<4;i++)
     glProgramLocalParameter4fARB(GL_FRAGMENT_PROGRAM_ARB, i
diff --git a/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.h b/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.h
index efa8d87..0f7b107 100644
--- a/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.h
+++ b/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.h
@@ -24,6 +24,8 @@
 #include "guilib/TransformMatrix.h"
 #include "cores/VideoRenderers/RenderFormats.h"
 
+#include "GLSLOutput.h"
+
 void CalculateYUVMatrix(TransformMatrix &matrix
                         , unsigned int  flags
                         , ERenderFormat format
@@ -70,8 +72,8 @@ namespace Shaders {
     , public CGLSLShaderProgram
   {
   public:
-    BaseYUV2RGBGLSLShader(bool rect, unsigned flags, ERenderFormat format, bool stretch, bool output=true);
-   ~BaseYUV2RGBGLSLShader() {}
+    BaseYUV2RGBGLSLShader(bool rect, unsigned flags, ERenderFormat format, bool stretch, GLSLOutput *output=NULL);
+   ~BaseYUV2RGBGLSLShader();
     virtual void SetField(int field) { m_field  = field; }
     virtual void SetWidth(int w)     { m_width  = w; }
     virtual void SetHeight(int h)    { m_height = h; }
@@ -92,6 +94,8 @@ namespace Shaders {
   protected:
     void OnCompiledAndLinked();
     bool OnEnabled();
+    void OnDisabled();
+    void Free();
 
     unsigned m_flags;
     ERenderFormat m_format;
@@ -105,6 +109,8 @@ namespace Shaders {
 
     string m_defines;
 
+    Shaders::GLSLOutput *m_glslOutput;
+
     // shader attribute handles
     GLint m_hYTex;
     GLint m_hUTex;
@@ -170,7 +176,11 @@ namespace Shaders {
   class YUV2RGBProgressiveShader : public BaseYUV2RGBGLSLShader
   {
   public:
-    YUV2RGBProgressiveShader(bool rect=false, unsigned flags=0, ERenderFormat format=RENDER_FMT_NONE, bool stretch = false, bool output=true);
+    YUV2RGBProgressiveShader(bool rect=false,
+                             unsigned flags=0,
+                             ERenderFormat format=RENDER_FMT_NONE,
+                             bool stretch = false,
+                             GLSLOutput *output=NULL);
   };
 
   class YUV2RGBBobShader : public BaseYUV2RGBGLSLShader
diff --git a/xbmc/cores/VideoRenderers/VideoShaders/dither.h b/xbmc/cores/VideoRenderers/VideoShaders/dither.h
new file mode 100644
index 0000000..d9a6bd7
--- /dev/null
+++ b/xbmc/cores/VideoRenderers/VideoShaders/dither.h
@@ -0,0 +1,72 @@
+// Generated with https://git.fruit.je/src?a=blob;f=dither/dither.c;h=913d06c11f8d7cbd24121ecd772396b7c10f4826;hb=HEAD
+
+#include <stdint.h>
+
+static const int dither_size = 64;
+static const int dither_size2 = 4096;
+static const uint16_t dither_matrix[] = {
+	   3, 2603,  743, 2361,  199, 2711,  806, 3181, 2113, 3820,  988, 3485, 1560, 2650,  327, 3063, 1660, 3340,  356, 1055, 2218, 2796, 3278,  528, 2104, 2909, 1465, 4076,  911, 3358, 1586, 3039,   41, 4038,  690, 3493,  155, 3754,  636, 3403,  271, 1355, 2973, 1816, 1287, 3908, 1095, 2549, 4086,  984, 3452,  357, 3560, 1662,   39, 1362, 2954, 1538,  552, 2823, 1871,  319, 2964,  792, 
+	3590, 1799, 4095, 1197, 3302, 2009, 3974, 1602,  475, 1433, 2801, 2059,  551, 4067, 1916,  914, 3887, 1308, 2969, 1817, 3780,  790, 1262, 1828, 3421,  802, 2454,  126, 3006, 2212,  536, 2513, 1029, 2142, 2920, 1641, 3178, 1902, 2848,  966, 2579, 3567, 2252,  142, 2798,  388, 3014, 2005,  216, 2285, 1583, 2994, 1091, 2813, 2002, 3712,  856, 4069, 2292, 1256, 3682, 2405, 1359, 3225, 
+	1046, 2855,  404, 2646, 1698,  545, 1138, 2982, 1985, 3610,  133, 3256, 1794,  971, 3167, 2251,  483, 2613,  668, 3468,   75, 3156, 2398, 3838,  201, 2690, 1060, 3599, 1820, 1168, 3890, 1743, 3564, 1487,  372, 2617, 1078,  462, 2193, 3915, 1659,  567, 1123, 3806, 1897, 3623,  849, 1483, 3513, 2857,  777, 2164, 3993,  584, 3338,  461, 2748, 1806,  206, 3264,  729, 1993, 3925,  492, 
+	2269, 1508, 3497,  927, 3743, 2109, 3469,  248, 2697, 1041, 2404, 1260, 3741, 2162,   52, 3526, 1214, 3722, 2085, 1449, 2557, 1938,  442, 1418, 2987, 1612, 3232, 2139,  654, 2884,  245, 2754,  621, 3060, 3858, 1341, 3698, 2948, 1436,   64, 3194, 2025, 3092, 1506,  595, 2216, 3252, 2632,  484, 1239, 3625,  122, 1864, 2589, 1475, 2360, 1195, 3588, 2536, 1010, 2890,  110, 2628, 1735, 
+	3110,  217, 1939, 2913,  101, 2483, 1274, 3124, 1636, 3791,  810, 3049,  417, 2828, 1416, 2515, 1992,  219, 3088,  844, 3343, 1171, 3632, 2201,  637, 3939,  354, 1330, 3800, 1943, 3284, 1390, 2347,  947, 2047,  200, 2128,  739, 3511, 2707, 1177, 4051,  336, 2501, 3472, 1316,   17, 2087, 3801, 1892, 2466, 1409, 3241, 1031, 3844,  152, 3123,  631, 1485, 3835, 1664, 3396, 1181, 3569, 
+	 890, 3790, 2353, 1098, 3229,  820, 3910,  448, 2319,  579, 2618, 1903, 3502,  873, 3988,  585, 3015, 1639, 2261, 4055,  292, 2809,  894, 3168, 1959,  995, 2627, 3128, 2282,  506, 1050, 3986,  125, 3537, 2804, 1533, 3291, 2523, 1860,  539, 2328,  829, 2866, 1965,  941, 2718, 4021, 1444,  877, 3210,  695, 3755,  391, 2980,  839, 3378, 1739, 2217, 3031,  351, 2334,  760, 2468,  413, 
+	2833, 1382,  553, 4013, 1886, 2660, 1512, 2092, 3541, 1391, 3950,  202, 1543, 2705, 1734, 3312,  990, 3765,  607, 1317, 2458, 1813, 3906,  134, 2390, 3415, 1671,   38, 1218, 3668, 2535, 1552, 2657, 1883,  518, 4094, 1028,  304, 3884, 1303, 3557, 1680, 3406,  203, 3717, 1854,  422, 2304, 2944,  249, 2651, 1757, 2297, 1576, 2706, 2014,  524, 3970, 1139, 2063, 3639, 1417, 4053, 1763, 
+	2150, 3450, 2616, 1247,  334, 3355,  650, 2955,   20, 3187,  885, 2178, 3352,  507, 2351,  162, 2735, 1492, 3254, 2030, 3544,  565, 1575, 2921, 1376,  547, 4037, 2017, 3337, 1730,  287, 3247,  660, 3048, 1201, 2383, 1935, 3138, 1594, 2902,  132, 2758, 1358, 2279,  763, 3203, 1574, 3527, 1157, 3938,  958, 3383, 1130, 4012,  234, 3545, 1335, 2558,   27, 3206,  651, 2949,  209, 3170, 
+	 977,   50, 1647, 3087, 2189, 1733, 3768, 1331, 2012, 2470, 1484, 2999,  979, 3863, 1288, 3603, 2147,  447, 2876,    6, 1122, 2673, 3368,  837, 3769, 2529,  965, 2699,  575, 2914, 2149,  954, 3693, 1635, 3441,   11, 3725,  780, 2425,  953, 3797, 2171,  677, 3957, 2587, 1108, 2849,  656, 2129, 1650, 2881,   63, 2612,  735, 2348,  951, 3106, 1614, 3490, 1834, 1223, 2597, 1523, 2306, 
+	3851, 1983, 3714,  599, 3524,  179, 2408,  904, 4050,  688, 3427,  369, 2671, 1994, 2931,  645, 1686, 3931, 1221, 2553, 3842, 2071,  305, 2276, 1829,  221, 3227, 1452, 3552, 1096, 3956, 1472, 2438,  335, 2187, 2889, 1428, 2746,  415, 3224, 1851, 1086, 2957,  350, 1764, 3393,  116, 2516, 3662,  398, 2209, 3716, 1310, 3464, 1480, 3762,  381, 2853,  772, 2374, 3943,  487, 3542,  616, 
+	1302, 2963,  925, 2731, 1148, 2869, 1414, 3026,  310, 2740, 1744, 3699, 1573,   76, 1126, 3300, 2493,  878, 3438, 1849,  785, 1478, 3653, 2765, 1085, 3605, 2246,  383, 1878, 2479,  106, 2841,  801, 3901, 1842,  610, 3518, 1104, 3996, 2270,  549, 3492, 2105, 3640,  931, 2224, 3916, 1866,  816, 3193, 1024, 1845, 3161,  502, 2990, 1942, 2475, 1035, 3673,  243, 1977, 3097, 1679, 2121, 
+	3318,  363, 2287, 1590, 3989,  500, 3453, 1796, 3659, 1240, 2331,  834, 3115, 2537, 4070, 2050,  212, 3079, 2267,  371, 2834, 3223, 1270,  527, 3130, 2052,  938, 2757, 3775,  740, 3471, 1656, 3281, 1062, 3102, 1349, 2512, 2090,  173, 1577, 3100, 1412,   40, 1931, 3152,  520, 1253, 2906, 1467, 2366, 4081,  254, 2089, 2522, 1174,  123, 4040, 2205, 1557, 3196, 1076, 2686,  103, 3920, 
+	 850, 2585, 3651,  147, 1909, 2562,  989, 2275,  761, 3235,  186, 3852, 1212, 1888,  603, 1399, 3749, 1561,  711, 3969, 2138,  158, 1997, 4079, 1615,   65, 3913, 1778, 1301, 3072, 2083,  394, 2599, 1990,  154, 3818,  480, 3351, 1827, 3665,  853, 2734, 4066, 1128, 2538, 1619, 3257,  192, 3606,  557, 1625, 2793,  867, 3894, 1791, 3366, 1384,  472, 2779,  843, 3802, 1332, 2434, 1453, 
+	2867, 1807, 1198, 2181, 3244, 1311, 3823,   81, 2649, 1381, 2776, 2046,  449, 3574, 2161, 3237, 1067, 2118, 2996, 1700, 1044, 3696, 2654,  759, 2455, 2966,  707, 3157,  256, 2362,  920, 4058,  671, 3601, 2263, 1528, 2976,  922, 2630,  373, 2432, 1971,  580, 3385,  289, 3770, 1960, 2598,  992, 2160, 3069, 1131, 3240,  370, 2745,  899, 3036, 1863, 3575, 2268,  399, 2953,  724, 3270, 
+	 314, 3516,  658, 3795,  412, 2997,  809, 3349, 1771, 3999,  702, 3449, 1657, 2621,  280, 2795,  512, 3615,   66, 2531, 3420,  477, 1568, 3357, 1250, 2100, 3508, 1001, 2006, 3727, 1397, 2988, 1812, 1135, 2800,  812, 1922, 3587, 1395, 3935, 1167, 3055, 1554, 2231, 2858, 1203,  773, 3964, 1703, 3433,    5, 3812, 1918, 2393, 1457, 3778,  664, 2569,   53, 1468, 3387, 1727, 4077, 2222, 
+	1037, 1966, 3089, 1367, 2762, 1694, 2355, 1087, 2837,  328, 2373, 1286, 3126,  961, 3928, 1746, 2430, 1230, 3177,  857, 1435, 2888, 2198,  264, 3777,  456, 1539, 2578, 3371,  592, 2655,   36, 2173, 3345,  297, 4010, 2397,   73, 2832,  661, 3310,  168, 3830,  691, 1420, 3547, 2305,  387, 2912,  742, 2643, 1544,  614, 3619,  164, 2172, 3316, 1259, 3978, 2042,  613, 2743,  210, 1413, 
+	3680, 2637,   13, 2316,  709, 4059,  220, 3670, 1569, 3285,  903, 3786,   31, 2293, 1354, 3342,  738, 4033, 2221, 1877, 3879,  728, 3246, 1926, 1141, 2821, 4006,  156, 1193, 1907, 3231, 1507, 3753,  948, 3083, 1667,  718, 3142, 1780, 2278, 1338, 2747, 1716, 3139, 2136,   94, 3085, 1978, 1356, 3723, 1065, 2101, 3008, 1300, 2831, 1899,  455, 3113,  939, 2898, 3608, 1097, 2126, 3147, 
+	 532, 1527, 3911, 1769, 3322, 1296, 2656, 2078,  563, 2000, 2586, 1714, 2926,  782, 2677,  181, 2938, 1535,  396, 2840,  197, 2435, 1032, 3626, 2542,  653, 2235, 1800, 2875, 3872,  353, 2456,  644, 2606, 1351, 2132, 3514, 1100, 3857,  324, 3451,  796, 2526,  419, 3747, 1766,  981, 3362, 2400,  187, 2728, 4023,  416, 3499,  881, 3849, 1521, 2431, 1841,  333, 2299, 1567, 3831,  964, 
+	2402, 3411, 1068, 2543,  340, 3109,  907, 3460, 1372, 3942,  259, 3408, 1103, 3631, 1632, 3813, 1049, 2043, 3581, 1344, 3332, 1604, 2983,   21, 1663, 3305, 1272, 3664,  519, 2208, 1048, 3555, 2029, 3949,  465, 2896,  228, 2623, 1579, 2478, 1450, 4045, 1147, 3326,  909, 2573, 4003,  513, 1249, 3532, 1775,  910, 2340, 1717, 2610,  624, 3391,  194, 3912, 2704,  765, 3243,  108, 2919, 
+	1689,  291, 2959,  826, 3779, 1626, 2250,   74, 2694,  847, 3013, 1460, 2401,  382, 2864,  627, 2463, 3140,  797, 2666,  515, 3990,  824, 2156, 3846,  341, 2911,  932, 2723, 1638, 3080, 1387,  149, 1748, 3266, 1202, 3711,  942, 3248,  744, 2970,   24, 2344, 1910, 2977,  232, 2107, 2892, 1850, 3047,  343, 2037, 3402,   85, 3220, 1278, 2200, 2854,  905, 1430, 3746, 1975, 2506,  686, 
+	3997, 2247, 1255, 3484, 2152,  544, 3034, 3870, 1520, 3528, 2180,  606, 4090, 1781, 2123, 3354, 1591,   80, 3767, 1955, 1245, 2363, 1750, 3165, 1089, 2472, 1566, 3455,   83, 4085,  692, 2685, 3475, 2356,  741, 2769, 1693, 2314,  395, 3637, 2070, 1658, 3467,  481, 1407, 3660, 1531,  753, 3819, 1047, 2532, 3902, 1161, 2491, 1621, 4065,  433, 1676, 3573, 2226,  490, 1189, 3091, 1790, 
+	 944, 3309, 1920,  135, 1440, 2799, 1859, 1115, 2427,  443, 1847, 2816,  993, 3041,  238, 1199, 3981, 2254,  949, 2900, 3456,  237, 3658,  548, 1961, 3024,  708, 2313, 1976, 1178, 3301, 2084,  556, 1321, 3880, 2015,   90, 4016, 1914, 2680,  970, 3118, 1194, 3930, 2508,  937, 3282, 2439,   57, 2777, 1578,  510, 3127,  769, 2939,  957, 2041, 3238,   28, 3019, 1890, 3389,  263, 3676, 
+	2076,  474, 3067, 2450, 4043,  800, 3556,  250, 3365, 1306, 3841,  107, 3419, 1410, 3570, 2197,  499, 3093, 1831,  425, 1550, 2652,  924, 2414, 4030,  190, 3546, 1007, 3708, 2645,  290, 1607, 3728, 2591,  358, 3205, 1162, 2863, 1346,  633, 3874,  279, 2766,  766, 2082, 3025,  438, 1946, 3629,  808, 3473, 2307, 1343, 3796,  265, 2415, 3729, 1323, 2473,  793, 3836, 1350, 2782, 1070, 
+	2624, 3860,  864, 1741,  437, 3098,  985, 2607, 1934, 2933,  828, 2703, 1889,  466, 2572, 1493, 2794, 1136, 3643, 2056, 3914, 1172, 3412, 1826, 1327, 3146, 1651, 2530,  440, 1486, 3073, 2242, 1033, 1815, 2972, 1515, 3463,  489, 2469, 3347, 1454, 2311, 1726, 3197,  124, 1622, 4091, 1156, 2170, 2946, 1835,  167, 2700, 1968, 3320, 1227,  469, 3121, 1018, 2727, 1761,  428, 1969, 3265, 
+	  60, 1524, 2301, 3593, 2683, 1269, 2207, 3891,  593, 1564, 3633, 1176, 2375, 3745,  967, 3904,  752, 3313,  180, 2452,  701, 2820,   59, 2923,  467, 2163,  866, 3941, 1898, 3392,  657, 3991,    2, 3592,  831, 2378,  982, 3798, 2099,  140, 3062,  876, 3737, 1279, 3548, 2376,  725, 3344,  301, 1318, 3961, 1107, 3562,  578, 1517, 2861, 2184, 1643, 3922,  193, 3479, 2309, 4088,  840, 
+	2487, 3498, 1235,  272, 2031, 3707,   33, 1394, 3148, 2120,  225, 3290,  731, 2044, 3208,    8, 2349, 1691, 2715, 1371, 3162, 1631, 2233, 3821, 1079, 3481, 2806,  112, 2929, 1054, 2420, 1446, 2847, 1933, 3180,  223, 2736, 1879, 1211, 3582, 1773, 2441,  424, 2648,  588, 1927, 2788, 1500, 3117, 2447,  602, 2880, 2190, 1856, 4015,   96, 3628,  604, 1913, 2882, 1319,  628, 1466, 3027, 
+	1688,  564, 2732, 3236,  715, 1613, 3306, 2273,  430, 3980, 2548, 1627, 2865,  348, 1722, 2958, 1309, 3690,  860, 4072,  397, 3561,  634, 1438, 2674, 1870,  663, 2377, 1295, 3825,  274, 3487, 1173,  550, 2169, 4060,  756, 3263,  367, 2611,  623, 4032, 2067, 3356, 1064, 3885,  178, 3645,  818, 1809, 3377, 1456,  375, 3137,  859, 2682, 1073, 3400, 2437,  913, 3242, 2604, 3638,  325, 
+	2206, 3898, 1982, 1084, 4018, 2521, 1020, 2856, 1832, 1234,  886, 3480, 1277, 4046, 2215, 1045, 3428,  283, 3021, 2027, 1284, 2642, 1912, 3262,  257, 3917, 1601, 3595, 2065,  716, 3212, 1633, 2687, 3703, 1021, 1674, 3029, 1378, 3896, 1609, 3018, 1365,   43, 1708, 2829, 1553, 2514, 1266, 2300, 3829,   14, 2525, 3720, 1292, 2380, 1718, 3050, 1464,  303, 3994, 2055,  114, 1923, 1142, 
+	3184, 1353,  145, 3001, 2102,  313, 3517,  679, 3685, 2016, 2915,   95, 2459,  641, 3163,  454, 2600, 1767, 2277,  586, 3444,  163, 3764,  962, 2429, 1140, 3191,  320, 2981, 1753, 2564,  845, 2054,  307, 3304, 2232,   79, 2659,  827, 2294, 1026, 3489, 2560, 3804,  361, 3287,  687, 3053,  408, 1375, 2985, 1774,  778, 3272,  262, 3900,  517, 2103, 3151,  726, 1565, 3759, 2502, 3520, 
+	 784, 2324, 3740, 1758,  955, 3131, 1546, 2413,  195, 3211,  786, 3757, 1785, 3535, 1434, 2049, 3882, 1124, 3735, 1459, 2554, 2079, 1505, 3040,  751, 2752, 1419, 2329,  972, 3736,  131, 3104, 3973, 1290, 2770,  672, 3448, 1762, 3694,  231, 3222,  521, 1963,  855, 2326, 1160, 3979, 1697, 3509, 2066,  617, 4052, 2290, 1600, 2810, 1158, 2570, 3549,  998, 2288, 2993, 1237,  503, 1777, 
+	2860,  414, 2726,  570, 3649, 2256,  841, 3862, 1322, 2561, 1652, 2280, 1069, 2583,  170, 2886,  673, 2443,   68, 3334,  734, 3953,  364, 2214, 3677,   32, 4063,  573, 3279, 1469, 2407, 1911,  511, 2343, 1504, 3807, 1053, 2381, 1297, 2785, 1653, 2417, 3646, 1445, 3169, 1996,  113, 2771,  999, 2546, 3253, 1188,  153, 3641,  591, 3414, 1900,   46, 1782, 3814,  240, 2196, 3417,  969, 
+	4047, 2114, 1481, 3381, 1952,   87, 2952, 2053, 3360,  589, 4022,  337, 3380,  833, 3960, 1603, 3293,  963, 3046, 1981, 2802,  991, 3174, 1824, 1164, 3132, 1620, 2676, 2081,  378, 3883, 1094, 2960, 3580,  174, 2034, 2878,  379, 3315,  612, 3983, 1238,  160, 2842,  562, 3404, 2399,  798, 3731,  269, 1562, 2907, 1973, 2631, 1403, 2320,  926, 3683, 2764, 1133, 3195, 1443, 2667, 1872, 
+	   0, 3099, 1027, 2462, 1191, 3982, 1617,  365, 1118, 3077, 1389, 2713, 1811, 2995, 2127,  482, 2011, 3598, 1655,  470, 1369, 3565, 2332,  649, 2850, 1930,  794, 3572, 1120, 3394,  887, 2609, 1587,  733, 1846, 3228,  836, 3888, 2010, 2688,  945, 2956, 2143, 1677, 3704, 1282, 1855, 2968, 1431, 2308, 3919,  453, 3386,  720, 3972,  345, 3221, 2001,  431, 2426,  667, 3893,  377, 3617, 
+	2039,  746, 3832,  296, 3286,  615, 2357, 3613, 1940, 2262,   37, 3578,  568, 1326, 3721, 1153, 2789,  270, 2541, 4035, 2203,  146, 1534, 3375,  306, 3871, 2186,  214, 2556, 1893, 3071,   56, 3350, 2074, 4089, 1186, 2626, 1491,   19, 1713, 3470,  390, 3803,  722, 2566,  299, 4075,  497, 3437, 1102, 1802, 2580, 1144, 1862, 2852, 1580, 2485, 1271, 4073, 1729, 2870, 1222, 2339,  872, 
+	3297, 2551, 1294, 2897, 1737, 2719, 1313, 3042,  771, 3810, 1490, 2411, 1949, 2664,  130, 3116, 1494, 3787, 1246,  598, 3260, 1848, 3773, 1112, 2480,  946, 2941, 1532, 4009,  611, 1682, 3824, 1226, 2729,  285, 3028,  534, 3531, 2509, 3150, 1265, 2385, 1405, 3329, 1768, 3108, 1190, 1987, 2724,   54, 3577,  842, 3808, 2219,  119, 3751,  700, 2986,  884, 3482,  100, 3215, 1408, 2759, 
+	1593,  478, 3558, 2062,  817, 3734,  207, 1797, 2581,  468, 3158,  815, 3945,  980, 3486, 2259,  770, 1788, 3185, 2370, 1030, 2903,  748, 2708, 1805, 3602,  530, 3218, 1248, 2238, 2894,  486, 2396,  851, 3622, 1666, 2354, 1137, 1947,  712, 4031,  902, 3009,   78, 2317,  803, 3533, 2486,  879, 3143, 2115, 3017,  317, 3209, 1244, 2058, 3407,  253, 2266, 1526, 2517,  767, 3657,  196, 
+	4011, 1861, 2346,  109, 3086, 1011, 2112, 4061, 1229, 3447, 1683, 2767,  282, 2891, 1843,  494, 3372, 2639,   16, 1951, 3705,  312, 2068, 4002,   70, 1455, 2756, 2003,  157, 3454, 1117, 3687, 1366, 3207, 2144,  674, 3869,  182, 3671, 2188,  277, 2684, 1598, 3881, 1061, 2822,  198, 1616, 3760, 1393,  569, 1673, 2712, 1522, 3591,  861, 2575, 1752, 3288, 1025, 3948, 1814, 2134, 3038, 
+	 933, 3239, 1213, 3897, 1582, 2423, 3182,  626, 2681,  136, 2327, 1127, 3612, 2179, 1182, 4093, 2095,  935, 3895,  697, 2528, 1597, 3033, 1152, 2359, 3325, 1016, 3799, 1756, 2593,  342, 2008, 2817,  121, 1497, 3280, 1760, 2786, 1285, 3084, 1732, 3597,  576, 1917, 3426, 1357, 3940, 2091,  376, 3335, 2013, 3877,  819, 2440,  401, 3070, 1345, 3866,  541, 2797,  288, 3333,  574, 1529, 
+	2457,  405, 2846,  659, 3395,  346, 1184, 3483, 1595, 3853,  901, 3275, 1755,  680, 3056,  229, 1581, 2975, 1348, 3330, 1233, 3609,  485, 3435,  705, 2048,  322, 2461,  736, 3944, 1545, 3341,  936, 4017, 2614,  402, 2428,  776, 3348,  488, 2584, 1228, 2158, 3061,  318, 2391,  632, 3022, 2453, 1043, 2778,  141, 2961, 1175, 4044, 1919,   25, 2159, 3145, 1624, 2336, 1225, 2629, 3840, 
+	1106, 3501, 2148, 1479, 2641, 1830, 2922, 1998,  504, 2096, 3005,  432, 2488, 3826, 1402, 2448, 3692,  366, 2225, 2772,  175, 2140, 2826, 1334, 2608, 3739, 1571, 3495, 2108, 1232, 2678,  559, 2325, 1905, 1145, 3503, 1360, 3955, 2124,  994, 3855,  151, 3370, 1013, 2737, 1709, 3630, 1462,  783, 4020, 1801, 1307, 3689, 2274,  629, 2670, 3538,  787, 1289, 3585,  917, 3742, 1684,   51, 
+	3002, 1712,  218, 3642,  749, 3954,   26, 3600, 1000, 2721, 1361, 3656, 1210,   58, 3153,  640, 1974, 3213,  898, 1819, 4026,  928, 1779, 3839,  139, 1056, 2989,  525, 3234,   10, 3553, 1648, 3792,  258, 3101,  699, 2838,   49, 1474, 2945, 1772, 2412, 1547, 4062,  822, 3245,    7, 2035, 3135,  298, 3384, 2192,  498, 1838, 3364, 1038, 1556, 3023, 2444,  177, 2716,  501, 2905, 2061, 
+	 883, 4084, 2602, 1200, 2386, 1392, 2812, 2248, 1728, 4027,  242, 1875, 2873, 2166, 1644, 3554, 1080, 2524, 3772,  505, 2369, 3160,  434, 2286, 3192, 1882, 2392, 1363, 2720, 1970, 1003, 2918,  895, 2763, 2106, 3730, 1585, 2379, 3589,  418, 3259,  669, 2773,  352, 2291, 1092, 2691, 3724, 1170, 2661,  952, 2862, 1518, 3043,  222, 2518, 3905,  360, 1692, 4019, 1936, 3432,  973, 3258, 
+	2245,  555, 1925, 3074,  444, 3319, 1066,  392, 3204,  813, 2358, 3461,  865, 3976,  458, 2644, 1839,  127, 1514, 2917, 1163, 2028, 3519, 1220,  642, 4068,  278, 3604,  605, 3975, 2503,  406, 3359, 1793, 1264,  471, 3328, 1059, 1921, 2672, 1254, 3794, 1364, 3621, 1789, 3488, 1563,  652, 2337, 1695, 3822,   82, 3465, 1231, 3672, 2045,  940, 2223, 3120,  685, 1320, 2367, 1784,  326, 
+	3766, 1519, 3424,  923, 3706, 1867, 2155, 3783, 1451, 2937, 1608,  543, 2596, 1477, 3336,  960, 3899, 2032, 3425,  863, 3661,   44, 1589, 2893, 2135, 1511, 3064, 1759, 2310, 1293, 1833, 3761, 2227,  102, 4078, 2033, 2702,  239, 3984,  732, 2228,   98, 2992,  713, 2590,  233, 2433, 3992,  384, 2965,  755, 2477, 1881,  681, 2775,  529, 1804, 3373, 1155, 2550, 3793,  148, 3507, 2693, 
+	1057, 2924,   93, 2714, 1588,  204, 2971,  694, 2544,  104, 3892, 1958, 3250,  189, 2130, 3003,  355, 3122,  648, 2582, 1740, 2213, 3932,  331, 3331,  891, 2533,  781, 3176,  185, 3004,  721, 1180, 3125, 2333,  908, 1654, 3096, 1421, 3431, 2825, 1736, 2125, 3339, 1423, 3058,  805, 1932, 3226, 1386, 3571, 1105, 4092, 2167, 1548, 3771, 2899,   69, 3607,  464, 1724, 3045, 1204, 1964, 
+	2389,  706, 3971, 1132, 2449, 3859, 1166, 3369, 1280, 3476,  930, 2422, 1268, 3718,  745, 1705, 2717, 1379, 2271, 3847,  450, 2814, 1022, 2692, 1315, 3647,   89, 3845, 1052, 3536, 1584, 2157, 3652, 1510,  682, 2868, 3624,  538, 2489, 1006,  362, 3876, 1051,  435, 3774, 1146, 3543, 1005, 2237,  191, 2023, 2636,  410, 3200,  183, 2321,  889, 2133, 1488, 2874, 2234,  643, 4041,  389, 
+	3594, 1642, 2094, 3295,  523, 2040, 2675,  359, 2295, 1853, 3051,  316, 2824, 1002, 2500, 4071, 1114, 3529,  211, 1304, 3075, 1441, 3382,  693, 2387, 1665, 2901, 1263, 2445, 1915,  581, 3308,  329, 2481, 3834,  188, 2165, 1217, 3750, 1876, 3283, 1470, 2725, 2281, 1702, 2815,   77, 2594, 3929, 1629, 3324,  906, 2940, 1267, 3523, 1388, 4008, 2662,  762, 3702, 1063, 2749, 1525, 3159, 
+	 852, 2998,  261, 2739, 1822,  976, 3550, 1672, 4057,  554, 1374, 3828, 1894, 3202,    4, 2220,  572, 1884, 3198, 2119,  723, 3618,  176, 2036, 3968,  427, 2183, 3401,  368, 4036, 2871, 1324, 2709, 1880, 1072, 3149, 1723, 2811,   23, 2394,  757, 2984,  159, 3966,  582, 2093, 3268, 1463,  618, 2859,  463, 3715, 1725, 2283,  655, 3068,  386, 1675, 3011,  266, 1986, 3410,   12, 2073, 
+	2474, 1216, 3732,  900, 3924, 2364,   47, 2830,  871, 2605, 3255, 2191,  597, 1610, 3443, 1406, 3655, 2555,  875, 3995, 1570, 2471, 1731, 3000,  804, 3230,  975, 1798, 2620,  897, 2211,   48, 3923,  835, 3446, 2257,  583, 3311, 1549, 4054, 2098, 1273, 3405, 1967, 1340, 3663,  862, 2007, 3748, 1219, 1924, 2416,   30, 3861, 1165, 2467, 1929, 3379, 1121, 3952, 2567,  915, 1787, 3909, 
+	 509, 3442, 1501, 2563,  457, 1559, 3353, 1352, 3654, 2060,  150, 1125, 3579, 2574, 1039, 2962,  323, 1628, 3010,   88, 2753,  535, 3713, 1040, 2663, 1891, 3811,  213, 3616, 1429, 3439, 1715, 2117, 2932,  380, 1385, 3889, 1110, 2592,  608, 3094,  411, 2547,  807, 3119,  338, 2315, 3037,  224, 3398, 2710, 1017, 3103, 1516, 3292,  236, 3744,  719, 2382, 1555,  537, 3522, 2647, 1305, 
+	2774, 2024,  128, 3190, 1945, 2947,  646, 2510,  421, 1236, 3936, 2698, 1792,  284, 3756,  832, 2322, 3867, 1090, 2241, 3323, 1333, 2137, 3141,   22, 1299, 2803, 2080,  768, 2835,  452, 3066,  639, 1243, 3679, 2635, 2019,  321, 3627, 1312, 1989, 3726, 1489, 3551, 2122, 1605, 4064, 1081, 1770, 2204,  666, 3998, 1858,  540, 2111, 2668, 1427, 2936,   97, 3129, 1895, 2210,  241, 3719, 
+	1009, 3307, 1810,  934, 3634, 1119, 3959, 1719, 3445, 2916, 1599,  533, 3179, 2365, 1447, 2844, 1953,  526, 3430, 1887,  789, 3815,  347, 1513, 4082, 2460,  542, 3172, 1670, 2260, 3987, 1368, 3510, 2240, 1808,  115, 3035, 1618, 2146, 3361,  184, 2335,  662, 2783,   42, 2925,  596, 2571, 3596,  956, 2877,  295, 2552, 3494,  987, 3926,  893, 1840, 3667, 1241, 3856, 1083, 3216,  727, 
+	2342,  409, 4080, 2436,  300, 2741, 2185,  171, 2026,  683, 2230, 3738, 1339,  747, 4005,  138, 3219, 1502, 2565,  255, 3076, 1699, 2368, 3418,  638, 1747, 3500, 1113, 3763,  120, 1023, 2689,  252, 2792,  774, 4025, 1008, 3217,  791, 2665, 1150, 4004, 1837,  997, 3850, 1437, 3413, 1984,  129, 3171, 1606, 3688, 1206, 2244, 1803,  429, 3112, 2418,  811, 2696,  344, 2496, 1749, 2967, 
+	1377, 2839, 1099, 2077, 3271,  838, 1442, 3583, 2679, 1034, 3054,   62, 2069, 3267, 1852, 2519, 1205, 3695,  869, 4024, 2176, 1101, 2974,  918, 2151, 2843,  267, 2406, 1496, 2951, 2174, 1690, 3817, 1143, 3299, 1979, 2495,  476, 3868, 1498, 2979,  493, 3134, 2490, 1937,  445, 2350,  854, 3946, 1169, 2341,  775, 3007,   84, 2805, 3563, 2097,  215, 3294, 1640, 3477,  870, 4014,   71, 
+	3678, 1711, 3504,  670, 1623, 3864, 2883,  546, 1645, 4034, 1396, 3457, 2634,  473, 1015, 3559,  423, 2202, 2887, 1611,  558, 3374,  137, 1896, 3644, 1075, 3937,  825, 3458,  460, 3691,  590, 2075, 3081,  439, 1337, 3440, 1742, 2318,   67, 1954, 3491, 1401,  230, 3648, 2751, 1328, 3012, 1687, 2658,  374, 3314, 1704, 4074, 1448,  620, 1329, 3958, 1999,  560, 2088, 2791, 1257, 2284, 
+	 821, 2492,  227, 3057, 2540,   29, 1258, 2239, 3016,  273, 2424,  635, 1251, 3684, 2255, 1681, 3105, 1432,   45, 3506, 2619, 1261, 3886, 2484,  436, 3107, 1701, 2625, 1380, 2352, 1551, 3199,  929, 2410, 1865, 3781,  246, 2942, 1185, 3681, 2588,  912, 2264, 3269, 1208,  714, 3752,  268, 3466,  730, 3837, 1242, 2722,  919, 2372, 3416, 2615,  880, 2851, 1476, 3788,  286, 3289, 1668, 
+	3399, 1314, 3921, 1795, 1036, 3478, 1948, 3697,  921, 3397, 1707, 3878, 2004, 2943,  166, 2733,  814, 3918, 2086,  978, 1957, 3155,  622, 1461, 2750, 2064,   61, 3346,  676, 3032,  205, 1821, 3977,    1, 2819,  892, 2442,  754, 3233,  566, 1537, 3963,  678, 1696, 2895, 1904, 2465, 1458, 2131, 2904, 1776, 2298,  226, 3710, 1988,  308, 1630, 3636,   34, 3095, 1116, 2464,  703, 2638, 
+	 385, 2781,  600, 2323, 3175,  764, 2808,  403, 1825, 2695, 1082, 2845,  339, 1499, 4087, 1179, 3376,  459, 2827, 3758,  294, 2345, 1818, 3409,  959, 3784, 1276, 1857, 4042, 1149, 3534, 2520, 1209, 3363, 1422, 3525, 1634, 4083, 2194, 1823, 3082,  293, 2633, 3530,   99, 3927,  531, 3114, 1058,    9, 3620,  874, 3277,  684, 3052, 1215, 3188, 1908, 2265,  758, 3434, 1885, 3967,  968, 
+	3701, 2022, 3459, 1503,  332, 4001, 1473, 2168, 3833,  117, 2338,  779, 3173, 2153,  609, 2576, 1637, 2409,  846, 1542, 3321, 1077, 4056,  169, 2978,  561, 3214, 2253,  400, 2807, 1928,  495, 2991,  689, 2177,  420, 2885, 1088,  172, 2761, 1281, 3422, 1991, 1109, 2388,  943, 3317, 1669, 4029, 2653, 1398, 2497, 1540, 2818, 1836, 3865,  522,  983, 4049, 2601, 1536,  165, 2182, 3164, 
+	1572,   92, 1183, 2927, 1873, 2451, 1093, 3201,  888, 3044, 1439, 3789, 1151, 3512, 1783, 3650,  251, 3274, 1868, 2669,  710, 2872, 1370, 2446, 2038, 1646, 2577, 1012, 3635, 2145,  974, 3805, 2272, 1738, 3933, 2527, 1342, 3303, 1944, 3843,  514, 2296,  788, 3709, 1592, 2780, 2020,  281, 2249,  665, 3462,  315, 3985, 1074,  111, 2534, 2018, 2930, 1411,  441, 3576, 2836, 1347,  508, 
+	2744, 2243, 3951,  696, 3666,  161, 3521,  516, 2494, 1962, 3436,  491, 2476,   15, 2760,  868, 2258, 1291, 3875,   91, 3700, 2141,  393, 3611,  750, 3903,  275, 3296, 1596,  105, 3144, 1541,  260, 3183, 1042,  118, 3686,  594, 2384,  996, 3539, 1710, 3133,  235, 3030,  587, 3785, 1154, 3020, 1941, 1196, 3154, 1720, 2236, 3474, 1325, 3614,  247, 3249, 1844, 2229, 1014, 3776, 1869, 
+	3515,  986, 1956, 2545, 1336, 3078, 2051, 1649, 4048,  309, 1192, 2787, 1721, 3388, 1426, 3965, 2928,  496, 2175, 3111, 1019, 1745, 3065, 1482, 3186, 1252, 2879,  698, 2507, 3947,  896, 2742, 3586, 1400, 2110, 2934, 1706, 2738, 1383, 2950,   35, 2482, 1425, 4039, 1187, 2505, 1509, 3390,  479, 3873, 2395,  848, 2768,  407, 2910,  619, 1754, 2755, 1207, 3816,  717, 3059,  276, 2498, 
+	 647, 2908,  311, 3166,  571, 2303,  916, 2935, 1283, 3276, 1874, 3907,  823, 2302,  577, 1995, 1129, 3566, 1415,  601, 2539, 3540,  858, 2595,   18, 2330, 1751, 3505, 1111, 1906, 2403,  625, 2199,  446, 3782,  799, 3367,  349, 4007,  830, 3251, 1071, 2730,  426, 1972, 3568,   72, 2154, 2790, 1404,  144, 3674, 1471, 3854, 1004, 2072, 3934,  882, 2419,   86, 2640, 1685, 3298, 1530, 
+	3848, 1373, 3429, 1661, 3809, 1424, 3584,   55, 2622,  675, 2421,  208, 3090, 1224, 3675, 2504,  143, 2057, 2701, 4028, 1558,  244, 1980, 3962, 1159, 3669,  451, 2021, 2784,  302, 3733, 1298, 3261, 1786, 2568, 1275, 2289, 1495, 2499, 1765, 2116, 3827,  704, 3423, 2371,  795, 3189, 1678,  630, 3136, 1901, 2559,  737, 2195, 3273, 2511,  330, 3327, 1950, 3496,  950, 4000, 1134, 2312, 
+};
-- 
1.9.1


From 31f4f5233a303e8cbee453bad34ab23e7a0243ed Mon Sep 17 00:00:00 2001
From: Lauri Myllari <lauri.myllari@gmail.com>
Date: Sun, 17 May 2015 21:50:21 -0700
Subject: [PATCH 11/21] settings: add video dither depth

---
 addons/resource.language.en_gb/resources/strings.po   | 15 +++++++++++++--
 system/settings/settings.xml                          | 11 +++++++++++
 xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.cpp |  3 ++-
 xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.h   |  1 +
 xbmc/windowing/WinSystem.cpp                          | 10 ++++++++++
 xbmc/windowing/WinSystem.h                            |  2 ++
 6 files changed, 39 insertions(+), 3 deletions(-)

diff --git a/addons/resource.language.en_gb/resources/strings.po b/addons/resource.language.en_gb/resources/strings.po
index faf423c..af57a66 100644
--- a/addons/resource.language.en_gb/resources/strings.po
+++ b/addons/resource.language.en_gb/resources/strings.po
@@ -14102,7 +14102,12 @@ msgctxt "#36042"
 msgid "Use limited colour range (16-235)"
 msgstr ""
 
-#empty strings from id 36043 to 36100
+#: system/settings/settings.xml
+msgctxt "#36043"
+msgid "Dither depth"
+msgstr ""
+
+#empty strings from id 36044 to 36100
 #strings from 36100 to 36999 are reserved for settings descriptions
 
 #. Description of settings section "Appearance"
@@ -16254,7 +16259,13 @@ msgctxt "#36549"
 msgid "Use iOS8 compatible AirPlay support. If you have trouble with older iOS devices detecting this application as a valid target try switching this off. This option requires a restart to take effect!"
 msgstr ""
 
-#empty strings from id 36550 to 36599
+#. Description of setting "System -> Video output -> Dither depth" with label #36045
+#: system/settings/settings.xml
+msgctxt "#36550"
+msgid "Video dithering depth in bits"
+msgstr ""
+
+#empty strings from id 36551 to 36599
 #reserved strings 365XX
 
 #. Description of settings category "Music -> Library" with label #14022
diff --git a/system/settings/settings.xml b/system/settings/settings.xml
index 3ef33e0..83144ef 100644
--- a/system/settings/settings.xml
+++ b/system/settings/settings.xml
@@ -2494,6 +2494,17 @@
           </updates>
           <control type="toggle" />
         </setting>
+        <setting id="videoscreen.ditherdepth" type="integer" label="36043" help="36550">
+          <requirement>HAS_GL</requirement>
+          <level>3</level>
+          <default>8</default>
+          <constraints>
+            <minimum>2</minimum>
+            <step>1</step>
+            <maximum>8</maximum>
+          </constraints>
+          <control type="spinner" format="integer" />
+        </setting>
       </group>
     </category>
     <category id="audiooutput" label="772" help="36360">
diff --git a/xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.cpp b/xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.cpp
index 5f9b075..2312689 100644
--- a/xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.cpp
+++ b/xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.cpp
@@ -43,6 +43,7 @@ GLSLOutput::GLSLOutput(int texunit)
   m_hDitherSize  = -1;
 
   m_dither = true; // hardcode dithering for now
+  m_ditherDepth = g_Windowing.DitherDepth();
   m_fullRange = !g_Windowing.UseLimitedColor();
 }
 
@@ -110,7 +111,7 @@ bool GLSLOutput::OnEnabled()
     VerifyGLState();
 
     // dither settings
-    glUniform1f(m_hDitherQuant, 255.0); // (1<<depth)-1
+    glUniform1f(m_hDitherQuant, (1<<m_ditherDepth)-1.0);
     VerifyGLState();
     glUniform2f(m_hDitherSize, dither_size, dither_size);
     VerifyGLState();
diff --git a/xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.h b/xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.h
index a4dba4f..4119923 100644
--- a/xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.h
+++ b/xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.h
@@ -42,6 +42,7 @@ namespace Shaders {
     void FreeTextures();
 
     bool m_dither;
+    unsigned m_ditherDepth;
     bool m_fullRange;
     // first texture unit available to us
     int m_1stTexUnit;
diff --git a/xbmc/windowing/WinSystem.cpp b/xbmc/windowing/WinSystem.cpp
index d674f24..2b56745 100644
--- a/xbmc/windowing/WinSystem.cpp
+++ b/xbmc/windowing/WinSystem.cpp
@@ -252,6 +252,16 @@ bool CWinSystemBase::UseLimitedColor()
 #endif
 }
 
+unsigned CWinSystemBase::DitherDepth()
+{
+#if defined(HAS_GL)
+  static CSettingInt* setting = (CSettingInt*)CSettings::Get().GetSetting("videoscreen.ditherdepth");
+  return setting->GetValue();
+#else
+  return 8;
+#endif
+}
+
 std::string CWinSystemBase::GetClipboardText(void)
 {
   return "";
diff --git a/xbmc/windowing/WinSystem.h b/xbmc/windowing/WinSystem.h
index b922156..33198b3 100644
--- a/xbmc/windowing/WinSystem.h
+++ b/xbmc/windowing/WinSystem.h
@@ -77,6 +77,8 @@ public:
   //does the output expect limited color range (ie 16-235)
   virtual bool UseLimitedColor();
 
+  virtual unsigned DitherDepth();
+
   virtual bool Minimize() { return false; }
   virtual bool Restore() { return false; }
   virtual bool Hide() { return false; }
-- 
1.9.1


From 82178e8554bdcb8c2ee5cc37542e3cdfe4fa8e09 Mon Sep 17 00:00:00 2001
From: Lauri Myllari <lauri.myllari@gmail.com>
Date: Wed, 24 Jun 2015 22:57:35 -0700
Subject: [PATCH 12/21] gl: fix GLSLOutput includes

---
 xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.cpp | 6 +++++-
 xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.h   | 2 ++
 2 files changed, 7 insertions(+), 1 deletion(-)

diff --git a/xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.cpp b/xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.cpp
index 2312689..9df2aa4 100644
--- a/xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.cpp
+++ b/xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.cpp
@@ -20,10 +20,14 @@
  *
  */
 
+#include "system.h"
+#include "GLSLOutput.h"
 #include "windowing/WindowingFactory.h"
 #include "utils/log.h"
+#if defined(HAS_GL) || defined(HAS_GLES)
+#include "utils/GLUtils.h"
+#endif
 
-#include "GLSLOutput.h"
 #include "dither.h"
 
 using namespace Shaders;
diff --git a/xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.h b/xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.h
index 4119923..080023c 100644
--- a/xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.h
+++ b/xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.h
@@ -25,6 +25,8 @@
 #include "system.h"
 #include "utils/GLUtils.h"
 
+#include <string>
+
 namespace Shaders {
 
   class GLSLOutput
-- 
1.9.1


From fd86830d1dd4d950285261039c1c3520454ef5c9 Mon Sep 17 00:00:00 2001
From: Lauri Myllari <lauri.myllari@gmail.com>
Date: Thu, 25 Jun 2015 21:49:19 -0700
Subject: [PATCH 13/21] settings: add video dithering toggle

---
 addons/resource.language.en_gb/resources/strings.po   | 17 ++++++++++++++---
 system/settings/settings.xml                          |  9 +++++++++
 xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.cpp |  2 +-
 xbmc/windowing/WinSystem.cpp                          | 10 ++++++++++
 xbmc/windowing/WinSystem.h                            |  1 +
 5 files changed, 35 insertions(+), 4 deletions(-)

diff --git a/addons/resource.language.en_gb/resources/strings.po b/addons/resource.language.en_gb/resources/strings.po
index af57a66..dd341f2 100644
--- a/addons/resource.language.en_gb/resources/strings.po
+++ b/addons/resource.language.en_gb/resources/strings.po
@@ -14107,7 +14107,12 @@ msgctxt "#36043"
 msgid "Dither depth"
 msgstr ""
 
-#empty strings from id 36044 to 36100
+#: system/settings/settings.xml
+msgctxt "#36044"
+msgid "Dithering"
+msgstr ""
+
+#empty strings from id 36045 to 36100
 #strings from 36100 to 36999 are reserved for settings descriptions
 
 #. Description of settings section "Appearance"
@@ -16259,13 +16264,19 @@ msgctxt "#36549"
 msgid "Use iOS8 compatible AirPlay support. If you have trouble with older iOS devices detecting this application as a valid target try switching this off. This option requires a restart to take effect!"
 msgstr ""
 
-#. Description of setting "System -> Video output -> Dither depth" with label #36045
+#. Description of setting "System -> Video output -> Dither depth" with label #36043
 #: system/settings/settings.xml
 msgctxt "#36550"
 msgid "Video dithering depth in bits"
 msgstr ""
 
-#empty strings from id 36551 to 36599
+#. Description of setting "System -> Video output -> Dither" with label #36044
+#: system/settings/settings.xml
+msgctxt "#36551"
+msgid "Dither video output to eliminate banding and allow greater than 8bit precision."
+msgstr ""
+
+#empty strings from id 36552 to 36599
 #reserved strings 365XX
 
 #. Description of settings category "Music -> Library" with label #14022
diff --git a/system/settings/settings.xml b/system/settings/settings.xml
index 83144ef..a76125d 100644
--- a/system/settings/settings.xml
+++ b/system/settings/settings.xml
@@ -2494,6 +2494,12 @@
           </updates>
           <control type="toggle" />
         </setting>
+        <setting id="videoscreen.dither" type="boolean" label="36044" help="36551">
+          <requirement>HAS_GL</requirement>
+          <level>3</level>
+          <default>true</default>
+          <control type="toggle" />
+        </setting>
         <setting id="videoscreen.ditherdepth" type="integer" label="36043" help="36550">
           <requirement>HAS_GL</requirement>
           <level>3</level>
@@ -2503,6 +2509,9 @@
             <step>1</step>
             <maximum>8</maximum>
           </constraints>
+          <dependencies>
+            <dependency type="visible" setting="videoscreen.dither" operator="is">true</dependency>
+          </dependencies>
           <control type="spinner" format="integer" />
         </setting>
       </group>
diff --git a/xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.cpp b/xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.cpp
index 9df2aa4..e228bde 100644
--- a/xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.cpp
+++ b/xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.cpp
@@ -46,7 +46,7 @@ GLSLOutput::GLSLOutput(int texunit)
   m_hDitherQuant = -1;
   m_hDitherSize  = -1;
 
-  m_dither = true; // hardcode dithering for now
+  m_dither = g_Windowing.UseDithering();
   m_ditherDepth = g_Windowing.DitherDepth();
   m_fullRange = !g_Windowing.UseLimitedColor();
 }
diff --git a/xbmc/windowing/WinSystem.cpp b/xbmc/windowing/WinSystem.cpp
index 2b56745..5b7a067 100644
--- a/xbmc/windowing/WinSystem.cpp
+++ b/xbmc/windowing/WinSystem.cpp
@@ -252,6 +252,16 @@ bool CWinSystemBase::UseLimitedColor()
 #endif
 }
 
+bool CWinSystemBase::UseDithering()
+{
+#if defined(HAS_GL)
+  static CSettingBool* setting = (CSettingBool*)CSettings::Get().GetSetting("videoscreen.dither");
+  return setting->GetValue();
+#else
+  return false;
+#endif
+}
+
 unsigned CWinSystemBase::DitherDepth()
 {
 #if defined(HAS_GL)
diff --git a/xbmc/windowing/WinSystem.h b/xbmc/windowing/WinSystem.h
index 33198b3..a9e5515 100644
--- a/xbmc/windowing/WinSystem.h
+++ b/xbmc/windowing/WinSystem.h
@@ -77,6 +77,7 @@ public:
   //does the output expect limited color range (ie 16-235)
   virtual bool UseLimitedColor();
 
+  virtual bool UseDithering();
   virtual unsigned DitherDepth();
 
   virtual bool Minimize() { return false; }
-- 
1.9.1


From 51a23d4cf607f18123a41f558974fd740edcf233 Mon Sep 17 00:00:00 2001
From: Lauri Myllari <lauri.myllari@gmail.com>
Date: Fri, 26 Jun 2015 22:21:58 -0700
Subject: [PATCH 14/21] gl: disable dither texture after rendering only when
 dithering is used

---
 xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.cpp | 6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)

diff --git a/xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.cpp b/xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.cpp
index e228bde..989e69e 100644
--- a/xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.cpp
+++ b/xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.cpp
@@ -128,8 +128,10 @@ bool GLSLOutput::OnEnabled()
 void GLSLOutput::OnDisabled()
 {
   // disable textures
-  glActiveTexture(GL_TEXTURE0 + m_uDither);
-  glDisable(GL_TEXTURE_2D);
+  if (m_dither) {
+    glActiveTexture(GL_TEXTURE0 + m_uDither);
+    glDisable(GL_TEXTURE_2D);
+  }
   glActiveTexture(GL_TEXTURE0);
   VerifyGLState();
 }
-- 
1.9.1


From 372fd0a34f8cf7012a9a32152cf08e6390c2ec43 Mon Sep 17 00:00:00 2001
From: Lauri Myllari <lauri.myllari@gmail.com>
Date: Sat, 27 Jun 2015 09:17:25 -0700
Subject: [PATCH 15/21] settings: better descriptions for the dither settings

---
 addons/resource.language.en_gb/resources/strings.po | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/addons/resource.language.en_gb/resources/strings.po b/addons/resource.language.en_gb/resources/strings.po
index dd341f2..3b50282 100644
--- a/addons/resource.language.en_gb/resources/strings.po
+++ b/addons/resource.language.en_gb/resources/strings.po
@@ -16267,13 +16267,13 @@ msgstr ""
 #. Description of setting "System -> Video output -> Dither depth" with label #36043
 #: system/settings/settings.xml
 msgctxt "#36550"
-msgid "Video dithering depth in bits"
+msgid "Video dithering output precision in bits. Use the highest setting that doesn't show banding. The default of 8 is recommended for most systems. If your GPU is set to scale the output RGB levels or you use a laptop screen, a 7 or 6 bit setting may eliminate more banding. Lower settings are available for testing purposes only to make it easy to see whether dithering is applied and that the dither noise pixel size matches the display resolution."
 msgstr ""
 
 #. Description of setting "System -> Video output -> Dither" with label #36044
 #: system/settings/settings.xml
 msgctxt "#36551"
-msgid "Dither video output to eliminate banding and allow greater than 8bit precision."
+msgid "Eliminate banding caused by RGB level conversion or other processing by adding a small amount of noise to the picture. This can be disabled for slower systems, or when Kodi is set to limited range RGB output and no video processing is needed."
 msgstr ""
 
 #empty strings from id 36552 to 36599
-- 
1.9.1


From 3eff212bc7d46f89cc5594f254d3c63ba33faca4 Mon Sep 17 00:00:00 2001
From: fritsch <Peter.Fruehberger@gmail.com>
Date: Fri, 10 Jul 2015 08:34:46 +0200
Subject: [PATCH 16/21] VAAPI: Use upstreamed fourcc RG88

---
 xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp
index bde6ad3..2c4168f 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp
@@ -1252,7 +1252,7 @@ bool CVaapiRenderPicture::GLMapSurface()
 
       attrib = attribs;
       *attrib++ = EGL_LINUX_DRM_FOURCC_EXT;
-      *attrib++ = fourcc_code('G', 'R', '1', '6');
+      *attrib++ = fourcc_code('G', 'R', '8', '8');
       *attrib++ = EGL_WIDTH;
       *attrib++ = (glInterop.vaImage.width + 1) >> 1;
       *attrib++ = EGL_HEIGHT;
-- 
1.9.1


From f1a47fa97e2249c9b7678d2c5b3b9332af456eb3 Mon Sep 17 00:00:00 2001
From: fritsch <Peter.Fruehberger@gmail.com>
Date: Thu, 9 Jul 2015 22:07:35 +0200
Subject: [PATCH 17/21] PlatformDefs: Fix compilation issue on i386 (revisit me
 later)

---
 xbmc/linux/PlatformDefs.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/xbmc/linux/PlatformDefs.h b/xbmc/linux/PlatformDefs.h
index 4350075..6b25dd4 100644
--- a/xbmc/linux/PlatformDefs.h
+++ b/xbmc/linux/PlatformDefs.h
@@ -164,7 +164,7 @@
 #if defined(__x86_64__) || defined(__powerpc__) || defined(__ppc__) || defined (__arm__) || defined(__mips__) // should this be powerpc64 only?
 #define __stdcall
 #else /* !__x86_64__ */
-#define __stdcall   __attribute__((__stdcall__))
+#define __stdcall
 #endif /* __x86_64__ */
 #define __cdecl
 #define WINBASEAPI
-- 
1.9.1


From 5bf2985aaaced0279a4e5a1e3c6d3bf10490a3e2 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Fri, 17 Jul 2015 08:04:47 +0200
Subject: [PATCH 18/21] renderer: fix forced deinterlacing for non-render
 methods

---
 xbmc/cores/VideoRenderers/RenderManager.cpp | 21 ++++++++++++---------
 1 file changed, 12 insertions(+), 9 deletions(-)

diff --git a/xbmc/cores/VideoRenderers/RenderManager.cpp b/xbmc/cores/VideoRenderers/RenderManager.cpp
index 8122f77..87e858a 100644
--- a/xbmc/cores/VideoRenderers/RenderManager.cpp
+++ b/xbmc/cores/VideoRenderers/RenderManager.cpp
@@ -864,17 +864,20 @@ void CXBMCRenderManager::FlipPage(volatile bool& bStop, double timestamp /* = 0L
         else if (interlacemethod == VS_INTERLACEMETHOD_IMX_FASTMOTION_DOUBLE)   presentmethod = PRESENT_METHOD_BOB;
         else                                                                    presentmethod = PRESENT_METHOD_SINGLE;
 
-        /* default to odd field if we want to deinterlace and don't know better */
-        if (deinterlacemode == VS_DEINTERLACEMODE_FORCE && sync == FS_NONE)
-          sync = FS_TOP;
-
-        /* invert present field */
-        if(invert)
+        if (presentmethod != PRESENT_METHOD_SINGLE)
         {
-          if( sync == FS_BOT )
+          /* default to odd field if we want to deinterlace and don't know better */
+          if (deinterlacemode == VS_DEINTERLACEMODE_FORCE && sync == FS_NONE)
             sync = FS_TOP;
-          else
-            sync = FS_BOT;
+
+          /* invert present field */
+          if (invert)
+          {
+            if (sync == FS_BOT)
+              sync = FS_TOP;
+            else
+              sync = FS_BOT;
+          }
         }
       }
     }
-- 
1.9.1

